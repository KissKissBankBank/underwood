var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
import React$a, { createContext, useReducer, useContext, useRef, useState, useEffect } from "react";
import require$$0$2 from "react-dom";
import { ScreenConfig, CONTAINER_PADDING, CONTAINER_PADDING_THIN, useLazyObserver, LazyObserver, ResponsiveIframeContainer, parseHtml, domElementHelper, Button as Button$1, BUTTON_STYLE_ICON, buttonModifierStyles, pxToRem, COLORS, BoldIcon, ItalicIcon, ListIcon, AlignLeftIcon, AlignCenterIcon, AlignRightIcon, ImageIcon, VideoIcon, LinkIcon, EditorButtonIcon, BlockquoteIcon, Field, TextInputWithButton, VisuallyHidden, ModalNext, Title as Title$1, ArrowContainer, Text, TYPOGRAPHY, Paragraph, Details, ArrowIcon, ParagraphIcon, Title4Icon, Title3Icon, Title2Icon, Title1Icon } from "@kisskissbankbank/kitten";
import styled, { keyframes, createGlobalStyle, css } from "styled-components";
import { useField, ErrorMessage, Formik, useFormikContext } from "formik";
import * as Yup from "yup";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a = Object.defineProperty({}, "__esModule", {
    value: true
  });
  Object.keys(n2).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k];
      }
    });
  });
  return a;
}
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction$2() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction$2;
var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
    err.name = "Invariant Violation";
    throw err;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction$2
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes.exports = factoryWithThrowingShims();
}
var PropTypes = propTypes.exports;
var immutable$1 = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    var SLICE$0 = Array.prototype.slice;
    function createClass(ctor, superClass) {
      if (superClass) {
        ctor.prototype = Object.create(superClass.prototype);
      }
      ctor.prototype.constructor = ctor;
    }
    function Iterable(value) {
      return isIterable(value) ? value : Seq2(value);
    }
    createClass(KeyedIterable, Iterable);
    function KeyedIterable(value) {
      return isKeyed2(value) ? value : KeyedSeq2(value);
    }
    createClass(IndexedIterable, Iterable);
    function IndexedIterable(value) {
      return isIndexed2(value) ? value : IndexedSeq2(value);
    }
    createClass(SetIterable, Iterable);
    function SetIterable(value) {
      return isIterable(value) && !isAssociative2(value) ? value : SetSeq2(value);
    }
    function isIterable(maybeIterable) {
      return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
    }
    function isKeyed2(maybeKeyed) {
      return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
    }
    function isIndexed2(maybeIndexed) {
      return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
    }
    function isAssociative2(maybeAssociative) {
      return isKeyed2(maybeAssociative) || isIndexed2(maybeAssociative);
    }
    function isOrdered2(maybeOrdered) {
      return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
    }
    Iterable.isIterable = isIterable;
    Iterable.isKeyed = isKeyed2;
    Iterable.isIndexed = isIndexed2;
    Iterable.isAssociative = isAssociative2;
    Iterable.isOrdered = isOrdered2;
    Iterable.Keyed = KeyedIterable;
    Iterable.Indexed = IndexedIterable;
    Iterable.Set = SetIterable;
    var IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
    var IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
    var IS_INDEXED_SENTINEL = "@@__IMMUTABLE_INDEXED__@@";
    var IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
    var DELETE2 = "delete";
    var SHIFT2 = 5;
    var SIZE2 = 1 << SHIFT2;
    var MASK2 = SIZE2 - 1;
    var NOT_SET2 = {};
    var CHANGE_LENGTH = {
      value: false
    };
    var DID_ALTER = {
      value: false
    };
    function MakeRef2(ref) {
      ref.value = false;
      return ref;
    }
    function SetRef2(ref) {
      ref && (ref.value = true);
    }
    function OwnerID2() {
    }
    function arrCopy2(arr, offset) {
      offset = offset || 0;
      var len = Math.max(0, arr.length - offset);
      var newArr = new Array(len);
      for (var ii = 0; ii < len; ii++) {
        newArr[ii] = arr[ii + offset];
      }
      return newArr;
    }
    function ensureSize2(iter) {
      if (iter.size === void 0) {
        iter.size = iter.__iterate(returnTrue3);
      }
      return iter.size;
    }
    function wrapIndex2(iter, index) {
      if (typeof index !== "number") {
        var uint32Index = index >>> 0;
        if ("" + uint32Index !== index || uint32Index === 4294967295) {
          return NaN;
        }
        index = uint32Index;
      }
      return index < 0 ? ensureSize2(iter) + index : index;
    }
    function returnTrue3() {
      return true;
    }
    function wholeSlice2(begin, end, size) {
      return (begin === 0 || size !== void 0 && begin <= -size) && (end === void 0 || size !== void 0 && end >= size);
    }
    function resolveBegin2(begin, size) {
      return resolveIndex2(begin, size, 0);
    }
    function resolveEnd2(end, size) {
      return resolveIndex2(end, size, size);
    }
    function resolveIndex2(index, size, defaultIndex) {
      return index === void 0 ? defaultIndex : index < 0 ? Math.max(0, size + index) : size === void 0 ? index : Math.min(size, index);
    }
    var ITERATE_KEYS2 = 0;
    var ITERATE_VALUES2 = 1;
    var ITERATE_ENTRIES2 = 2;
    var REAL_ITERATOR_SYMBOL2 = typeof Symbol === "function" && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL2 = "@@iterator";
    var ITERATOR_SYMBOL2 = REAL_ITERATOR_SYMBOL2 || FAUX_ITERATOR_SYMBOL2;
    function Iterator3(next) {
      this.next = next;
    }
    Iterator3.prototype.toString = function() {
      return "[Iterator]";
    };
    Iterator3.KEYS = ITERATE_KEYS2;
    Iterator3.VALUES = ITERATE_VALUES2;
    Iterator3.ENTRIES = ITERATE_ENTRIES2;
    Iterator3.prototype.inspect = Iterator3.prototype.toSource = function() {
      return this.toString();
    };
    Iterator3.prototype[ITERATOR_SYMBOL2] = function() {
      return this;
    };
    function iteratorValue2(type, k, v, iteratorResult) {
      var value = type === 0 ? k : type === 1 ? v : [k, v];
      iteratorResult ? iteratorResult.value = value : iteratorResult = {
        value,
        done: false
      };
      return iteratorResult;
    }
    function iteratorDone2() {
      return {
        value: void 0,
        done: true
      };
    }
    function hasIterator2(maybeIterable) {
      return !!getIteratorFn2(maybeIterable);
    }
    function isIterator2(maybeIterator) {
      return maybeIterator && typeof maybeIterator.next === "function";
    }
    function getIterator2(iterable) {
      var iteratorFn = getIteratorFn2(iterable);
      return iteratorFn && iteratorFn.call(iterable);
    }
    function getIteratorFn2(iterable) {
      var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL2 && iterable[REAL_ITERATOR_SYMBOL2] || iterable[FAUX_ITERATOR_SYMBOL2]);
      if (typeof iteratorFn === "function") {
        return iteratorFn;
      }
    }
    function isArrayLike2(value) {
      return value && typeof value.length === "number";
    }
    createClass(Seq2, Iterable);
    function Seq2(value) {
      return value === null || value === void 0 ? emptySequence2() : isIterable(value) ? value.toSeq() : seqFromValue2(value);
    }
    Seq2.of = function() {
      return Seq2(arguments);
    };
    Seq2.prototype.toSeq = function() {
      return this;
    };
    Seq2.prototype.toString = function() {
      return this.__toString("Seq {", "}");
    };
    Seq2.prototype.cacheResult = function() {
      if (!this._cache && this.__iterateUncached) {
        this._cache = this.entrySeq().toArray();
        this.size = this._cache.length;
      }
      return this;
    };
    Seq2.prototype.__iterate = function(fn, reverse3) {
      return seqIterate(this, fn, reverse3, true);
    };
    Seq2.prototype.__iterator = function(type, reverse3) {
      return seqIterator(this, type, reverse3, true);
    };
    createClass(KeyedSeq2, Seq2);
    function KeyedSeq2(value) {
      return value === null || value === void 0 ? emptySequence2().toKeyedSeq() : isIterable(value) ? isKeyed2(value) ? value.toSeq() : value.fromEntrySeq() : keyedSeqFromValue2(value);
    }
    KeyedSeq2.prototype.toKeyedSeq = function() {
      return this;
    };
    createClass(IndexedSeq2, Seq2);
    function IndexedSeq2(value) {
      return value === null || value === void 0 ? emptySequence2() : !isIterable(value) ? indexedSeqFromValue2(value) : isKeyed2(value) ? value.entrySeq() : value.toIndexedSeq();
    }
    IndexedSeq2.of = function() {
      return IndexedSeq2(arguments);
    };
    IndexedSeq2.prototype.toIndexedSeq = function() {
      return this;
    };
    IndexedSeq2.prototype.toString = function() {
      return this.__toString("Seq [", "]");
    };
    IndexedSeq2.prototype.__iterate = function(fn, reverse3) {
      return seqIterate(this, fn, reverse3, false);
    };
    IndexedSeq2.prototype.__iterator = function(type, reverse3) {
      return seqIterator(this, type, reverse3, false);
    };
    createClass(SetSeq2, Seq2);
    function SetSeq2(value) {
      return (value === null || value === void 0 ? emptySequence2() : !isIterable(value) ? indexedSeqFromValue2(value) : isKeyed2(value) ? value.entrySeq() : value).toSetSeq();
    }
    SetSeq2.of = function() {
      return SetSeq2(arguments);
    };
    SetSeq2.prototype.toSetSeq = function() {
      return this;
    };
    Seq2.isSeq = isSeq2;
    Seq2.Keyed = KeyedSeq2;
    Seq2.Set = SetSeq2;
    Seq2.Indexed = IndexedSeq2;
    var IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
    Seq2.prototype[IS_SEQ_SENTINEL] = true;
    createClass(ArraySeq2, IndexedSeq2);
    function ArraySeq2(array) {
      this._array = array;
      this.size = array.length;
    }
    ArraySeq2.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._array[wrapIndex2(this, index)] : notSetValue;
    };
    ArraySeq2.prototype.__iterate = function(fn, reverse3) {
      var array = this._array;
      var maxIndex = array.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(array[reverse3 ? maxIndex - ii : ii], ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };
    ArraySeq2.prototype.__iterator = function(type, reverse3) {
      var array = this._array;
      var maxIndex = array.length - 1;
      var ii = 0;
      return new Iterator3(function() {
        return ii > maxIndex ? iteratorDone2() : iteratorValue2(type, ii, array[reverse3 ? maxIndex - ii++ : ii++]);
      });
    };
    createClass(ObjectSeq2, KeyedSeq2);
    function ObjectSeq2(object) {
      var keys3 = Object.keys(object);
      this._object = object;
      this._keys = keys3;
      this.size = keys3.length;
    }
    ObjectSeq2.prototype.get = function(key, notSetValue) {
      if (notSetValue !== void 0 && !this.has(key)) {
        return notSetValue;
      }
      return this._object[key];
    };
    ObjectSeq2.prototype.has = function(key) {
      return this._object.hasOwnProperty(key);
    };
    ObjectSeq2.prototype.__iterate = function(fn, reverse3) {
      var object = this._object;
      var keys3 = this._keys;
      var maxIndex = keys3.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var key = keys3[reverse3 ? maxIndex - ii : ii];
        if (fn(object[key], key, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };
    ObjectSeq2.prototype.__iterator = function(type, reverse3) {
      var object = this._object;
      var keys3 = this._keys;
      var maxIndex = keys3.length - 1;
      var ii = 0;
      return new Iterator3(function() {
        var key = keys3[reverse3 ? maxIndex - ii : ii];
        return ii++ > maxIndex ? iteratorDone2() : iteratorValue2(type, key, object[key]);
      });
    };
    ObjectSeq2.prototype[IS_ORDERED_SENTINEL] = true;
    createClass(IterableSeq, IndexedSeq2);
    function IterableSeq(iterable) {
      this._iterable = iterable;
      this.size = iterable.length || iterable.size;
    }
    IterableSeq.prototype.__iterateUncached = function(fn, reverse3) {
      if (reverse3) {
        return this.cacheResult().__iterate(fn, reverse3);
      }
      var iterable = this._iterable;
      var iterator = getIterator2(iterable);
      var iterations = 0;
      if (isIterator2(iterator)) {
        var step;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
      }
      return iterations;
    };
    IterableSeq.prototype.__iteratorUncached = function(type, reverse3) {
      if (reverse3) {
        return this.cacheResult().__iterator(type, reverse3);
      }
      var iterable = this._iterable;
      var iterator = getIterator2(iterable);
      if (!isIterator2(iterator)) {
        return new Iterator3(iteratorDone2);
      }
      var iterations = 0;
      return new Iterator3(function() {
        var step = iterator.next();
        return step.done ? step : iteratorValue2(type, iterations++, step.value);
      });
    };
    createClass(IteratorSeq, IndexedSeq2);
    function IteratorSeq(iterator) {
      this._iterator = iterator;
      this._iteratorCache = [];
    }
    IteratorSeq.prototype.__iterateUncached = function(fn, reverse3) {
      if (reverse3) {
        return this.cacheResult().__iterate(fn, reverse3);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      while (iterations < cache.length) {
        if (fn(cache[iterations], iterations++, this) === false) {
          return iterations;
        }
      }
      var step;
      while (!(step = iterator.next()).done) {
        var val = step.value;
        cache[iterations] = val;
        if (fn(val, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };
    IteratorSeq.prototype.__iteratorUncached = function(type, reverse3) {
      if (reverse3) {
        return this.cacheResult().__iterator(type, reverse3);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      return new Iterator3(function() {
        if (iterations >= cache.length) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          cache[iterations] = step.value;
        }
        return iteratorValue2(type, iterations, cache[iterations++]);
      });
    };
    function isSeq2(maybeSeq) {
      return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
    }
    var EMPTY_SEQ2;
    function emptySequence2() {
      return EMPTY_SEQ2 || (EMPTY_SEQ2 = new ArraySeq2([]));
    }
    function keyedSeqFromValue2(value) {
      var seq = Array.isArray(value) ? new ArraySeq2(value).fromEntrySeq() : isIterator2(value) ? new IteratorSeq(value).fromEntrySeq() : hasIterator2(value) ? new IterableSeq(value).fromEntrySeq() : typeof value === "object" ? new ObjectSeq2(value) : void 0;
      if (!seq) {
        throw new TypeError("Expected Array or iterable object of [k, v] entries, or keyed object: " + value);
      }
      return seq;
    }
    function indexedSeqFromValue2(value) {
      var seq = maybeIndexedSeqFromValue2(value);
      if (!seq) {
        throw new TypeError("Expected Array or iterable object of values: " + value);
      }
      return seq;
    }
    function seqFromValue2(value) {
      var seq = maybeIndexedSeqFromValue2(value) || typeof value === "object" && new ObjectSeq2(value);
      if (!seq) {
        throw new TypeError("Expected Array or iterable object of values, or keyed object: " + value);
      }
      return seq;
    }
    function maybeIndexedSeqFromValue2(value) {
      return isArrayLike2(value) ? new ArraySeq2(value) : isIterator2(value) ? new IteratorSeq(value) : hasIterator2(value) ? new IterableSeq(value) : void 0;
    }
    function seqIterate(seq, fn, reverse3, useKeys) {
      var cache = seq._cache;
      if (cache) {
        var maxIndex = cache.length - 1;
        for (var ii = 0; ii <= maxIndex; ii++) {
          var entry = cache[reverse3 ? maxIndex - ii : ii];
          if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
            return ii + 1;
          }
        }
        return ii;
      }
      return seq.__iterateUncached(fn, reverse3);
    }
    function seqIterator(seq, type, reverse3, useKeys) {
      var cache = seq._cache;
      if (cache) {
        var maxIndex = cache.length - 1;
        var ii = 0;
        return new Iterator3(function() {
          var entry = cache[reverse3 ? maxIndex - ii : ii];
          return ii++ > maxIndex ? iteratorDone2() : iteratorValue2(type, useKeys ? entry[0] : ii - 1, entry[1]);
        });
      }
      return seq.__iteratorUncached(type, reverse3);
    }
    function fromJS2(json, converter2) {
      return converter2 ? fromJSWith(converter2, json, "", {
        "": json
      }) : fromJSDefault(json);
    }
    function fromJSWith(converter2, json, key, parentJSON) {
      if (Array.isArray(json)) {
        return converter2.call(parentJSON, key, IndexedSeq2(json).map(function(v, k) {
          return fromJSWith(converter2, v, k, json);
        }));
      }
      if (isPlainObj(json)) {
        return converter2.call(parentJSON, key, KeyedSeq2(json).map(function(v, k) {
          return fromJSWith(converter2, v, k, json);
        }));
      }
      return json;
    }
    function fromJSDefault(json) {
      if (Array.isArray(json)) {
        return IndexedSeq2(json).map(fromJSDefault).toList();
      }
      if (isPlainObj(json)) {
        return KeyedSeq2(json).map(fromJSDefault).toMap();
      }
      return json;
    }
    function isPlainObj(value) {
      return value && (value.constructor === Object || value.constructor === void 0);
    }
    function is2(valueA, valueB) {
      if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
        return true;
      }
      if (!valueA || !valueB) {
        return false;
      }
      if (typeof valueA.valueOf === "function" && typeof valueB.valueOf === "function") {
        valueA = valueA.valueOf();
        valueB = valueB.valueOf();
        if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
          return true;
        }
        if (!valueA || !valueB) {
          return false;
        }
      }
      if (typeof valueA.equals === "function" && typeof valueB.equals === "function" && valueA.equals(valueB)) {
        return true;
      }
      return false;
    }
    function deepEqual2(a, b) {
      if (a === b) {
        return true;
      }
      if (!isIterable(b) || a.size !== void 0 && b.size !== void 0 && a.size !== b.size || a.__hash !== void 0 && b.__hash !== void 0 && a.__hash !== b.__hash || isKeyed2(a) !== isKeyed2(b) || isIndexed2(a) !== isIndexed2(b) || isOrdered2(a) !== isOrdered2(b)) {
        return false;
      }
      if (a.size === 0 && b.size === 0) {
        return true;
      }
      var notAssociative = !isAssociative2(a);
      if (isOrdered2(a)) {
        var entries2 = a.entries();
        return b.every(function(v, k) {
          var entry = entries2.next().value;
          return entry && is2(entry[1], v) && (notAssociative || is2(entry[0], k));
        }) && entries2.next().done;
      }
      var flipped = false;
      if (a.size === void 0) {
        if (b.size === void 0) {
          if (typeof a.cacheResult === "function") {
            a.cacheResult();
          }
        } else {
          flipped = true;
          var _ = a;
          a = b;
          b = _;
        }
      }
      var allEqual = true;
      var bSize = b.__iterate(function(v, k) {
        if (notAssociative ? !a.has(v) : flipped ? !is2(v, a.get(k, NOT_SET2)) : !is2(a.get(k, NOT_SET2), v)) {
          allEqual = false;
          return false;
        }
      });
      return allEqual && a.size === bSize;
    }
    createClass(Repeat2, IndexedSeq2);
    function Repeat2(value, times) {
      if (!(this instanceof Repeat2)) {
        return new Repeat2(value, times);
      }
      this._value = value;
      this.size = times === void 0 ? Infinity : Math.max(0, times);
      if (this.size === 0) {
        if (EMPTY_REPEAT) {
          return EMPTY_REPEAT;
        }
        EMPTY_REPEAT = this;
      }
    }
    Repeat2.prototype.toString = function() {
      if (this.size === 0) {
        return "Repeat []";
      }
      return "Repeat [ " + this._value + " " + this.size + " times ]";
    };
    Repeat2.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._value : notSetValue;
    };
    Repeat2.prototype.includes = function(searchValue) {
      return is2(this._value, searchValue);
    };
    Repeat2.prototype.slice = function(begin, end) {
      var size = this.size;
      return wholeSlice2(begin, end, size) ? this : new Repeat2(this._value, resolveEnd2(end, size) - resolveBegin2(begin, size));
    };
    Repeat2.prototype.reverse = function() {
      return this;
    };
    Repeat2.prototype.indexOf = function(searchValue) {
      if (is2(this._value, searchValue)) {
        return 0;
      }
      return -1;
    };
    Repeat2.prototype.lastIndexOf = function(searchValue) {
      if (is2(this._value, searchValue)) {
        return this.size;
      }
      return -1;
    };
    Repeat2.prototype.__iterate = function(fn, reverse3) {
      for (var ii = 0; ii < this.size; ii++) {
        if (fn(this._value, ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };
    Repeat2.prototype.__iterator = function(type, reverse3) {
      var this$0 = this;
      var ii = 0;
      return new Iterator3(function() {
        return ii < this$0.size ? iteratorValue2(type, ii++, this$0._value) : iteratorDone2();
      });
    };
    Repeat2.prototype.equals = function(other) {
      return other instanceof Repeat2 ? is2(this._value, other._value) : deepEqual2(other);
    };
    var EMPTY_REPEAT;
    function invariant2(condition, error) {
      if (!condition)
        throw new Error(error);
    }
    createClass(Range2, IndexedSeq2);
    function Range2(start, end, step) {
      if (!(this instanceof Range2)) {
        return new Range2(start, end, step);
      }
      invariant2(step !== 0, "Cannot step a Range by 0");
      start = start || 0;
      if (end === void 0) {
        end = Infinity;
      }
      step = step === void 0 ? 1 : Math.abs(step);
      if (end < start) {
        step = -step;
      }
      this._start = start;
      this._end = end;
      this._step = step;
      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
      if (this.size === 0) {
        if (EMPTY_RANGE2) {
          return EMPTY_RANGE2;
        }
        EMPTY_RANGE2 = this;
      }
    }
    Range2.prototype.toString = function() {
      if (this.size === 0) {
        return "Range []";
      }
      return "Range [ " + this._start + "..." + this._end + (this._step > 1 ? " by " + this._step : "") + " ]";
    };
    Range2.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._start + wrapIndex2(this, index) * this._step : notSetValue;
    };
    Range2.prototype.includes = function(searchValue) {
      var possibleIndex = (searchValue - this._start) / this._step;
      return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
    };
    Range2.prototype.slice = function(begin, end) {
      if (wholeSlice2(begin, end, this.size)) {
        return this;
      }
      begin = resolveBegin2(begin, this.size);
      end = resolveEnd2(end, this.size);
      if (end <= begin) {
        return new Range2(0, 0);
      }
      return new Range2(this.get(begin, this._end), this.get(end, this._end), this._step);
    };
    Range2.prototype.indexOf = function(searchValue) {
      var offsetValue = searchValue - this._start;
      if (offsetValue % this._step === 0) {
        var index = offsetValue / this._step;
        if (index >= 0 && index < this.size) {
          return index;
        }
      }
      return -1;
    };
    Range2.prototype.lastIndexOf = function(searchValue) {
      return this.indexOf(searchValue);
    };
    Range2.prototype.__iterate = function(fn, reverse3) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse3 ? this._start + maxIndex * step : this._start;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(value, ii, this) === false) {
          return ii + 1;
        }
        value += reverse3 ? -step : step;
      }
      return ii;
    };
    Range2.prototype.__iterator = function(type, reverse3) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse3 ? this._start + maxIndex * step : this._start;
      var ii = 0;
      return new Iterator3(function() {
        var v = value;
        value += reverse3 ? -step : step;
        return ii > maxIndex ? iteratorDone2() : iteratorValue2(type, ii++, v);
      });
    };
    Range2.prototype.equals = function(other) {
      return other instanceof Range2 ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual2(this, other);
    };
    var EMPTY_RANGE2;
    createClass(Collection3, Iterable);
    function Collection3() {
      throw TypeError("Abstract");
    }
    createClass(KeyedCollection2, Collection3);
    function KeyedCollection2() {
    }
    createClass(IndexedCollection2, Collection3);
    function IndexedCollection2() {
    }
    createClass(SetCollection2, Collection3);
    function SetCollection2() {
    }
    Collection3.Keyed = KeyedCollection2;
    Collection3.Indexed = IndexedCollection2;
    Collection3.Set = SetCollection2;
    var imul3 = typeof Math.imul === "function" && Math.imul(4294967295, 2) === -2 ? Math.imul : function imul4(a, b) {
      a = a | 0;
      b = b | 0;
      var c = a & 65535;
      var d = b & 65535;
      return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0;
    };
    function smi2(i32) {
      return i32 >>> 1 & 1073741824 | i32 & 3221225471;
    }
    function hash2(o) {
      if (o === false || o === null || o === void 0) {
        return 0;
      }
      if (typeof o.valueOf === "function") {
        o = o.valueOf();
        if (o === false || o === null || o === void 0) {
          return 0;
        }
      }
      if (o === true) {
        return 1;
      }
      var type = typeof o;
      if (type === "number") {
        var h = o | 0;
        if (h !== o) {
          h ^= o * 4294967295;
        }
        while (o > 4294967295) {
          o /= 4294967295;
          h ^= o;
        }
        return smi2(h);
      }
      if (type === "string") {
        return o.length > STRING_HASH_CACHE_MIN_STRLEN2 ? cachedHashString2(o) : hashString2(o);
      }
      if (typeof o.hashCode === "function") {
        return o.hashCode();
      }
      if (type === "object") {
        return hashJSObj2(o);
      }
      if (typeof o.toString === "function") {
        return hashString2(o.toString());
      }
      throw new Error("Value type " + type + " cannot be hashed.");
    }
    function cachedHashString2(string) {
      var hash3 = stringHashCache2[string];
      if (hash3 === void 0) {
        hash3 = hashString2(string);
        if (STRING_HASH_CACHE_SIZE2 === STRING_HASH_CACHE_MAX_SIZE2) {
          STRING_HASH_CACHE_SIZE2 = 0;
          stringHashCache2 = {};
        }
        STRING_HASH_CACHE_SIZE2++;
        stringHashCache2[string] = hash3;
      }
      return hash3;
    }
    function hashString2(string) {
      var hash3 = 0;
      for (var ii = 0; ii < string.length; ii++) {
        hash3 = 31 * hash3 + string.charCodeAt(ii) | 0;
      }
      return smi2(hash3);
    }
    function hashJSObj2(obj) {
      var hash3;
      if (usingWeakMap2) {
        hash3 = weakMap2.get(obj);
        if (hash3 !== void 0) {
          return hash3;
        }
      }
      hash3 = obj[UID_HASH_KEY2];
      if (hash3 !== void 0) {
        return hash3;
      }
      if (!canDefineProperty2) {
        hash3 = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY2];
        if (hash3 !== void 0) {
          return hash3;
        }
        hash3 = getIENodeHash2(obj);
        if (hash3 !== void 0) {
          return hash3;
        }
      }
      hash3 = ++objHashUID;
      if (objHashUID & 1073741824) {
        objHashUID = 0;
      }
      if (usingWeakMap2) {
        weakMap2.set(obj, hash3);
      } else if (isExtensible2 !== void 0 && isExtensible2(obj) === false) {
        throw new Error("Non-extensible objects are not allowed as keys.");
      } else if (canDefineProperty2) {
        Object.defineProperty(obj, UID_HASH_KEY2, {
          "enumerable": false,
          "configurable": false,
          "writable": false,
          "value": hash3
        });
      } else if (obj.propertyIsEnumerable !== void 0 && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
        obj.propertyIsEnumerable = function() {
          return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
        };
        obj.propertyIsEnumerable[UID_HASH_KEY2] = hash3;
      } else if (obj.nodeType !== void 0) {
        obj[UID_HASH_KEY2] = hash3;
      } else {
        throw new Error("Unable to set a non-enumerable property on object.");
      }
      return hash3;
    }
    var isExtensible2 = Object.isExtensible;
    var canDefineProperty2 = function() {
      try {
        Object.defineProperty({}, "@", {});
        return true;
      } catch (e) {
        return false;
      }
    }();
    function getIENodeHash2(node) {
      if (node && node.nodeType > 0) {
        switch (node.nodeType) {
          case 1:
            return node.uniqueID;
          case 9:
            return node.documentElement && node.documentElement.uniqueID;
        }
      }
    }
    var usingWeakMap2 = typeof WeakMap === "function";
    var weakMap2;
    if (usingWeakMap2) {
      weakMap2 = new WeakMap();
    }
    var objHashUID = 0;
    var UID_HASH_KEY2 = "__immutablehash__";
    if (typeof Symbol === "function") {
      UID_HASH_KEY2 = Symbol(UID_HASH_KEY2);
    }
    var STRING_HASH_CACHE_MIN_STRLEN2 = 16;
    var STRING_HASH_CACHE_MAX_SIZE2 = 255;
    var STRING_HASH_CACHE_SIZE2 = 0;
    var stringHashCache2 = {};
    function assertNotInfinite2(size) {
      invariant2(size !== Infinity, "Cannot perform this action with an infinite size.");
    }
    createClass(Map2, KeyedCollection2);
    function Map2(value) {
      return value === null || value === void 0 ? emptyMap2() : isMap2(value) && !isOrdered2(value) ? value : emptyMap2().withMutations(function(map2) {
        var iter = KeyedIterable(value);
        assertNotInfinite2(iter.size);
        iter.forEach(function(v, k) {
          return map2.set(k, v);
        });
      });
    }
    Map2.prototype.toString = function() {
      return this.__toString("Map {", "}");
    };
    Map2.prototype.get = function(k, notSetValue) {
      return this._root ? this._root.get(0, void 0, k, notSetValue) : notSetValue;
    };
    Map2.prototype.set = function(k, v) {
      return updateMap2(this, k, v);
    };
    Map2.prototype.setIn = function(keyPath, v) {
      return this.updateIn(keyPath, NOT_SET2, function() {
        return v;
      });
    };
    Map2.prototype.remove = function(k) {
      return updateMap2(this, k, NOT_SET2);
    };
    Map2.prototype.deleteIn = function(keyPath) {
      return this.updateIn(keyPath, function() {
        return NOT_SET2;
      });
    };
    Map2.prototype.update = function(k, notSetValue, updater) {
      return arguments.length === 1 ? k(this) : this.updateIn([k], notSetValue, updater);
    };
    Map2.prototype.updateIn = function(keyPath, notSetValue, updater) {
      if (!updater) {
        updater = notSetValue;
        notSetValue = void 0;
      }
      var updatedValue = updateInDeepMap(this, forceIterator(keyPath), notSetValue, updater);
      return updatedValue === NOT_SET2 ? void 0 : updatedValue;
    };
    Map2.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._root = null;
        this.__hash = void 0;
        this.__altered = true;
        return this;
      }
      return emptyMap2();
    };
    Map2.prototype.merge = function() {
      return mergeIntoMapWith(this, void 0, arguments);
    };
    Map2.prototype.mergeWith = function(merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, merger, iters);
    };
    Map2.prototype.mergeIn = function(keyPath) {
      var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(keyPath, emptyMap2(), function(m2) {
        return typeof m2.merge === "function" ? m2.merge.apply(m2, iters) : iters[iters.length - 1];
      });
    };
    Map2.prototype.mergeDeep = function() {
      return mergeIntoMapWith(this, deepMerger, arguments);
    };
    Map2.prototype.mergeDeepWith = function(merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, deepMergerWith2(merger), iters);
    };
    Map2.prototype.mergeDeepIn = function(keyPath) {
      var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(keyPath, emptyMap2(), function(m2) {
        return typeof m2.mergeDeep === "function" ? m2.mergeDeep.apply(m2, iters) : iters[iters.length - 1];
      });
    };
    Map2.prototype.sort = function(comparator) {
      return OrderedMap2(sortFactory2(this, comparator));
    };
    Map2.prototype.sortBy = function(mapper, comparator) {
      return OrderedMap2(sortFactory2(this, comparator, mapper));
    };
    Map2.prototype.withMutations = function(fn) {
      var mutable = this.asMutable();
      fn(mutable);
      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
    };
    Map2.prototype.asMutable = function() {
      return this.__ownerID ? this : this.__ensureOwner(new OwnerID2());
    };
    Map2.prototype.asImmutable = function() {
      return this.__ensureOwner();
    };
    Map2.prototype.wasAltered = function() {
      return this.__altered;
    };
    Map2.prototype.__iterator = function(type, reverse3) {
      return new MapIterator2(this, type, reverse3);
    };
    Map2.prototype.__iterate = function(fn, reverse3) {
      var this$0 = this;
      var iterations = 0;
      this._root && this._root.iterate(function(entry) {
        iterations++;
        return fn(entry[1], entry[0], this$0);
      }, reverse3);
      return iterations;
    };
    Map2.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeMap2(this.size, this._root, ownerID, this.__hash);
    };
    function isMap2(maybeMap3) {
      return !!(maybeMap3 && maybeMap3[IS_MAP_SENTINEL]);
    }
    Map2.isMap = isMap2;
    var IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
    var MapPrototype2 = Map2.prototype;
    MapPrototype2[IS_MAP_SENTINEL] = true;
    MapPrototype2[DELETE2] = MapPrototype2.remove;
    MapPrototype2.removeIn = MapPrototype2.deleteIn;
    function ArrayMapNode3(ownerID, entries2) {
      this.ownerID = ownerID;
      this.entries = entries2;
    }
    ArrayMapNode3.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries2 = this.entries;
      for (var ii = 0, len = entries2.length; ii < len; ii++) {
        if (is2(key, entries2[ii][0])) {
          return entries2[ii][1];
        }
      }
      return notSetValue;
    };
    ArrayMapNode3.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET2;
      var entries2 = this.entries;
      var idx = 0;
      for (var len = entries2.length; idx < len; idx++) {
        if (is2(key, entries2[idx][0])) {
          break;
        }
      }
      var exists = idx < len;
      if (exists ? entries2[idx][1] === value : removed) {
        return this;
      }
      SetRef2(didAlter);
      (removed || !exists) && SetRef2(didChangeSize);
      if (removed && entries2.length === 1) {
        return;
      }
      if (!exists && !removed && entries2.length >= MAX_ARRAY_MAP_SIZE2) {
        return createNodes2(ownerID, entries2, key, value);
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries2 : arrCopy2(entries2);
      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }
      if (isEditable) {
        this.entries = newEntries;
        return this;
      }
      return new ArrayMapNode3(ownerID, newEntries);
    };
    function BitmapIndexedNode3(ownerID, bitmap, nodes) {
      this.ownerID = ownerID;
      this.bitmap = bitmap;
      this.nodes = nodes;
    }
    BitmapIndexedNode3.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === void 0) {
        keyHash = hash2(key);
      }
      var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK2);
      var bitmap = this.bitmap;
      return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount2(bitmap & bit - 1)].get(shift + SHIFT2, keyHash, key, notSetValue);
    };
    BitmapIndexedNode3.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === void 0) {
        keyHash = hash2(key);
      }
      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK2;
      var bit = 1 << keyHashFrag;
      var bitmap = this.bitmap;
      var exists = (bitmap & bit) !== 0;
      if (!exists && value === NOT_SET2) {
        return this;
      }
      var idx = popCount2(bitmap & bit - 1);
      var nodes = this.nodes;
      var node = exists ? nodes[idx] : void 0;
      var newNode = updateNode2(node, ownerID, shift + SHIFT2, keyHash, key, value, didChangeSize, didAlter);
      if (newNode === node) {
        return this;
      }
      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE2) {
        return expandNodes2(ownerID, nodes, bitmap, keyHashFrag, newNode);
      }
      if (exists && !newNode && nodes.length === 2 && isLeafNode2(nodes[idx ^ 1])) {
        return nodes[idx ^ 1];
      }
      if (exists && newNode && nodes.length === 1 && isLeafNode2(newNode)) {
        return newNode;
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
      var newNodes = exists ? newNode ? setIn2(nodes, idx, newNode, isEditable) : spliceOut2(nodes, idx, isEditable) : spliceIn2(nodes, idx, newNode, isEditable);
      if (isEditable) {
        this.bitmap = newBitmap;
        this.nodes = newNodes;
        return this;
      }
      return new BitmapIndexedNode3(ownerID, newBitmap, newNodes);
    };
    function HashArrayMapNode3(ownerID, count2, nodes) {
      this.ownerID = ownerID;
      this.count = count2;
      this.nodes = nodes;
    }
    HashArrayMapNode3.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === void 0) {
        keyHash = hash2(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK2;
      var node = this.nodes[idx];
      return node ? node.get(shift + SHIFT2, keyHash, key, notSetValue) : notSetValue;
    };
    HashArrayMapNode3.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === void 0) {
        keyHash = hash2(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK2;
      var removed = value === NOT_SET2;
      var nodes = this.nodes;
      var node = nodes[idx];
      if (removed && !node) {
        return this;
      }
      var newNode = updateNode2(node, ownerID, shift + SHIFT2, keyHash, key, value, didChangeSize, didAlter);
      if (newNode === node) {
        return this;
      }
      var newCount = this.count;
      if (!node) {
        newCount++;
      } else if (!newNode) {
        newCount--;
        if (newCount < MIN_HASH_ARRAY_MAP_SIZE2) {
          return packNodes2(ownerID, nodes, newCount, idx);
        }
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newNodes = setIn2(nodes, idx, newNode, isEditable);
      if (isEditable) {
        this.count = newCount;
        this.nodes = newNodes;
        return this;
      }
      return new HashArrayMapNode3(ownerID, newCount, newNodes);
    };
    function HashCollisionNode3(ownerID, keyHash, entries2) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entries = entries2;
    }
    HashCollisionNode3.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries2 = this.entries;
      for (var ii = 0, len = entries2.length; ii < len; ii++) {
        if (is2(key, entries2[ii][0])) {
          return entries2[ii][1];
        }
      }
      return notSetValue;
    };
    HashCollisionNode3.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === void 0) {
        keyHash = hash2(key);
      }
      var removed = value === NOT_SET2;
      if (keyHash !== this.keyHash) {
        if (removed) {
          return this;
        }
        SetRef2(didAlter);
        SetRef2(didChangeSize);
        return mergeIntoNode2(this, ownerID, shift, keyHash, [key, value]);
      }
      var entries2 = this.entries;
      var idx = 0;
      for (var len = entries2.length; idx < len; idx++) {
        if (is2(key, entries2[idx][0])) {
          break;
        }
      }
      var exists = idx < len;
      if (exists ? entries2[idx][1] === value : removed) {
        return this;
      }
      SetRef2(didAlter);
      (removed || !exists) && SetRef2(didChangeSize);
      if (removed && len === 2) {
        return new ValueNode3(ownerID, this.keyHash, entries2[idx ^ 1]);
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries2 : arrCopy2(entries2);
      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }
      if (isEditable) {
        this.entries = newEntries;
        return this;
      }
      return new HashCollisionNode3(ownerID, this.keyHash, newEntries);
    };
    function ValueNode3(ownerID, keyHash, entry) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entry = entry;
    }
    ValueNode3.prototype.get = function(shift, keyHash, key, notSetValue) {
      return is2(key, this.entry[0]) ? this.entry[1] : notSetValue;
    };
    ValueNode3.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET2;
      var keyMatch = is2(key, this.entry[0]);
      if (keyMatch ? value === this.entry[1] : removed) {
        return this;
      }
      SetRef2(didAlter);
      if (removed) {
        SetRef2(didChangeSize);
        return;
      }
      if (keyMatch) {
        if (ownerID && ownerID === this.ownerID) {
          this.entry[1] = value;
          return this;
        }
        return new ValueNode3(ownerID, this.keyHash, [key, value]);
      }
      SetRef2(didChangeSize);
      return mergeIntoNode2(this, ownerID, shift, hash2(key), [key, value]);
    };
    ArrayMapNode3.prototype.iterate = HashCollisionNode3.prototype.iterate = function(fn, reverse3) {
      var entries2 = this.entries;
      for (var ii = 0, maxIndex = entries2.length - 1; ii <= maxIndex; ii++) {
        if (fn(entries2[reverse3 ? maxIndex - ii : ii]) === false) {
          return false;
        }
      }
    };
    BitmapIndexedNode3.prototype.iterate = HashArrayMapNode3.prototype.iterate = function(fn, reverse3) {
      var nodes = this.nodes;
      for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
        var node = nodes[reverse3 ? maxIndex - ii : ii];
        if (node && node.iterate(fn, reverse3) === false) {
          return false;
        }
      }
    };
    ValueNode3.prototype.iterate = function(fn, reverse3) {
      return fn(this.entry);
    };
    createClass(MapIterator2, Iterator3);
    function MapIterator2(map2, type, reverse3) {
      this._type = type;
      this._reverse = reverse3;
      this._stack = map2._root && mapIteratorFrame2(map2._root);
    }
    MapIterator2.prototype.next = function() {
      var type = this._type;
      var stack = this._stack;
      while (stack) {
        var node = stack.node;
        var index = stack.index++;
        var maxIndex;
        if (node.entry) {
          if (index === 0) {
            return mapIteratorValue2(type, node.entry);
          }
        } else if (node.entries) {
          maxIndex = node.entries.length - 1;
          if (index <= maxIndex) {
            return mapIteratorValue2(type, node.entries[this._reverse ? maxIndex - index : index]);
          }
        } else {
          maxIndex = node.nodes.length - 1;
          if (index <= maxIndex) {
            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
            if (subNode) {
              if (subNode.entry) {
                return mapIteratorValue2(type, subNode.entry);
              }
              stack = this._stack = mapIteratorFrame2(subNode, stack);
            }
            continue;
          }
        }
        stack = this._stack = this._stack.__prev;
      }
      return iteratorDone2();
    };
    function mapIteratorValue2(type, entry) {
      return iteratorValue2(type, entry[0], entry[1]);
    }
    function mapIteratorFrame2(node, prev) {
      return {
        node,
        index: 0,
        __prev: prev
      };
    }
    function makeMap2(size, root2, ownerID, hash3) {
      var map2 = Object.create(MapPrototype2);
      map2.size = size;
      map2._root = root2;
      map2.__ownerID = ownerID;
      map2.__hash = hash3;
      map2.__altered = false;
      return map2;
    }
    var EMPTY_MAP2;
    function emptyMap2() {
      return EMPTY_MAP2 || (EMPTY_MAP2 = makeMap2(0));
    }
    function updateMap2(map2, k, v) {
      var newRoot;
      var newSize;
      if (!map2._root) {
        if (v === NOT_SET2) {
          return map2;
        }
        newSize = 1;
        newRoot = new ArrayMapNode3(map2.__ownerID, [[k, v]]);
      } else {
        var didChangeSize = MakeRef2(CHANGE_LENGTH);
        var didAlter = MakeRef2(DID_ALTER);
        newRoot = updateNode2(map2._root, map2.__ownerID, 0, void 0, k, v, didChangeSize, didAlter);
        if (!didAlter.value) {
          return map2;
        }
        newSize = map2.size + (didChangeSize.value ? v === NOT_SET2 ? -1 : 1 : 0);
      }
      if (map2.__ownerID) {
        map2.size = newSize;
        map2._root = newRoot;
        map2.__hash = void 0;
        map2.__altered = true;
        return map2;
      }
      return newRoot ? makeMap2(newSize, newRoot) : emptyMap2();
    }
    function updateNode2(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (!node) {
        if (value === NOT_SET2) {
          return node;
        }
        SetRef2(didAlter);
        SetRef2(didChangeSize);
        return new ValueNode3(ownerID, keyHash, [key, value]);
      }
      return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
    }
    function isLeafNode2(node) {
      return node.constructor === ValueNode3 || node.constructor === HashCollisionNode3;
    }
    function mergeIntoNode2(node, ownerID, shift, keyHash, entry) {
      if (node.keyHash === keyHash) {
        return new HashCollisionNode3(ownerID, keyHash, [node.entry, entry]);
      }
      var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK2;
      var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK2;
      var newNode;
      var nodes = idx1 === idx2 ? [mergeIntoNode2(node, ownerID, shift + SHIFT2, keyHash, entry)] : (newNode = new ValueNode3(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
      return new BitmapIndexedNode3(ownerID, 1 << idx1 | 1 << idx2, nodes);
    }
    function createNodes2(ownerID, entries2, key, value) {
      if (!ownerID) {
        ownerID = new OwnerID2();
      }
      var node = new ValueNode3(ownerID, hash2(key), [key, value]);
      for (var ii = 0; ii < entries2.length; ii++) {
        var entry = entries2[ii];
        node = node.update(ownerID, 0, void 0, entry[0], entry[1]);
      }
      return node;
    }
    function packNodes2(ownerID, nodes, count2, excluding) {
      var bitmap = 0;
      var packedII = 0;
      var packedNodes = new Array(count2);
      for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
        var node = nodes[ii];
        if (node !== void 0 && ii !== excluding) {
          bitmap |= bit;
          packedNodes[packedII++] = node;
        }
      }
      return new BitmapIndexedNode3(ownerID, bitmap, packedNodes);
    }
    function expandNodes2(ownerID, nodes, bitmap, including, node) {
      var count2 = 0;
      var expandedNodes = new Array(SIZE2);
      for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
        expandedNodes[ii] = bitmap & 1 ? nodes[count2++] : void 0;
      }
      expandedNodes[including] = node;
      return new HashArrayMapNode3(ownerID, count2 + 1, expandedNodes);
    }
    function mergeIntoMapWith(map2, merger, iterables) {
      var iters = [];
      for (var ii = 0; ii < iterables.length; ii++) {
        var value = iterables[ii];
        var iter = KeyedIterable(value);
        if (!isIterable(value)) {
          iter = iter.map(function(v) {
            return fromJS2(v);
          });
        }
        iters.push(iter);
      }
      return mergeIntoCollectionWith(map2, merger, iters);
    }
    function deepMerger(existing, value, key) {
      return existing && existing.mergeDeep && isIterable(value) ? existing.mergeDeep(value) : is2(existing, value) ? existing : value;
    }
    function deepMergerWith2(merger) {
      return function(existing, value, key) {
        if (existing && existing.mergeDeepWith && isIterable(value)) {
          return existing.mergeDeepWith(merger, value);
        }
        var nextValue = merger(existing, value, key);
        return is2(existing, nextValue) ? existing : nextValue;
      };
    }
    function mergeIntoCollectionWith(collection, merger, iters) {
      iters = iters.filter(function(x) {
        return x.size !== 0;
      });
      if (iters.length === 0) {
        return collection;
      }
      if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
        return collection.constructor(iters[0]);
      }
      return collection.withMutations(function(collection2) {
        var mergeIntoMap = merger ? function(value, key) {
          collection2.update(key, NOT_SET2, function(existing) {
            return existing === NOT_SET2 ? value : merger(existing, value, key);
          });
        } : function(value, key) {
          collection2.set(key, value);
        };
        for (var ii = 0; ii < iters.length; ii++) {
          iters[ii].forEach(mergeIntoMap);
        }
      });
    }
    function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
      var isNotSet = existing === NOT_SET2;
      var step = keyPathIter.next();
      if (step.done) {
        var existingValue = isNotSet ? notSetValue : existing;
        var newValue = updater(existingValue);
        return newValue === existingValue ? existing : newValue;
      }
      invariant2(isNotSet || existing && existing.set, "invalid keyPath");
      var key = step.value;
      var nextExisting = isNotSet ? NOT_SET2 : existing.get(key, NOT_SET2);
      var nextUpdated = updateInDeepMap(nextExisting, keyPathIter, notSetValue, updater);
      return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET2 ? existing.remove(key) : (isNotSet ? emptyMap2() : existing).set(key, nextUpdated);
    }
    function popCount2(x) {
      x = x - (x >> 1 & 1431655765);
      x = (x & 858993459) + (x >> 2 & 858993459);
      x = x + (x >> 4) & 252645135;
      x = x + (x >> 8);
      x = x + (x >> 16);
      return x & 127;
    }
    function setIn2(array, idx, val, canEdit) {
      var newArray = canEdit ? array : arrCopy2(array);
      newArray[idx] = val;
      return newArray;
    }
    function spliceIn2(array, idx, val, canEdit) {
      var newLen = array.length + 1;
      if (canEdit && idx + 1 === newLen) {
        array[idx] = val;
        return array;
      }
      var newArray = new Array(newLen);
      var after = 0;
      for (var ii = 0; ii < newLen; ii++) {
        if (ii === idx) {
          newArray[ii] = val;
          after = -1;
        } else {
          newArray[ii] = array[ii + after];
        }
      }
      return newArray;
    }
    function spliceOut2(array, idx, canEdit) {
      var newLen = array.length - 1;
      if (canEdit && idx === newLen) {
        array.pop();
        return array;
      }
      var newArray = new Array(newLen);
      var after = 0;
      for (var ii = 0; ii < newLen; ii++) {
        if (ii === idx) {
          after = 1;
        }
        newArray[ii] = array[ii + after];
      }
      return newArray;
    }
    var MAX_ARRAY_MAP_SIZE2 = SIZE2 / 4;
    var MAX_BITMAP_INDEXED_SIZE2 = SIZE2 / 2;
    var MIN_HASH_ARRAY_MAP_SIZE2 = SIZE2 / 4;
    createClass(List2, IndexedCollection2);
    function List2(value) {
      var empty = emptyList2();
      if (value === null || value === void 0) {
        return empty;
      }
      if (isList2(value)) {
        return value;
      }
      var iter = IndexedIterable(value);
      var size = iter.size;
      if (size === 0) {
        return empty;
      }
      assertNotInfinite2(size);
      if (size > 0 && size < SIZE2) {
        return makeList2(0, size, SHIFT2, null, new VNode3(iter.toArray()));
      }
      return empty.withMutations(function(list) {
        list.setSize(size);
        iter.forEach(function(v, i) {
          return list.set(i, v);
        });
      });
    }
    List2.of = function() {
      return this(arguments);
    };
    List2.prototype.toString = function() {
      return this.__toString("List [", "]");
    };
    List2.prototype.get = function(index, notSetValue) {
      index = wrapIndex2(this, index);
      if (index >= 0 && index < this.size) {
        index += this._origin;
        var node = listNodeFor2(this, index);
        return node && node.array[index & MASK2];
      }
      return notSetValue;
    };
    List2.prototype.set = function(index, value) {
      return updateList2(this, index, value);
    };
    List2.prototype.remove = function(index) {
      return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
    };
    List2.prototype.insert = function(index, value) {
      return this.splice(index, 0, value);
    };
    List2.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = this._origin = this._capacity = 0;
        this._level = SHIFT2;
        this._root = this._tail = null;
        this.__hash = void 0;
        this.__altered = true;
        return this;
      }
      return emptyList2();
    };
    List2.prototype.push = function() {
      var values2 = arguments;
      var oldSize = this.size;
      return this.withMutations(function(list) {
        setListBounds2(list, 0, oldSize + values2.length);
        for (var ii = 0; ii < values2.length; ii++) {
          list.set(oldSize + ii, values2[ii]);
        }
      });
    };
    List2.prototype.pop = function() {
      return setListBounds2(this, 0, -1);
    };
    List2.prototype.unshift = function() {
      var values2 = arguments;
      return this.withMutations(function(list) {
        setListBounds2(list, -values2.length);
        for (var ii = 0; ii < values2.length; ii++) {
          list.set(ii, values2[ii]);
        }
      });
    };
    List2.prototype.shift = function() {
      return setListBounds2(this, 1);
    };
    List2.prototype.merge = function() {
      return mergeIntoListWith(this, void 0, arguments);
    };
    List2.prototype.mergeWith = function(merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, merger, iters);
    };
    List2.prototype.mergeDeep = function() {
      return mergeIntoListWith(this, deepMerger, arguments);
    };
    List2.prototype.mergeDeepWith = function(merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, deepMergerWith2(merger), iters);
    };
    List2.prototype.setSize = function(size) {
      return setListBounds2(this, 0, size);
    };
    List2.prototype.slice = function(begin, end) {
      var size = this.size;
      if (wholeSlice2(begin, end, size)) {
        return this;
      }
      return setListBounds2(this, resolveBegin2(begin, size), resolveEnd2(end, size));
    };
    List2.prototype.__iterator = function(type, reverse3) {
      var index = 0;
      var values2 = iterateList2(this, reverse3);
      return new Iterator3(function() {
        var value = values2();
        return value === DONE2 ? iteratorDone2() : iteratorValue2(type, index++, value);
      });
    };
    List2.prototype.__iterate = function(fn, reverse3) {
      var index = 0;
      var values2 = iterateList2(this, reverse3);
      var value;
      while ((value = values2()) !== DONE2) {
        if (fn(value, index++, this) === false) {
          break;
        }
      }
      return index;
    };
    List2.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        return this;
      }
      return makeList2(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
    };
    function isList2(maybeList) {
      return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
    }
    List2.isList = isList2;
    var IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
    var ListPrototype2 = List2.prototype;
    ListPrototype2[IS_LIST_SENTINEL] = true;
    ListPrototype2[DELETE2] = ListPrototype2.remove;
    ListPrototype2.setIn = MapPrototype2.setIn;
    ListPrototype2.deleteIn = ListPrototype2.removeIn = MapPrototype2.removeIn;
    ListPrototype2.update = MapPrototype2.update;
    ListPrototype2.updateIn = MapPrototype2.updateIn;
    ListPrototype2.mergeIn = MapPrototype2.mergeIn;
    ListPrototype2.mergeDeepIn = MapPrototype2.mergeDeepIn;
    ListPrototype2.withMutations = MapPrototype2.withMutations;
    ListPrototype2.asMutable = MapPrototype2.asMutable;
    ListPrototype2.asImmutable = MapPrototype2.asImmutable;
    ListPrototype2.wasAltered = MapPrototype2.wasAltered;
    function VNode3(array, ownerID) {
      this.array = array;
      this.ownerID = ownerID;
    }
    VNode3.prototype.removeBefore = function(ownerID, level, index) {
      if (index === level ? 1 << level : this.array.length === 0) {
        return this;
      }
      var originIndex = index >>> level & MASK2;
      if (originIndex >= this.array.length) {
        return new VNode3([], ownerID);
      }
      var removingFirst = originIndex === 0;
      var newChild;
      if (level > 0) {
        var oldChild = this.array[originIndex];
        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT2, index);
        if (newChild === oldChild && removingFirst) {
          return this;
        }
      }
      if (removingFirst && !newChild) {
        return this;
      }
      var editable = editableVNode2(this, ownerID);
      if (!removingFirst) {
        for (var ii = 0; ii < originIndex; ii++) {
          editable.array[ii] = void 0;
        }
      }
      if (newChild) {
        editable.array[originIndex] = newChild;
      }
      return editable;
    };
    VNode3.prototype.removeAfter = function(ownerID, level, index) {
      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
        return this;
      }
      var sizeIndex = index - 1 >>> level & MASK2;
      if (sizeIndex >= this.array.length) {
        return this;
      }
      var newChild;
      if (level > 0) {
        var oldChild = this.array[sizeIndex];
        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT2, index);
        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
          return this;
        }
      }
      var editable = editableVNode2(this, ownerID);
      editable.array.splice(sizeIndex + 1);
      if (newChild) {
        editable.array[sizeIndex] = newChild;
      }
      return editable;
    };
    var DONE2 = {};
    function iterateList2(list, reverse3) {
      var left = list._origin;
      var right = list._capacity;
      var tailPos = getTailOffset2(right);
      var tail = list._tail;
      return iterateNodeOrLeaf(list._root, list._level, 0);
      function iterateNodeOrLeaf(node, level, offset) {
        return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
      }
      function iterateLeaf(node, offset) {
        var array = offset === tailPos ? tail && tail.array : node && node.array;
        var from = offset > left ? 0 : left - offset;
        var to = right - offset;
        if (to > SIZE2) {
          to = SIZE2;
        }
        return function() {
          if (from === to) {
            return DONE2;
          }
          var idx = reverse3 ? --to : from++;
          return array && array[idx];
        };
      }
      function iterateNode(node, level, offset) {
        var values2;
        var array = node && node.array;
        var from = offset > left ? 0 : left - offset >> level;
        var to = (right - offset >> level) + 1;
        if (to > SIZE2) {
          to = SIZE2;
        }
        return function() {
          do {
            if (values2) {
              var value = values2();
              if (value !== DONE2) {
                return value;
              }
              values2 = null;
            }
            if (from === to) {
              return DONE2;
            }
            var idx = reverse3 ? --to : from++;
            values2 = iterateNodeOrLeaf(array && array[idx], level - SHIFT2, offset + (idx << level));
          } while (true);
        };
      }
    }
    function makeList2(origin, capacity, level, root2, tail, ownerID, hash3) {
      var list = Object.create(ListPrototype2);
      list.size = capacity - origin;
      list._origin = origin;
      list._capacity = capacity;
      list._level = level;
      list._root = root2;
      list._tail = tail;
      list.__ownerID = ownerID;
      list.__hash = hash3;
      list.__altered = false;
      return list;
    }
    var EMPTY_LIST2;
    function emptyList2() {
      return EMPTY_LIST2 || (EMPTY_LIST2 = makeList2(0, 0, SHIFT2));
    }
    function updateList2(list, index, value) {
      index = wrapIndex2(list, index);
      if (index !== index) {
        return list;
      }
      if (index >= list.size || index < 0) {
        return list.withMutations(function(list2) {
          index < 0 ? setListBounds2(list2, index).set(0, value) : setListBounds2(list2, 0, index + 1).set(index, value);
        });
      }
      index += list._origin;
      var newTail = list._tail;
      var newRoot = list._root;
      var didAlter = MakeRef2(DID_ALTER);
      if (index >= getTailOffset2(list._capacity)) {
        newTail = updateVNode2(newTail, list.__ownerID, 0, index, value, didAlter);
      } else {
        newRoot = updateVNode2(newRoot, list.__ownerID, list._level, index, value, didAlter);
      }
      if (!didAlter.value) {
        return list;
      }
      if (list.__ownerID) {
        list._root = newRoot;
        list._tail = newTail;
        list.__hash = void 0;
        list.__altered = true;
        return list;
      }
      return makeList2(list._origin, list._capacity, list._level, newRoot, newTail);
    }
    function updateVNode2(node, ownerID, level, index, value, didAlter) {
      var idx = index >>> level & MASK2;
      var nodeHas = node && idx < node.array.length;
      if (!nodeHas && value === void 0) {
        return node;
      }
      var newNode;
      if (level > 0) {
        var lowerNode = node && node.array[idx];
        var newLowerNode = updateVNode2(lowerNode, ownerID, level - SHIFT2, index, value, didAlter);
        if (newLowerNode === lowerNode) {
          return node;
        }
        newNode = editableVNode2(node, ownerID);
        newNode.array[idx] = newLowerNode;
        return newNode;
      }
      if (nodeHas && node.array[idx] === value) {
        return node;
      }
      SetRef2(didAlter);
      newNode = editableVNode2(node, ownerID);
      if (value === void 0 && idx === newNode.array.length - 1) {
        newNode.array.pop();
      } else {
        newNode.array[idx] = value;
      }
      return newNode;
    }
    function editableVNode2(node, ownerID) {
      if (ownerID && node && ownerID === node.ownerID) {
        return node;
      }
      return new VNode3(node ? node.array.slice() : [], ownerID);
    }
    function listNodeFor2(list, rawIndex) {
      if (rawIndex >= getTailOffset2(list._capacity)) {
        return list._tail;
      }
      if (rawIndex < 1 << list._level + SHIFT2) {
        var node = list._root;
        var level = list._level;
        while (node && level > 0) {
          node = node.array[rawIndex >>> level & MASK2];
          level -= SHIFT2;
        }
        return node;
      }
    }
    function setListBounds2(list, begin, end) {
      if (begin !== void 0) {
        begin = begin | 0;
      }
      if (end !== void 0) {
        end = end | 0;
      }
      var owner = list.__ownerID || new OwnerID2();
      var oldOrigin = list._origin;
      var oldCapacity = list._capacity;
      var newOrigin = oldOrigin + begin;
      var newCapacity = end === void 0 ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
      if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
        return list;
      }
      if (newOrigin >= newCapacity) {
        return list.clear();
      }
      var newLevel = list._level;
      var newRoot = list._root;
      var offsetShift = 0;
      while (newOrigin + offsetShift < 0) {
        newRoot = new VNode3(newRoot && newRoot.array.length ? [void 0, newRoot] : [], owner);
        newLevel += SHIFT2;
        offsetShift += 1 << newLevel;
      }
      if (offsetShift) {
        newOrigin += offsetShift;
        oldOrigin += offsetShift;
        newCapacity += offsetShift;
        oldCapacity += offsetShift;
      }
      var oldTailOffset = getTailOffset2(oldCapacity);
      var newTailOffset = getTailOffset2(newCapacity);
      while (newTailOffset >= 1 << newLevel + SHIFT2) {
        newRoot = new VNode3(newRoot && newRoot.array.length ? [newRoot] : [], owner);
        newLevel += SHIFT2;
      }
      var oldTail = list._tail;
      var newTail = newTailOffset < oldTailOffset ? listNodeFor2(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode3([], owner) : oldTail;
      if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
        newRoot = editableVNode2(newRoot, owner);
        var node = newRoot;
        for (var level = newLevel; level > SHIFT2; level -= SHIFT2) {
          var idx = oldTailOffset >>> level & MASK2;
          node = node.array[idx] = editableVNode2(node.array[idx], owner);
        }
        node.array[oldTailOffset >>> SHIFT2 & MASK2] = oldTail;
      }
      if (newCapacity < oldCapacity) {
        newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
      }
      if (newOrigin >= newTailOffset) {
        newOrigin -= newTailOffset;
        newCapacity -= newTailOffset;
        newLevel = SHIFT2;
        newRoot = null;
        newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
      } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
        offsetShift = 0;
        while (newRoot) {
          var beginIndex = newOrigin >>> newLevel & MASK2;
          if (beginIndex !== newTailOffset >>> newLevel & MASK2) {
            break;
          }
          if (beginIndex) {
            offsetShift += (1 << newLevel) * beginIndex;
          }
          newLevel -= SHIFT2;
          newRoot = newRoot.array[beginIndex];
        }
        if (newRoot && newOrigin > oldOrigin) {
          newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
        }
        if (newRoot && newTailOffset < oldTailOffset) {
          newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
        }
        if (offsetShift) {
          newOrigin -= offsetShift;
          newCapacity -= offsetShift;
        }
      }
      if (list.__ownerID) {
        list.size = newCapacity - newOrigin;
        list._origin = newOrigin;
        list._capacity = newCapacity;
        list._level = newLevel;
        list._root = newRoot;
        list._tail = newTail;
        list.__hash = void 0;
        list.__altered = true;
        return list;
      }
      return makeList2(newOrigin, newCapacity, newLevel, newRoot, newTail);
    }
    function mergeIntoListWith(list, merger, iterables) {
      var iters = [];
      var maxSize = 0;
      for (var ii = 0; ii < iterables.length; ii++) {
        var value = iterables[ii];
        var iter = IndexedIterable(value);
        if (iter.size > maxSize) {
          maxSize = iter.size;
        }
        if (!isIterable(value)) {
          iter = iter.map(function(v) {
            return fromJS2(v);
          });
        }
        iters.push(iter);
      }
      if (maxSize > list.size) {
        list = list.setSize(maxSize);
      }
      return mergeIntoCollectionWith(list, merger, iters);
    }
    function getTailOffset2(size) {
      return size < SIZE2 ? 0 : size - 1 >>> SHIFT2 << SHIFT2;
    }
    createClass(OrderedMap2, Map2);
    function OrderedMap2(value) {
      return value === null || value === void 0 ? emptyOrderedMap2() : isOrderedMap2(value) ? value : emptyOrderedMap2().withMutations(function(map2) {
        var iter = KeyedIterable(value);
        assertNotInfinite2(iter.size);
        iter.forEach(function(v, k) {
          return map2.set(k, v);
        });
      });
    }
    OrderedMap2.of = function() {
      return this(arguments);
    };
    OrderedMap2.prototype.toString = function() {
      return this.__toString("OrderedMap {", "}");
    };
    OrderedMap2.prototype.get = function(k, notSetValue) {
      var index = this._map.get(k);
      return index !== void 0 ? this._list.get(index)[1] : notSetValue;
    };
    OrderedMap2.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._map.clear();
        this._list.clear();
        return this;
      }
      return emptyOrderedMap2();
    };
    OrderedMap2.prototype.set = function(k, v) {
      return updateOrderedMap2(this, k, v);
    };
    OrderedMap2.prototype.remove = function(k) {
      return updateOrderedMap2(this, k, NOT_SET2);
    };
    OrderedMap2.prototype.wasAltered = function() {
      return this._map.wasAltered() || this._list.wasAltered();
    };
    OrderedMap2.prototype.__iterate = function(fn, reverse3) {
      var this$0 = this;
      return this._list.__iterate(function(entry) {
        return entry && fn(entry[1], entry[0], this$0);
      }, reverse3);
    };
    OrderedMap2.prototype.__iterator = function(type, reverse3) {
      return this._list.fromEntrySeq().__iterator(type, reverse3);
    };
    OrderedMap2.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      var newList = this._list.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        this._list = newList;
        return this;
      }
      return makeOrderedMap2(newMap, newList, ownerID, this.__hash);
    };
    function isOrderedMap2(maybeOrderedMap) {
      return isMap2(maybeOrderedMap) && isOrdered2(maybeOrderedMap);
    }
    OrderedMap2.isOrderedMap = isOrderedMap2;
    OrderedMap2.prototype[IS_ORDERED_SENTINEL] = true;
    OrderedMap2.prototype[DELETE2] = OrderedMap2.prototype.remove;
    function makeOrderedMap2(map2, list, ownerID, hash3) {
      var omap = Object.create(OrderedMap2.prototype);
      omap.size = map2 ? map2.size : 0;
      omap._map = map2;
      omap._list = list;
      omap.__ownerID = ownerID;
      omap.__hash = hash3;
      return omap;
    }
    var EMPTY_ORDERED_MAP2;
    function emptyOrderedMap2() {
      return EMPTY_ORDERED_MAP2 || (EMPTY_ORDERED_MAP2 = makeOrderedMap2(emptyMap2(), emptyList2()));
    }
    function updateOrderedMap2(omap, k, v) {
      var map2 = omap._map;
      var list = omap._list;
      var i = map2.get(k);
      var has4 = i !== void 0;
      var newMap;
      var newList;
      if (v === NOT_SET2) {
        if (!has4) {
          return omap;
        }
        if (list.size >= SIZE2 && list.size >= map2.size * 2) {
          newList = list.filter(function(entry, idx) {
            return entry !== void 0 && i !== idx;
          });
          newMap = newList.toKeyedSeq().map(function(entry) {
            return entry[0];
          }).flip().toMap();
          if (omap.__ownerID) {
            newMap.__ownerID = newList.__ownerID = omap.__ownerID;
          }
        } else {
          newMap = map2.remove(k);
          newList = i === list.size - 1 ? list.pop() : list.set(i, void 0);
        }
      } else {
        if (has4) {
          if (v === list.get(i)[1]) {
            return omap;
          }
          newMap = map2;
          newList = list.set(i, [k, v]);
        } else {
          newMap = map2.set(k, list.size);
          newList = list.set(list.size, [k, v]);
        }
      }
      if (omap.__ownerID) {
        omap.size = newMap.size;
        omap._map = newMap;
        omap._list = newList;
        omap.__hash = void 0;
        return omap;
      }
      return makeOrderedMap2(newMap, newList);
    }
    createClass(ToKeyedSequence2, KeyedSeq2);
    function ToKeyedSequence2(indexed, useKeys) {
      this._iter = indexed;
      this._useKeys = useKeys;
      this.size = indexed.size;
    }
    ToKeyedSequence2.prototype.get = function(key, notSetValue) {
      return this._iter.get(key, notSetValue);
    };
    ToKeyedSequence2.prototype.has = function(key) {
      return this._iter.has(key);
    };
    ToKeyedSequence2.prototype.valueSeq = function() {
      return this._iter.valueSeq();
    };
    ToKeyedSequence2.prototype.reverse = function() {
      var this$0 = this;
      var reversedSequence = reverseFactory2(this, true);
      if (!this._useKeys) {
        reversedSequence.valueSeq = function() {
          return this$0._iter.toSeq().reverse();
        };
      }
      return reversedSequence;
    };
    ToKeyedSequence2.prototype.map = function(mapper, context) {
      var this$0 = this;
      var mappedSequence = mapFactory2(this, mapper, context);
      if (!this._useKeys) {
        mappedSequence.valueSeq = function() {
          return this$0._iter.toSeq().map(mapper, context);
        };
      }
      return mappedSequence;
    };
    ToKeyedSequence2.prototype.__iterate = function(fn, reverse3) {
      var this$0 = this;
      var ii;
      return this._iter.__iterate(this._useKeys ? function(v, k) {
        return fn(v, k, this$0);
      } : (ii = reverse3 ? resolveSize(this) : 0, function(v) {
        return fn(v, reverse3 ? --ii : ii++, this$0);
      }), reverse3);
    };
    ToKeyedSequence2.prototype.__iterator = function(type, reverse3) {
      if (this._useKeys) {
        return this._iter.__iterator(type, reverse3);
      }
      var iterator = this._iter.__iterator(ITERATE_VALUES2, reverse3);
      var ii = reverse3 ? resolveSize(this) : 0;
      return new Iterator3(function() {
        var step = iterator.next();
        return step.done ? step : iteratorValue2(type, reverse3 ? --ii : ii++, step.value, step);
      });
    };
    ToKeyedSequence2.prototype[IS_ORDERED_SENTINEL] = true;
    createClass(ToIndexedSequence2, IndexedSeq2);
    function ToIndexedSequence2(iter) {
      this._iter = iter;
      this.size = iter.size;
    }
    ToIndexedSequence2.prototype.includes = function(value) {
      return this._iter.includes(value);
    };
    ToIndexedSequence2.prototype.__iterate = function(fn, reverse3) {
      var this$0 = this;
      var iterations = 0;
      return this._iter.__iterate(function(v) {
        return fn(v, iterations++, this$0);
      }, reverse3);
    };
    ToIndexedSequence2.prototype.__iterator = function(type, reverse3) {
      var iterator = this._iter.__iterator(ITERATE_VALUES2, reverse3);
      var iterations = 0;
      return new Iterator3(function() {
        var step = iterator.next();
        return step.done ? step : iteratorValue2(type, iterations++, step.value, step);
      });
    };
    createClass(ToSetSequence2, SetSeq2);
    function ToSetSequence2(iter) {
      this._iter = iter;
      this.size = iter.size;
    }
    ToSetSequence2.prototype.has = function(key) {
      return this._iter.includes(key);
    };
    ToSetSequence2.prototype.__iterate = function(fn, reverse3) {
      var this$0 = this;
      return this._iter.__iterate(function(v) {
        return fn(v, v, this$0);
      }, reverse3);
    };
    ToSetSequence2.prototype.__iterator = function(type, reverse3) {
      var iterator = this._iter.__iterator(ITERATE_VALUES2, reverse3);
      return new Iterator3(function() {
        var step = iterator.next();
        return step.done ? step : iteratorValue2(type, step.value, step.value, step);
      });
    };
    createClass(FromEntriesSequence2, KeyedSeq2);
    function FromEntriesSequence2(entries2) {
      this._iter = entries2;
      this.size = entries2.size;
    }
    FromEntriesSequence2.prototype.entrySeq = function() {
      return this._iter.toSeq();
    };
    FromEntriesSequence2.prototype.__iterate = function(fn, reverse3) {
      var this$0 = this;
      return this._iter.__iterate(function(entry) {
        if (entry) {
          validateEntry2(entry);
          var indexedIterable = isIterable(entry);
          return fn(indexedIterable ? entry.get(1) : entry[1], indexedIterable ? entry.get(0) : entry[0], this$0);
        }
      }, reverse3);
    };
    FromEntriesSequence2.prototype.__iterator = function(type, reverse3) {
      var iterator = this._iter.__iterator(ITERATE_VALUES2, reverse3);
      return new Iterator3(function() {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          if (entry) {
            validateEntry2(entry);
            var indexedIterable = isIterable(entry);
            return iteratorValue2(type, indexedIterable ? entry.get(0) : entry[0], indexedIterable ? entry.get(1) : entry[1], step);
          }
        }
      });
    };
    ToIndexedSequence2.prototype.cacheResult = ToKeyedSequence2.prototype.cacheResult = ToSetSequence2.prototype.cacheResult = FromEntriesSequence2.prototype.cacheResult = cacheResultThrough2;
    function flipFactory2(iterable) {
      var flipSequence = makeSequence2(iterable);
      flipSequence._iter = iterable;
      flipSequence.size = iterable.size;
      flipSequence.flip = function() {
        return iterable;
      };
      flipSequence.reverse = function() {
        var reversedSequence = iterable.reverse.apply(this);
        reversedSequence.flip = function() {
          return iterable.reverse();
        };
        return reversedSequence;
      };
      flipSequence.has = function(key) {
        return iterable.includes(key);
      };
      flipSequence.includes = function(key) {
        return iterable.has(key);
      };
      flipSequence.cacheResult = cacheResultThrough2;
      flipSequence.__iterateUncached = function(fn, reverse3) {
        var this$0 = this;
        return iterable.__iterate(function(v, k) {
          return fn(k, v, this$0) !== false;
        }, reverse3);
      };
      flipSequence.__iteratorUncached = function(type, reverse3) {
        if (type === ITERATE_ENTRIES2) {
          var iterator = iterable.__iterator(type, reverse3);
          return new Iterator3(function() {
            var step = iterator.next();
            if (!step.done) {
              var k = step.value[0];
              step.value[0] = step.value[1];
              step.value[1] = k;
            }
            return step;
          });
        }
        return iterable.__iterator(type === ITERATE_VALUES2 ? ITERATE_KEYS2 : ITERATE_VALUES2, reverse3);
      };
      return flipSequence;
    }
    function mapFactory2(iterable, mapper, context) {
      var mappedSequence = makeSequence2(iterable);
      mappedSequence.size = iterable.size;
      mappedSequence.has = function(key) {
        return iterable.has(key);
      };
      mappedSequence.get = function(key, notSetValue) {
        var v = iterable.get(key, NOT_SET2);
        return v === NOT_SET2 ? notSetValue : mapper.call(context, v, key, iterable);
      };
      mappedSequence.__iterateUncached = function(fn, reverse3) {
        var this$0 = this;
        return iterable.__iterate(function(v, k, c) {
          return fn(mapper.call(context, v, k, c), k, this$0) !== false;
        }, reverse3);
      };
      mappedSequence.__iteratorUncached = function(type, reverse3) {
        var iterator = iterable.__iterator(ITERATE_ENTRIES2, reverse3);
        return new Iterator3(function() {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var key = entry[0];
          return iteratorValue2(type, key, mapper.call(context, entry[1], key, iterable), step);
        });
      };
      return mappedSequence;
    }
    function reverseFactory2(iterable, useKeys) {
      var reversedSequence = makeSequence2(iterable);
      reversedSequence._iter = iterable;
      reversedSequence.size = iterable.size;
      reversedSequence.reverse = function() {
        return iterable;
      };
      if (iterable.flip) {
        reversedSequence.flip = function() {
          var flipSequence = flipFactory2(iterable);
          flipSequence.reverse = function() {
            return iterable.flip();
          };
          return flipSequence;
        };
      }
      reversedSequence.get = function(key, notSetValue) {
        return iterable.get(useKeys ? key : -1 - key, notSetValue);
      };
      reversedSequence.has = function(key) {
        return iterable.has(useKeys ? key : -1 - key);
      };
      reversedSequence.includes = function(value) {
        return iterable.includes(value);
      };
      reversedSequence.cacheResult = cacheResultThrough2;
      reversedSequence.__iterate = function(fn, reverse3) {
        var this$0 = this;
        return iterable.__iterate(function(v, k) {
          return fn(v, k, this$0);
        }, !reverse3);
      };
      reversedSequence.__iterator = function(type, reverse3) {
        return iterable.__iterator(type, !reverse3);
      };
      return reversedSequence;
    }
    function filterFactory2(iterable, predicate, context, useKeys) {
      var filterSequence = makeSequence2(iterable);
      if (useKeys) {
        filterSequence.has = function(key) {
          var v = iterable.get(key, NOT_SET2);
          return v !== NOT_SET2 && !!predicate.call(context, v, key, iterable);
        };
        filterSequence.get = function(key, notSetValue) {
          var v = iterable.get(key, NOT_SET2);
          return v !== NOT_SET2 && predicate.call(context, v, key, iterable) ? v : notSetValue;
        };
      }
      filterSequence.__iterateUncached = function(fn, reverse3) {
        var this$0 = this;
        var iterations = 0;
        iterable.__iterate(function(v, k, c) {
          if (predicate.call(context, v, k, c)) {
            iterations++;
            return fn(v, useKeys ? k : iterations - 1, this$0);
          }
        }, reverse3);
        return iterations;
      };
      filterSequence.__iteratorUncached = function(type, reverse3) {
        var iterator = iterable.__iterator(ITERATE_ENTRIES2, reverse3);
        var iterations = 0;
        return new Iterator3(function() {
          while (true) {
            var step = iterator.next();
            if (step.done) {
              return step;
            }
            var entry = step.value;
            var key = entry[0];
            var value = entry[1];
            if (predicate.call(context, value, key, iterable)) {
              return iteratorValue2(type, useKeys ? key : iterations++, value, step);
            }
          }
        });
      };
      return filterSequence;
    }
    function countByFactory2(iterable, grouper, context) {
      var groups = Map2().asMutable();
      iterable.__iterate(function(v, k) {
        groups.update(grouper.call(context, v, k, iterable), 0, function(a) {
          return a + 1;
        });
      });
      return groups.asImmutable();
    }
    function groupByFactory2(iterable, grouper, context) {
      var isKeyedIter = isKeyed2(iterable);
      var groups = (isOrdered2(iterable) ? OrderedMap2() : Map2()).asMutable();
      iterable.__iterate(function(v, k) {
        groups.update(grouper.call(context, v, k, iterable), function(a) {
          return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;
        });
      });
      var coerce = iterableClass(iterable);
      return groups.map(function(arr) {
        return reify2(iterable, coerce(arr));
      });
    }
    function sliceFactory2(iterable, begin, end, useKeys) {
      var originalSize = iterable.size;
      if (begin !== void 0) {
        begin = begin | 0;
      }
      if (end !== void 0) {
        end = end | 0;
      }
      if (wholeSlice2(begin, end, originalSize)) {
        return iterable;
      }
      var resolvedBegin = resolveBegin2(begin, originalSize);
      var resolvedEnd = resolveEnd2(end, originalSize);
      if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
        return sliceFactory2(iterable.toSeq().cacheResult(), begin, end, useKeys);
      }
      var resolvedSize = resolvedEnd - resolvedBegin;
      var sliceSize;
      if (resolvedSize === resolvedSize) {
        sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
      }
      var sliceSeq = makeSequence2(iterable);
      sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || void 0;
      if (!useKeys && isSeq2(iterable) && sliceSize >= 0) {
        sliceSeq.get = function(index, notSetValue) {
          index = wrapIndex2(this, index);
          return index >= 0 && index < sliceSize ? iterable.get(index + resolvedBegin, notSetValue) : notSetValue;
        };
      }
      sliceSeq.__iterateUncached = function(fn, reverse3) {
        var this$0 = this;
        if (sliceSize === 0) {
          return 0;
        }
        if (reverse3) {
          return this.cacheResult().__iterate(fn, reverse3);
        }
        var skipped = 0;
        var isSkipping = true;
        var iterations = 0;
        iterable.__iterate(function(v, k) {
          if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
            iterations++;
            return fn(v, useKeys ? k : iterations - 1, this$0) !== false && iterations !== sliceSize;
          }
        });
        return iterations;
      };
      sliceSeq.__iteratorUncached = function(type, reverse3) {
        if (sliceSize !== 0 && reverse3) {
          return this.cacheResult().__iterator(type, reverse3);
        }
        var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse3);
        var skipped = 0;
        var iterations = 0;
        return new Iterator3(function() {
          while (skipped++ < resolvedBegin) {
            iterator.next();
          }
          if (++iterations > sliceSize) {
            return iteratorDone2();
          }
          var step = iterator.next();
          if (useKeys || type === ITERATE_VALUES2) {
            return step;
          } else if (type === ITERATE_KEYS2) {
            return iteratorValue2(type, iterations - 1, void 0, step);
          } else {
            return iteratorValue2(type, iterations - 1, step.value[1], step);
          }
        });
      };
      return sliceSeq;
    }
    function takeWhileFactory2(iterable, predicate, context) {
      var takeSequence = makeSequence2(iterable);
      takeSequence.__iterateUncached = function(fn, reverse3) {
        var this$0 = this;
        if (reverse3) {
          return this.cacheResult().__iterate(fn, reverse3);
        }
        var iterations = 0;
        iterable.__iterate(function(v, k, c) {
          return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0);
        });
        return iterations;
      };
      takeSequence.__iteratorUncached = function(type, reverse3) {
        var this$0 = this;
        if (reverse3) {
          return this.cacheResult().__iterator(type, reverse3);
        }
        var iterator = iterable.__iterator(ITERATE_ENTRIES2, reverse3);
        var iterating = true;
        return new Iterator3(function() {
          if (!iterating) {
            return iteratorDone2();
          }
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var k = entry[0];
          var v = entry[1];
          if (!predicate.call(context, v, k, this$0)) {
            iterating = false;
            return iteratorDone2();
          }
          return type === ITERATE_ENTRIES2 ? step : iteratorValue2(type, k, v, step);
        });
      };
      return takeSequence;
    }
    function skipWhileFactory2(iterable, predicate, context, useKeys) {
      var skipSequence = makeSequence2(iterable);
      skipSequence.__iterateUncached = function(fn, reverse3) {
        var this$0 = this;
        if (reverse3) {
          return this.cacheResult().__iterate(fn, reverse3);
        }
        var isSkipping = true;
        var iterations = 0;
        iterable.__iterate(function(v, k, c) {
          if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
            iterations++;
            return fn(v, useKeys ? k : iterations - 1, this$0);
          }
        });
        return iterations;
      };
      skipSequence.__iteratorUncached = function(type, reverse3) {
        var this$0 = this;
        if (reverse3) {
          return this.cacheResult().__iterator(type, reverse3);
        }
        var iterator = iterable.__iterator(ITERATE_ENTRIES2, reverse3);
        var skipping = true;
        var iterations = 0;
        return new Iterator3(function() {
          var step, k, v;
          do {
            step = iterator.next();
            if (step.done) {
              if (useKeys || type === ITERATE_VALUES2) {
                return step;
              } else if (type === ITERATE_KEYS2) {
                return iteratorValue2(type, iterations++, void 0, step);
              } else {
                return iteratorValue2(type, iterations++, step.value[1], step);
              }
            }
            var entry = step.value;
            k = entry[0];
            v = entry[1];
            skipping && (skipping = predicate.call(context, v, k, this$0));
          } while (skipping);
          return type === ITERATE_ENTRIES2 ? step : iteratorValue2(type, k, v, step);
        });
      };
      return skipSequence;
    }
    function concatFactory2(iterable, values2) {
      var isKeyedIterable = isKeyed2(iterable);
      var iters = [iterable].concat(values2).map(function(v) {
        if (!isIterable(v)) {
          v = isKeyedIterable ? keyedSeqFromValue2(v) : indexedSeqFromValue2(Array.isArray(v) ? v : [v]);
        } else if (isKeyedIterable) {
          v = KeyedIterable(v);
        }
        return v;
      }).filter(function(v) {
        return v.size !== 0;
      });
      if (iters.length === 0) {
        return iterable;
      }
      if (iters.length === 1) {
        var singleton = iters[0];
        if (singleton === iterable || isKeyedIterable && isKeyed2(singleton) || isIndexed2(iterable) && isIndexed2(singleton)) {
          return singleton;
        }
      }
      var concatSeq = new ArraySeq2(iters);
      if (isKeyedIterable) {
        concatSeq = concatSeq.toKeyedSeq();
      } else if (!isIndexed2(iterable)) {
        concatSeq = concatSeq.toSetSeq();
      }
      concatSeq = concatSeq.flatten(true);
      concatSeq.size = iters.reduce(function(sum, seq) {
        if (sum !== void 0) {
          var size = seq.size;
          if (size !== void 0) {
            return sum + size;
          }
        }
      }, 0);
      return concatSeq;
    }
    function flattenFactory2(iterable, depth, useKeys) {
      var flatSequence = makeSequence2(iterable);
      flatSequence.__iterateUncached = function(fn, reverse3) {
        var iterations = 0;
        var stopped = false;
        function flatDeep(iter, currentDepth) {
          var this$0 = this;
          iter.__iterate(function(v, k) {
            if ((!depth || currentDepth < depth) && isIterable(v)) {
              flatDeep(v, currentDepth + 1);
            } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
              stopped = true;
            }
            return !stopped;
          }, reverse3);
        }
        flatDeep(iterable, 0);
        return iterations;
      };
      flatSequence.__iteratorUncached = function(type, reverse3) {
        var iterator = iterable.__iterator(type, reverse3);
        var stack = [];
        var iterations = 0;
        return new Iterator3(function() {
          while (iterator) {
            var step = iterator.next();
            if (step.done !== false) {
              iterator = stack.pop();
              continue;
            }
            var v = step.value;
            if (type === ITERATE_ENTRIES2) {
              v = v[1];
            }
            if ((!depth || stack.length < depth) && isIterable(v)) {
              stack.push(iterator);
              iterator = v.__iterator(type, reverse3);
            } else {
              return useKeys ? step : iteratorValue2(type, iterations++, v, step);
            }
          }
          return iteratorDone2();
        });
      };
      return flatSequence;
    }
    function flatMapFactory2(iterable, mapper, context) {
      var coerce = iterableClass(iterable);
      return iterable.toSeq().map(function(v, k) {
        return coerce(mapper.call(context, v, k, iterable));
      }).flatten(true);
    }
    function interposeFactory2(iterable, separator) {
      var interposedSequence = makeSequence2(iterable);
      interposedSequence.size = iterable.size && iterable.size * 2 - 1;
      interposedSequence.__iterateUncached = function(fn, reverse3) {
        var this$0 = this;
        var iterations = 0;
        iterable.__iterate(function(v, k) {
          return (!iterations || fn(separator, iterations++, this$0) !== false) && fn(v, iterations++, this$0) !== false;
        }, reverse3);
        return iterations;
      };
      interposedSequence.__iteratorUncached = function(type, reverse3) {
        var iterator = iterable.__iterator(ITERATE_VALUES2, reverse3);
        var iterations = 0;
        var step;
        return new Iterator3(function() {
          if (!step || iterations % 2) {
            step = iterator.next();
            if (step.done) {
              return step;
            }
          }
          return iterations % 2 ? iteratorValue2(type, iterations++, separator) : iteratorValue2(type, iterations++, step.value, step);
        });
      };
      return interposedSequence;
    }
    function sortFactory2(iterable, comparator, mapper) {
      if (!comparator) {
        comparator = defaultComparator2;
      }
      var isKeyedIterable = isKeyed2(iterable);
      var index = 0;
      var entries2 = iterable.toSeq().map(function(v, k) {
        return [k, v, index++, mapper ? mapper(v, k, iterable) : v];
      }).toArray();
      entries2.sort(function(a, b) {
        return comparator(a[3], b[3]) || a[2] - b[2];
      }).forEach(isKeyedIterable ? function(v, i) {
        entries2[i].length = 2;
      } : function(v, i) {
        entries2[i] = v[1];
      });
      return isKeyedIterable ? KeyedSeq2(entries2) : isIndexed2(iterable) ? IndexedSeq2(entries2) : SetSeq2(entries2);
    }
    function maxFactory2(iterable, comparator, mapper) {
      if (!comparator) {
        comparator = defaultComparator2;
      }
      if (mapper) {
        var entry = iterable.toSeq().map(function(v, k) {
          return [v, mapper(v, k, iterable)];
        }).reduce(function(a, b) {
          return maxCompare2(comparator, a[1], b[1]) ? b : a;
        });
        return entry && entry[0];
      } else {
        return iterable.reduce(function(a, b) {
          return maxCompare2(comparator, a, b) ? b : a;
        });
      }
    }
    function maxCompare2(comparator, a, b) {
      var comp = comparator(b, a);
      return comp === 0 && b !== a && (b === void 0 || b === null || b !== b) || comp > 0;
    }
    function zipWithFactory2(keyIter, zipper, iters) {
      var zipSequence = makeSequence2(keyIter);
      zipSequence.size = new ArraySeq2(iters).map(function(i) {
        return i.size;
      }).min();
      zipSequence.__iterate = function(fn, reverse3) {
        var iterator = this.__iterator(ITERATE_VALUES2, reverse3);
        var step;
        var iterations = 0;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
        return iterations;
      };
      zipSequence.__iteratorUncached = function(type, reverse3) {
        var iterators = iters.map(function(i) {
          return i = Iterable(i), getIterator2(reverse3 ? i.reverse() : i);
        });
        var iterations = 0;
        var isDone = false;
        return new Iterator3(function() {
          var steps;
          if (!isDone) {
            steps = iterators.map(function(i) {
              return i.next();
            });
            isDone = steps.some(function(s) {
              return s.done;
            });
          }
          if (isDone) {
            return iteratorDone2();
          }
          return iteratorValue2(type, iterations++, zipper.apply(null, steps.map(function(s) {
            return s.value;
          })));
        });
      };
      return zipSequence;
    }
    function reify2(iter, seq) {
      return isSeq2(iter) ? seq : iter.constructor(seq);
    }
    function validateEntry2(entry) {
      if (entry !== Object(entry)) {
        throw new TypeError("Expected [K, V] tuple: " + entry);
      }
    }
    function resolveSize(iter) {
      assertNotInfinite2(iter.size);
      return ensureSize2(iter);
    }
    function iterableClass(iterable) {
      return isKeyed2(iterable) ? KeyedIterable : isIndexed2(iterable) ? IndexedIterable : SetIterable;
    }
    function makeSequence2(iterable) {
      return Object.create((isKeyed2(iterable) ? KeyedSeq2 : isIndexed2(iterable) ? IndexedSeq2 : SetSeq2).prototype);
    }
    function cacheResultThrough2() {
      if (this._iter.cacheResult) {
        this._iter.cacheResult();
        this.size = this._iter.size;
        return this;
      } else {
        return Seq2.prototype.cacheResult.call(this);
      }
    }
    function defaultComparator2(a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
    }
    function forceIterator(keyPath) {
      var iter = getIterator2(keyPath);
      if (!iter) {
        if (!isArrayLike2(keyPath)) {
          throw new TypeError("Expected iterable or array-like: " + keyPath);
        }
        iter = getIterator2(Iterable(keyPath));
      }
      return iter;
    }
    createClass(Record2, KeyedCollection2);
    function Record2(defaultValues, name) {
      var hasInitialized;
      var RecordType = function Record3(values2) {
        if (values2 instanceof RecordType) {
          return values2;
        }
        if (!(this instanceof RecordType)) {
          return new RecordType(values2);
        }
        if (!hasInitialized) {
          hasInitialized = true;
          var keys3 = Object.keys(defaultValues);
          setProps(RecordTypePrototype, keys3);
          RecordTypePrototype.size = keys3.length;
          RecordTypePrototype._name = name;
          RecordTypePrototype._keys = keys3;
          RecordTypePrototype._defaultValues = defaultValues;
        }
        this._map = Map2(values2);
      };
      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
      RecordTypePrototype.constructor = RecordType;
      return RecordType;
    }
    Record2.prototype.toString = function() {
      return this.__toString(recordName(this) + " {", "}");
    };
    Record2.prototype.has = function(k) {
      return this._defaultValues.hasOwnProperty(k);
    };
    Record2.prototype.get = function(k, notSetValue) {
      if (!this.has(k)) {
        return notSetValue;
      }
      var defaultVal = this._defaultValues[k];
      return this._map ? this._map.get(k, defaultVal) : defaultVal;
    };
    Record2.prototype.clear = function() {
      if (this.__ownerID) {
        this._map && this._map.clear();
        return this;
      }
      var RecordType = this.constructor;
      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap2()));
    };
    Record2.prototype.set = function(k, v) {
      if (!this.has(k)) {
        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
      }
      var newMap = this._map && this._map.set(k, v);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };
    Record2.prototype.remove = function(k) {
      if (!this.has(k)) {
        return this;
      }
      var newMap = this._map && this._map.remove(k);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };
    Record2.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };
    Record2.prototype.__iterator = function(type, reverse3) {
      var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k) {
        return this$0.get(k);
      }).__iterator(type, reverse3);
    };
    Record2.prototype.__iterate = function(fn, reverse3) {
      var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k) {
        return this$0.get(k);
      }).__iterate(fn, reverse3);
    };
    Record2.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map && this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return makeRecord(this, newMap, ownerID);
    };
    var RecordPrototype = Record2.prototype;
    RecordPrototype[DELETE2] = RecordPrototype.remove;
    RecordPrototype.deleteIn = RecordPrototype.removeIn = MapPrototype2.removeIn;
    RecordPrototype.merge = MapPrototype2.merge;
    RecordPrototype.mergeWith = MapPrototype2.mergeWith;
    RecordPrototype.mergeIn = MapPrototype2.mergeIn;
    RecordPrototype.mergeDeep = MapPrototype2.mergeDeep;
    RecordPrototype.mergeDeepWith = MapPrototype2.mergeDeepWith;
    RecordPrototype.mergeDeepIn = MapPrototype2.mergeDeepIn;
    RecordPrototype.setIn = MapPrototype2.setIn;
    RecordPrototype.update = MapPrototype2.update;
    RecordPrototype.updateIn = MapPrototype2.updateIn;
    RecordPrototype.withMutations = MapPrototype2.withMutations;
    RecordPrototype.asMutable = MapPrototype2.asMutable;
    RecordPrototype.asImmutable = MapPrototype2.asImmutable;
    function makeRecord(likeRecord, map2, ownerID) {
      var record = Object.create(Object.getPrototypeOf(likeRecord));
      record._map = map2;
      record.__ownerID = ownerID;
      return record;
    }
    function recordName(record) {
      return record._name || record.constructor.name || "Record";
    }
    function setProps(prototype, names) {
      try {
        names.forEach(setProp.bind(void 0, prototype));
      } catch (error) {
      }
    }
    function setProp(prototype, name) {
      Object.defineProperty(prototype, name, {
        get: function() {
          return this.get(name);
        },
        set: function(value) {
          invariant2(this.__ownerID, "Cannot set on an immutable record.");
          this.set(name, value);
        }
      });
    }
    createClass(Set2, SetCollection2);
    function Set2(value) {
      return value === null || value === void 0 ? emptySet2() : isSet2(value) && !isOrdered2(value) ? value : emptySet2().withMutations(function(set3) {
        var iter = SetIterable(value);
        assertNotInfinite2(iter.size);
        iter.forEach(function(v) {
          return set3.add(v);
        });
      });
    }
    Set2.of = function() {
      return this(arguments);
    };
    Set2.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };
    Set2.prototype.toString = function() {
      return this.__toString("Set {", "}");
    };
    Set2.prototype.has = function(value) {
      return this._map.has(value);
    };
    Set2.prototype.add = function(value) {
      return updateSet2(this, this._map.set(value, true));
    };
    Set2.prototype.remove = function(value) {
      return updateSet2(this, this._map.remove(value));
    };
    Set2.prototype.clear = function() {
      return updateSet2(this, this._map.clear());
    };
    Set2.prototype.union = function() {
      var iters = SLICE$0.call(arguments, 0);
      iters = iters.filter(function(x) {
        return x.size !== 0;
      });
      if (iters.length === 0) {
        return this;
      }
      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
        return this.constructor(iters[0]);
      }
      return this.withMutations(function(set3) {
        for (var ii = 0; ii < iters.length; ii++) {
          SetIterable(iters[ii]).forEach(function(value) {
            return set3.add(value);
          });
        }
      });
    };
    Set2.prototype.intersect = function() {
      var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter) {
        return SetIterable(iter);
      });
      var originalSet = this;
      return this.withMutations(function(set3) {
        originalSet.forEach(function(value) {
          if (!iters.every(function(iter) {
            return iter.includes(value);
          })) {
            set3.remove(value);
          }
        });
      });
    };
    Set2.prototype.subtract = function() {
      var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter) {
        return SetIterable(iter);
      });
      var originalSet = this;
      return this.withMutations(function(set3) {
        originalSet.forEach(function(value) {
          if (iters.some(function(iter) {
            return iter.includes(value);
          })) {
            set3.remove(value);
          }
        });
      });
    };
    Set2.prototype.merge = function() {
      return this.union.apply(this, arguments);
    };
    Set2.prototype.mergeWith = function(merger) {
      var iters = SLICE$0.call(arguments, 1);
      return this.union.apply(this, iters);
    };
    Set2.prototype.sort = function(comparator) {
      return OrderedSet2(sortFactory2(this, comparator));
    };
    Set2.prototype.sortBy = function(mapper, comparator) {
      return OrderedSet2(sortFactory2(this, comparator, mapper));
    };
    Set2.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };
    Set2.prototype.__iterate = function(fn, reverse3) {
      var this$0 = this;
      return this._map.__iterate(function(_, k) {
        return fn(k, k, this$0);
      }, reverse3);
    };
    Set2.prototype.__iterator = function(type, reverse3) {
      return this._map.map(function(_, k) {
        return k;
      }).__iterator(type, reverse3);
    };
    Set2.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return this.__make(newMap, ownerID);
    };
    function isSet2(maybeSet) {
      return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
    }
    Set2.isSet = isSet2;
    var IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
    var SetPrototype2 = Set2.prototype;
    SetPrototype2[IS_SET_SENTINEL] = true;
    SetPrototype2[DELETE2] = SetPrototype2.remove;
    SetPrototype2.mergeDeep = SetPrototype2.merge;
    SetPrototype2.mergeDeepWith = SetPrototype2.mergeWith;
    SetPrototype2.withMutations = MapPrototype2.withMutations;
    SetPrototype2.asMutable = MapPrototype2.asMutable;
    SetPrototype2.asImmutable = MapPrototype2.asImmutable;
    SetPrototype2.__empty = emptySet2;
    SetPrototype2.__make = makeSet2;
    function updateSet2(set3, newMap) {
      if (set3.__ownerID) {
        set3.size = newMap.size;
        set3._map = newMap;
        return set3;
      }
      return newMap === set3._map ? set3 : newMap.size === 0 ? set3.__empty() : set3.__make(newMap);
    }
    function makeSet2(map2, ownerID) {
      var set3 = Object.create(SetPrototype2);
      set3.size = map2 ? map2.size : 0;
      set3._map = map2;
      set3.__ownerID = ownerID;
      return set3;
    }
    var EMPTY_SET2;
    function emptySet2() {
      return EMPTY_SET2 || (EMPTY_SET2 = makeSet2(emptyMap2()));
    }
    createClass(OrderedSet2, Set2);
    function OrderedSet2(value) {
      return value === null || value === void 0 ? emptyOrderedSet2() : isOrderedSet2(value) ? value : emptyOrderedSet2().withMutations(function(set3) {
        var iter = SetIterable(value);
        assertNotInfinite2(iter.size);
        iter.forEach(function(v) {
          return set3.add(v);
        });
      });
    }
    OrderedSet2.of = function() {
      return this(arguments);
    };
    OrderedSet2.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };
    OrderedSet2.prototype.toString = function() {
      return this.__toString("OrderedSet {", "}");
    };
    function isOrderedSet2(maybeOrderedSet) {
      return isSet2(maybeOrderedSet) && isOrdered2(maybeOrderedSet);
    }
    OrderedSet2.isOrderedSet = isOrderedSet2;
    var OrderedSetPrototype2 = OrderedSet2.prototype;
    OrderedSetPrototype2[IS_ORDERED_SENTINEL] = true;
    OrderedSetPrototype2.__empty = emptyOrderedSet2;
    OrderedSetPrototype2.__make = makeOrderedSet2;
    function makeOrderedSet2(map2, ownerID) {
      var set3 = Object.create(OrderedSetPrototype2);
      set3.size = map2 ? map2.size : 0;
      set3._map = map2;
      set3.__ownerID = ownerID;
      return set3;
    }
    var EMPTY_ORDERED_SET2;
    function emptyOrderedSet2() {
      return EMPTY_ORDERED_SET2 || (EMPTY_ORDERED_SET2 = makeOrderedSet2(emptyOrderedMap2()));
    }
    createClass(Stack2, IndexedCollection2);
    function Stack2(value) {
      return value === null || value === void 0 ? emptyStack2() : isStack2(value) ? value : emptyStack2().unshiftAll(value);
    }
    Stack2.of = function() {
      return this(arguments);
    };
    Stack2.prototype.toString = function() {
      return this.__toString("Stack [", "]");
    };
    Stack2.prototype.get = function(index, notSetValue) {
      var head = this._head;
      index = wrapIndex2(this, index);
      while (head && index--) {
        head = head.next;
      }
      return head ? head.value : notSetValue;
    };
    Stack2.prototype.peek = function() {
      return this._head && this._head.value;
    };
    Stack2.prototype.push = function() {
      if (arguments.length === 0) {
        return this;
      }
      var newSize = this.size + arguments.length;
      var head = this._head;
      for (var ii = arguments.length - 1; ii >= 0; ii--) {
        head = {
          value: arguments[ii],
          next: head
        };
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = void 0;
        this.__altered = true;
        return this;
      }
      return makeStack2(newSize, head);
    };
    Stack2.prototype.pushAll = function(iter) {
      iter = IndexedIterable(iter);
      if (iter.size === 0) {
        return this;
      }
      assertNotInfinite2(iter.size);
      var newSize = this.size;
      var head = this._head;
      iter.reverse().forEach(function(value) {
        newSize++;
        head = {
          value,
          next: head
        };
      });
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = void 0;
        this.__altered = true;
        return this;
      }
      return makeStack2(newSize, head);
    };
    Stack2.prototype.pop = function() {
      return this.slice(1);
    };
    Stack2.prototype.unshift = function() {
      return this.push.apply(this, arguments);
    };
    Stack2.prototype.unshiftAll = function(iter) {
      return this.pushAll(iter);
    };
    Stack2.prototype.shift = function() {
      return this.pop.apply(this, arguments);
    };
    Stack2.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._head = void 0;
        this.__hash = void 0;
        this.__altered = true;
        return this;
      }
      return emptyStack2();
    };
    Stack2.prototype.slice = function(begin, end) {
      if (wholeSlice2(begin, end, this.size)) {
        return this;
      }
      var resolvedBegin = resolveBegin2(begin, this.size);
      var resolvedEnd = resolveEnd2(end, this.size);
      if (resolvedEnd !== this.size) {
        return IndexedCollection2.prototype.slice.call(this, begin, end);
      }
      var newSize = this.size - resolvedBegin;
      var head = this._head;
      while (resolvedBegin--) {
        head = head.next;
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = void 0;
        this.__altered = true;
        return this;
      }
      return makeStack2(newSize, head);
    };
    Stack2.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeStack2(this.size, this._head, ownerID, this.__hash);
    };
    Stack2.prototype.__iterate = function(fn, reverse3) {
      if (reverse3) {
        return this.reverse().__iterate(fn);
      }
      var iterations = 0;
      var node = this._head;
      while (node) {
        if (fn(node.value, iterations++, this) === false) {
          break;
        }
        node = node.next;
      }
      return iterations;
    };
    Stack2.prototype.__iterator = function(type, reverse3) {
      if (reverse3) {
        return this.reverse().__iterator(type);
      }
      var iterations = 0;
      var node = this._head;
      return new Iterator3(function() {
        if (node) {
          var value = node.value;
          node = node.next;
          return iteratorValue2(type, iterations++, value);
        }
        return iteratorDone2();
      });
    };
    function isStack2(maybeStack) {
      return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
    }
    Stack2.isStack = isStack2;
    var IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
    var StackPrototype2 = Stack2.prototype;
    StackPrototype2[IS_STACK_SENTINEL] = true;
    StackPrototype2.withMutations = MapPrototype2.withMutations;
    StackPrototype2.asMutable = MapPrototype2.asMutable;
    StackPrototype2.asImmutable = MapPrototype2.asImmutable;
    StackPrototype2.wasAltered = MapPrototype2.wasAltered;
    function makeStack2(size, head, ownerID, hash3) {
      var map2 = Object.create(StackPrototype2);
      map2.size = size;
      map2._head = head;
      map2.__ownerID = ownerID;
      map2.__hash = hash3;
      map2.__altered = false;
      return map2;
    }
    var EMPTY_STACK2;
    function emptyStack2() {
      return EMPTY_STACK2 || (EMPTY_STACK2 = makeStack2(0));
    }
    function mixin2(ctor, methods) {
      var keyCopier = function(key) {
        ctor.prototype[key] = methods[key];
      };
      Object.keys(methods).forEach(keyCopier);
      Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
      return ctor;
    }
    Iterable.Iterator = Iterator3;
    mixin2(Iterable, {
      toArray: function() {
        assertNotInfinite2(this.size);
        var array = new Array(this.size || 0);
        this.valueSeq().__iterate(function(v, i) {
          array[i] = v;
        });
        return array;
      },
      toIndexedSeq: function() {
        return new ToIndexedSequence2(this);
      },
      toJS: function() {
        return this.toSeq().map(function(value) {
          return value && typeof value.toJS === "function" ? value.toJS() : value;
        }).__toJS();
      },
      toJSON: function() {
        return this.toSeq().map(function(value) {
          return value && typeof value.toJSON === "function" ? value.toJSON() : value;
        }).__toJS();
      },
      toKeyedSeq: function() {
        return new ToKeyedSequence2(this, true);
      },
      toMap: function() {
        return Map2(this.toKeyedSeq());
      },
      toObject: function() {
        assertNotInfinite2(this.size);
        var object = {};
        this.__iterate(function(v, k) {
          object[k] = v;
        });
        return object;
      },
      toOrderedMap: function() {
        return OrderedMap2(this.toKeyedSeq());
      },
      toOrderedSet: function() {
        return OrderedSet2(isKeyed2(this) ? this.valueSeq() : this);
      },
      toSet: function() {
        return Set2(isKeyed2(this) ? this.valueSeq() : this);
      },
      toSetSeq: function() {
        return new ToSetSequence2(this);
      },
      toSeq: function() {
        return isIndexed2(this) ? this.toIndexedSeq() : isKeyed2(this) ? this.toKeyedSeq() : this.toSetSeq();
      },
      toStack: function() {
        return Stack2(isKeyed2(this) ? this.valueSeq() : this);
      },
      toList: function() {
        return List2(isKeyed2(this) ? this.valueSeq() : this);
      },
      toString: function() {
        return "[Iterable]";
      },
      __toString: function(head, tail) {
        if (this.size === 0) {
          return head + tail;
        }
        return head + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + tail;
      },
      concat: function() {
        var values2 = SLICE$0.call(arguments, 0);
        return reify2(this, concatFactory2(this, values2));
      },
      includes: function(searchValue) {
        return this.some(function(value) {
          return is2(value, searchValue);
        });
      },
      entries: function() {
        return this.__iterator(ITERATE_ENTRIES2);
      },
      every: function(predicate, context) {
        assertNotInfinite2(this.size);
        var returnValue = true;
        this.__iterate(function(v, k, c) {
          if (!predicate.call(context, v, k, c)) {
            returnValue = false;
            return false;
          }
        });
        return returnValue;
      },
      filter: function(predicate, context) {
        return reify2(this, filterFactory2(this, predicate, context, true));
      },
      find: function(predicate, context, notSetValue) {
        var entry = this.findEntry(predicate, context);
        return entry ? entry[1] : notSetValue;
      },
      findEntry: function(predicate, context) {
        var found;
        this.__iterate(function(v, k, c) {
          if (predicate.call(context, v, k, c)) {
            found = [k, v];
            return false;
          }
        });
        return found;
      },
      findLastEntry: function(predicate, context) {
        return this.toSeq().reverse().findEntry(predicate, context);
      },
      forEach: function(sideEffect, context) {
        assertNotInfinite2(this.size);
        return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
      },
      join: function(separator) {
        assertNotInfinite2(this.size);
        separator = separator !== void 0 ? "" + separator : ",";
        var joined = "";
        var isFirst = true;
        this.__iterate(function(v) {
          isFirst ? isFirst = false : joined += separator;
          joined += v !== null && v !== void 0 ? v.toString() : "";
        });
        return joined;
      },
      keys: function() {
        return this.__iterator(ITERATE_KEYS2);
      },
      map: function(mapper, context) {
        return reify2(this, mapFactory2(this, mapper, context));
      },
      reduce: function(reducer2, initialReduction, context) {
        assertNotInfinite2(this.size);
        var reduction;
        var useFirst;
        if (arguments.length < 2) {
          useFirst = true;
        } else {
          reduction = initialReduction;
        }
        this.__iterate(function(v, k, c) {
          if (useFirst) {
            useFirst = false;
            reduction = v;
          } else {
            reduction = reducer2.call(context, reduction, v, k, c);
          }
        });
        return reduction;
      },
      reduceRight: function(reducer2, initialReduction, context) {
        var reversed = this.toKeyedSeq().reverse();
        return reversed.reduce.apply(reversed, arguments);
      },
      reverse: function() {
        return reify2(this, reverseFactory2(this, true));
      },
      slice: function(begin, end) {
        return reify2(this, sliceFactory2(this, begin, end, true));
      },
      some: function(predicate, context) {
        return !this.every(not2(predicate), context);
      },
      sort: function(comparator) {
        return reify2(this, sortFactory2(this, comparator));
      },
      values: function() {
        return this.__iterator(ITERATE_VALUES2);
      },
      butLast: function() {
        return this.slice(0, -1);
      },
      isEmpty: function() {
        return this.size !== void 0 ? this.size === 0 : !this.some(function() {
          return true;
        });
      },
      count: function(predicate, context) {
        return ensureSize2(predicate ? this.toSeq().filter(predicate, context) : this);
      },
      countBy: function(grouper, context) {
        return countByFactory2(this, grouper, context);
      },
      equals: function(other) {
        return deepEqual2(this, other);
      },
      entrySeq: function() {
        var iterable = this;
        if (iterable._cache) {
          return new ArraySeq2(iterable._cache);
        }
        var entriesSequence = iterable.toSeq().map(entryMapper2).toIndexedSeq();
        entriesSequence.fromEntrySeq = function() {
          return iterable.toSeq();
        };
        return entriesSequence;
      },
      filterNot: function(predicate, context) {
        return this.filter(not2(predicate), context);
      },
      findLast: function(predicate, context, notSetValue) {
        return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
      },
      first: function() {
        return this.find(returnTrue3);
      },
      flatMap: function(mapper, context) {
        return reify2(this, flatMapFactory2(this, mapper, context));
      },
      flatten: function(depth) {
        return reify2(this, flattenFactory2(this, depth, true));
      },
      fromEntrySeq: function() {
        return new FromEntriesSequence2(this);
      },
      get: function(searchKey, notSetValue) {
        return this.find(function(_, key) {
          return is2(key, searchKey);
        }, void 0, notSetValue);
      },
      getIn: function(searchKeyPath, notSetValue) {
        var nested = this;
        var iter = forceIterator(searchKeyPath);
        var step;
        while (!(step = iter.next()).done) {
          var key = step.value;
          nested = nested && nested.get ? nested.get(key, NOT_SET2) : NOT_SET2;
          if (nested === NOT_SET2) {
            return notSetValue;
          }
        }
        return nested;
      },
      groupBy: function(grouper, context) {
        return groupByFactory2(this, grouper, context);
      },
      has: function(searchKey) {
        return this.get(searchKey, NOT_SET2) !== NOT_SET2;
      },
      hasIn: function(searchKeyPath) {
        return this.getIn(searchKeyPath, NOT_SET2) !== NOT_SET2;
      },
      isSubset: function(iter) {
        iter = typeof iter.includes === "function" ? iter : Iterable(iter);
        return this.every(function(value) {
          return iter.includes(value);
        });
      },
      isSuperset: function(iter) {
        iter = typeof iter.isSubset === "function" ? iter : Iterable(iter);
        return iter.isSubset(this);
      },
      keySeq: function() {
        return this.toSeq().map(keyMapper2).toIndexedSeq();
      },
      last: function() {
        return this.toSeq().reverse().first();
      },
      max: function(comparator) {
        return maxFactory2(this, comparator);
      },
      maxBy: function(mapper, comparator) {
        return maxFactory2(this, comparator, mapper);
      },
      min: function(comparator) {
        return maxFactory2(this, comparator ? neg2(comparator) : defaultNegComparator2);
      },
      minBy: function(mapper, comparator) {
        return maxFactory2(this, comparator ? neg2(comparator) : defaultNegComparator2, mapper);
      },
      rest: function() {
        return this.slice(1);
      },
      skip: function(amount) {
        return this.slice(Math.max(0, amount));
      },
      skipLast: function(amount) {
        return reify2(this, this.toSeq().reverse().skip(amount).reverse());
      },
      skipWhile: function(predicate, context) {
        return reify2(this, skipWhileFactory2(this, predicate, context, true));
      },
      skipUntil: function(predicate, context) {
        return this.skipWhile(not2(predicate), context);
      },
      sortBy: function(mapper, comparator) {
        return reify2(this, sortFactory2(this, comparator, mapper));
      },
      take: function(amount) {
        return this.slice(0, Math.max(0, amount));
      },
      takeLast: function(amount) {
        return reify2(this, this.toSeq().reverse().take(amount).reverse());
      },
      takeWhile: function(predicate, context) {
        return reify2(this, takeWhileFactory2(this, predicate, context));
      },
      takeUntil: function(predicate, context) {
        return this.takeWhile(not2(predicate), context);
      },
      valueSeq: function() {
        return this.toIndexedSeq();
      },
      hashCode: function() {
        return this.__hash || (this.__hash = hashIterable(this));
      }
    });
    var IterablePrototype = Iterable.prototype;
    IterablePrototype[IS_ITERABLE_SENTINEL] = true;
    IterablePrototype[ITERATOR_SYMBOL2] = IterablePrototype.values;
    IterablePrototype.__toJS = IterablePrototype.toArray;
    IterablePrototype.__toStringMapper = quoteString2;
    IterablePrototype.inspect = IterablePrototype.toSource = function() {
      return this.toString();
    };
    IterablePrototype.chain = IterablePrototype.flatMap;
    IterablePrototype.contains = IterablePrototype.includes;
    (function() {
      try {
        Object.defineProperty(IterablePrototype, "length", {
          get: function() {
            if (!Iterable.noLengthWarning) {
              var stack;
              try {
                throw new Error();
              } catch (error) {
                stack = error.stack;
              }
              if (stack.indexOf("_wrapObject") === -1) {
                console && console.warn && console.warn("iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version. " + stack);
                return this.size;
              }
            }
          }
        });
      } catch (e) {
      }
    })();
    mixin2(KeyedIterable, {
      flip: function() {
        return reify2(this, flipFactory2(this));
      },
      findKey: function(predicate, context) {
        var entry = this.findEntry(predicate, context);
        return entry && entry[0];
      },
      findLastKey: function(predicate, context) {
        return this.toSeq().reverse().findKey(predicate, context);
      },
      keyOf: function(searchValue) {
        return this.findKey(function(value) {
          return is2(value, searchValue);
        });
      },
      lastKeyOf: function(searchValue) {
        return this.findLastKey(function(value) {
          return is2(value, searchValue);
        });
      },
      mapEntries: function(mapper, context) {
        var this$0 = this;
        var iterations = 0;
        return reify2(this, this.toSeq().map(function(v, k) {
          return mapper.call(context, [k, v], iterations++, this$0);
        }).fromEntrySeq());
      },
      mapKeys: function(mapper, context) {
        var this$0 = this;
        return reify2(this, this.toSeq().flip().map(function(k, v) {
          return mapper.call(context, k, v, this$0);
        }).flip());
      }
    });
    var KeyedIterablePrototype = KeyedIterable.prototype;
    KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
    KeyedIterablePrototype[ITERATOR_SYMBOL2] = IterablePrototype.entries;
    KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
    KeyedIterablePrototype.__toStringMapper = function(v, k) {
      return JSON.stringify(k) + ": " + quoteString2(v);
    };
    mixin2(IndexedIterable, {
      toKeyedSeq: function() {
        return new ToKeyedSequence2(this, false);
      },
      filter: function(predicate, context) {
        return reify2(this, filterFactory2(this, predicate, context, false));
      },
      findIndex: function(predicate, context) {
        var entry = this.findEntry(predicate, context);
        return entry ? entry[0] : -1;
      },
      indexOf: function(searchValue) {
        var key = this.toKeyedSeq().keyOf(searchValue);
        return key === void 0 ? -1 : key;
      },
      lastIndexOf: function(searchValue) {
        var key = this.toKeyedSeq().reverse().keyOf(searchValue);
        return key === void 0 ? -1 : key;
      },
      reverse: function() {
        return reify2(this, reverseFactory2(this, false));
      },
      slice: function(begin, end) {
        return reify2(this, sliceFactory2(this, begin, end, false));
      },
      splice: function(index, removeNum) {
        var numArgs = arguments.length;
        removeNum = Math.max(removeNum | 0, 0);
        if (numArgs === 0 || numArgs === 2 && !removeNum) {
          return this;
        }
        index = resolveBegin2(index, index < 0 ? this.count() : this.size);
        var spliced = this.slice(0, index);
        return reify2(this, numArgs === 1 ? spliced : spliced.concat(arrCopy2(arguments, 2), this.slice(index + removeNum)));
      },
      findLastIndex: function(predicate, context) {
        var key = this.toKeyedSeq().findLastKey(predicate, context);
        return key === void 0 ? -1 : key;
      },
      first: function() {
        return this.get(0);
      },
      flatten: function(depth) {
        return reify2(this, flattenFactory2(this, depth, false));
      },
      get: function(index, notSetValue) {
        index = wrapIndex2(this, index);
        return index < 0 || this.size === Infinity || this.size !== void 0 && index > this.size ? notSetValue : this.find(function(_, key) {
          return key === index;
        }, void 0, notSetValue);
      },
      has: function(index) {
        index = wrapIndex2(this, index);
        return index >= 0 && (this.size !== void 0 ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
      },
      interpose: function(separator) {
        return reify2(this, interposeFactory2(this, separator));
      },
      interleave: function() {
        var iterables = [this].concat(arrCopy2(arguments));
        var zipped = zipWithFactory2(this.toSeq(), IndexedSeq2.of, iterables);
        var interleaved = zipped.flatten(true);
        if (zipped.size) {
          interleaved.size = zipped.size * iterables.length;
        }
        return reify2(this, interleaved);
      },
      last: function() {
        return this.get(-1);
      },
      skipWhile: function(predicate, context) {
        return reify2(this, skipWhileFactory2(this, predicate, context, false));
      },
      zip: function() {
        var iterables = [this].concat(arrCopy2(arguments));
        return reify2(this, zipWithFactory2(this, defaultZipper2, iterables));
      },
      zipWith: function(zipper) {
        var iterables = arrCopy2(arguments);
        iterables[0] = this;
        return reify2(this, zipWithFactory2(this, zipper, iterables));
      }
    });
    IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
    IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
    mixin2(SetIterable, {
      get: function(value, notSetValue) {
        return this.has(value) ? value : notSetValue;
      },
      includes: function(value) {
        return this.has(value);
      },
      keySeq: function() {
        return this.valueSeq();
      }
    });
    SetIterable.prototype.has = IterablePrototype.includes;
    mixin2(KeyedSeq2, KeyedIterable.prototype);
    mixin2(IndexedSeq2, IndexedIterable.prototype);
    mixin2(SetSeq2, SetIterable.prototype);
    mixin2(KeyedCollection2, KeyedIterable.prototype);
    mixin2(IndexedCollection2, IndexedIterable.prototype);
    mixin2(SetCollection2, SetIterable.prototype);
    function keyMapper2(v, k) {
      return k;
    }
    function entryMapper2(v, k) {
      return [k, v];
    }
    function not2(predicate) {
      return function() {
        return !predicate.apply(this, arguments);
      };
    }
    function neg2(predicate) {
      return function() {
        return -predicate.apply(this, arguments);
      };
    }
    function quoteString2(value) {
      return typeof value === "string" ? JSON.stringify(value) : value;
    }
    function defaultZipper2() {
      return arrCopy2(arguments);
    }
    function defaultNegComparator2(a, b) {
      return a < b ? 1 : a > b ? -1 : 0;
    }
    function hashIterable(iterable) {
      if (iterable.size === Infinity) {
        return 0;
      }
      var ordered = isOrdered2(iterable);
      var keyed = isKeyed2(iterable);
      var h = ordered ? 1 : 0;
      var size = iterable.__iterate(keyed ? ordered ? function(v, k) {
        h = 31 * h + hashMerge2(hash2(v), hash2(k)) | 0;
      } : function(v, k) {
        h = h + hashMerge2(hash2(v), hash2(k)) | 0;
      } : ordered ? function(v) {
        h = 31 * h + hash2(v) | 0;
      } : function(v) {
        h = h + hash2(v) | 0;
      });
      return murmurHashOfSize2(size, h);
    }
    function murmurHashOfSize2(size, h) {
      h = imul3(h, 3432918353);
      h = imul3(h << 15 | h >>> -15, 461845907);
      h = imul3(h << 13 | h >>> -13, 5);
      h = (h + 3864292196 | 0) ^ size;
      h = imul3(h ^ h >>> 16, 2246822507);
      h = imul3(h ^ h >>> 13, 3266489909);
      h = smi2(h ^ h >>> 16);
      return h;
    }
    function hashMerge2(a, b) {
      return a ^ b + 2654435769 + (a << 6) + (a >> 2) | 0;
    }
    var Immutable2 = {
      Iterable,
      Seq: Seq2,
      Collection: Collection3,
      Map: Map2,
      OrderedMap: OrderedMap2,
      List: List2,
      Stack: Stack2,
      Set: Set2,
      OrderedSet: OrderedSet2,
      Record: Record2,
      Range: Range2,
      Repeat: Repeat2,
      is: is2,
      fromJS: fromJS2
    };
    return Immutable2;
  });
})(immutable$1);
var Immutable$q = immutable$1.exports;
var OrderedMap$7 = Immutable$q.OrderedMap;
var BlockMapBuilder$5 = {
  createFromArray: function createFromArray(blocks) {
    return OrderedMap$7(blocks.map(function(block) {
      return [block.getKey(), block];
    }));
  }
};
var BlockMapBuilder_1 = BlockMapBuilder$5;
function _inheritsLoose$f(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var _require$6 = immutable$1.exports, Map$h = _require$6.Map, OrderedSet$7 = _require$6.OrderedSet, Record$7 = _require$6.Record;
var EMPTY_SET$5 = OrderedSet$7();
var defaultRecord$5 = {
  style: EMPTY_SET$5,
  entity: null
};
var CharacterMetadataRecord = Record$7(defaultRecord$5);
var CharacterMetadata$c = /* @__PURE__ */ function(_CharacterMetadataRec) {
  _inheritsLoose$f(CharacterMetadata2, _CharacterMetadataRec);
  function CharacterMetadata2() {
    return _CharacterMetadataRec.apply(this, arguments) || this;
  }
  var _proto = CharacterMetadata2.prototype;
  _proto.getStyle = function getStyle() {
    return this.get("style");
  };
  _proto.getEntity = function getEntity2() {
    return this.get("entity");
  };
  _proto.hasStyle = function hasStyle(style) {
    return this.getStyle().includes(style);
  };
  CharacterMetadata2.applyStyle = function applyStyle(record, style) {
    var withStyle = record.set("style", record.getStyle().add(style));
    return CharacterMetadata2.create(withStyle);
  };
  CharacterMetadata2.removeStyle = function removeStyle(record, style) {
    var withoutStyle = record.set("style", record.getStyle().remove(style));
    return CharacterMetadata2.create(withoutStyle);
  };
  CharacterMetadata2.applyEntity = function applyEntity2(record, entityKey) {
    var withEntity = record.getEntity() === entityKey ? record : record.set("entity", entityKey);
    return CharacterMetadata2.create(withEntity);
  };
  CharacterMetadata2.create = function create2(config) {
    if (!config) {
      return EMPTY;
    }
    var defaultConfig = {
      style: EMPTY_SET$5,
      entity: null
    };
    var configMap = Map$h(defaultConfig).merge(config);
    var existing = pool.get(configMap);
    if (existing) {
      return existing;
    }
    var newCharacter = new CharacterMetadata2(configMap);
    pool = pool.set(configMap, newCharacter);
    return newCharacter;
  };
  CharacterMetadata2.fromJS = function fromJS2(_ref) {
    var style = _ref.style, entity = _ref.entity;
    return new CharacterMetadata2({
      style: Array.isArray(style) ? OrderedSet$7(style) : style,
      entity: Array.isArray(entity) ? OrderedSet$7(entity) : entity
    });
  };
  return CharacterMetadata2;
}(CharacterMetadataRecord);
var EMPTY = new CharacterMetadata$c();
var pool = Map$h([[Map$h(defaultRecord$5), EMPTY]]);
CharacterMetadata$c.EMPTY = EMPTY;
var CharacterMetadata_1 = CharacterMetadata$c;
function findRangesImmutable$5(haystack, areEqualFn, filterFn, foundFn) {
  if (!haystack.size) {
    return;
  }
  var cursor = 0;
  haystack.reduce(function(value, nextValue, nextIndex) {
    if (!areEqualFn(value, nextValue)) {
      if (filterFn(value)) {
        foundFn(cursor, nextIndex);
      }
      cursor = nextIndex;
    }
    return nextValue;
  });
  filterFn(haystack.last()) && foundFn(cursor, haystack.count());
}
var findRangesImmutable_1 = findRangesImmutable$5;
function _inheritsLoose$e(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var CharacterMetadata$b = CharacterMetadata_1;
var findRangesImmutable$4 = findRangesImmutable_1;
var Immutable$p = immutable$1.exports;
var List$f = Immutable$p.List, Map$g = Immutable$p.Map, OrderedSet$6 = Immutable$p.OrderedSet, Record$6 = Immutable$p.Record, Repeat$6 = Immutable$p.Repeat;
var EMPTY_SET$4 = OrderedSet$6();
var defaultRecord$4 = {
  key: "",
  type: "unstyled",
  text: "",
  characterList: List$f(),
  depth: 0,
  data: Map$g()
};
var ContentBlockRecord$2 = Record$6(defaultRecord$4);
var decorateCharacterList$1 = function decorateCharacterList(config) {
  if (!config) {
    return config;
  }
  var characterList = config.characterList, text = config.text;
  if (text && !characterList) {
    config.characterList = List$f(Repeat$6(CharacterMetadata$b.EMPTY, text.length));
  }
  return config;
};
var ContentBlock$7 = /* @__PURE__ */ function(_ContentBlockRecord) {
  _inheritsLoose$e(ContentBlock2, _ContentBlockRecord);
  function ContentBlock2(config) {
    return _ContentBlockRecord.call(this, decorateCharacterList$1(config)) || this;
  }
  var _proto = ContentBlock2.prototype;
  _proto.getKey = function getKey() {
    return this.get("key");
  };
  _proto.getType = function getType() {
    return this.get("type");
  };
  _proto.getText = function getText() {
    return this.get("text");
  };
  _proto.getCharacterList = function getCharacterList() {
    return this.get("characterList");
  };
  _proto.getLength = function getLength() {
    return this.getText().length;
  };
  _proto.getDepth = function getDepth() {
    return this.get("depth");
  };
  _proto.getData = function getData2() {
    return this.get("data");
  };
  _proto.getInlineStyleAt = function getInlineStyleAt(offset) {
    var character = this.getCharacterList().get(offset);
    return character ? character.getStyle() : EMPTY_SET$4;
  };
  _proto.getEntityAt = function getEntityAt(offset) {
    var character = this.getCharacterList().get(offset);
    return character ? character.getEntity() : null;
  };
  _proto.findStyleRanges = function findStyleRanges(filterFn, callback) {
    findRangesImmutable$4(this.getCharacterList(), haveEqualStyle$1, filterFn, callback);
  };
  _proto.findEntityRanges = function findEntityRanges(filterFn, callback) {
    findRangesImmutable$4(this.getCharacterList(), haveEqualEntity$1, filterFn, callback);
  };
  return ContentBlock2;
}(ContentBlockRecord$2);
function haveEqualStyle$1(charA, charB) {
  return charA.getStyle() === charB.getStyle();
}
function haveEqualEntity$1(charA, charB) {
  return charA.getEntity() === charB.getEntity();
}
var ContentBlock_1 = ContentBlock$7;
function _inheritsLoose$d(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var CharacterMetadata$a = CharacterMetadata_1;
var findRangesImmutable$3 = findRangesImmutable_1;
var Immutable$o = immutable$1.exports;
var List$e = Immutable$o.List, Map$f = Immutable$o.Map, OrderedSet$5 = Immutable$o.OrderedSet, Record$5 = Immutable$o.Record, Repeat$5 = Immutable$o.Repeat;
var EMPTY_SET$3 = OrderedSet$5();
var defaultRecord$3 = {
  parent: null,
  characterList: List$e(),
  data: Map$f(),
  depth: 0,
  key: "",
  text: "",
  type: "unstyled",
  children: List$e(),
  prevSibling: null,
  nextSibling: null
};
var haveEqualStyle = function haveEqualStyle2(charA, charB) {
  return charA.getStyle() === charB.getStyle();
};
var haveEqualEntity = function haveEqualEntity2(charA, charB) {
  return charA.getEntity() === charB.getEntity();
};
var decorateCharacterList2 = function decorateCharacterList3(config) {
  if (!config) {
    return config;
  }
  var characterList = config.characterList, text = config.text;
  if (text && !characterList) {
    config.characterList = List$e(Repeat$5(CharacterMetadata$a.EMPTY, text.length));
  }
  return config;
};
var ContentBlockNode$c = /* @__PURE__ */ function(_ref) {
  _inheritsLoose$d(ContentBlockNode2, _ref);
  function ContentBlockNode2() {
    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultRecord$3;
    return _ref.call(this, decorateCharacterList2(props)) || this;
  }
  var _proto = ContentBlockNode2.prototype;
  _proto.getKey = function getKey() {
    return this.get("key");
  };
  _proto.getType = function getType() {
    return this.get("type");
  };
  _proto.getText = function getText() {
    return this.get("text");
  };
  _proto.getCharacterList = function getCharacterList() {
    return this.get("characterList");
  };
  _proto.getLength = function getLength() {
    return this.getText().length;
  };
  _proto.getDepth = function getDepth() {
    return this.get("depth");
  };
  _proto.getData = function getData2() {
    return this.get("data");
  };
  _proto.getInlineStyleAt = function getInlineStyleAt(offset) {
    var character = this.getCharacterList().get(offset);
    return character ? character.getStyle() : EMPTY_SET$3;
  };
  _proto.getEntityAt = function getEntityAt(offset) {
    var character = this.getCharacterList().get(offset);
    return character ? character.getEntity() : null;
  };
  _proto.getChildKeys = function getChildKeys() {
    return this.get("children");
  };
  _proto.getParentKey = function getParentKey() {
    return this.get("parent");
  };
  _proto.getPrevSiblingKey = function getPrevSiblingKey() {
    return this.get("prevSibling");
  };
  _proto.getNextSiblingKey = function getNextSiblingKey() {
    return this.get("nextSibling");
  };
  _proto.findStyleRanges = function findStyleRanges(filterFn, callback) {
    findRangesImmutable$3(this.getCharacterList(), haveEqualStyle, filterFn, callback);
  };
  _proto.findEntityRanges = function findEntityRanges(filterFn, callback) {
    findRangesImmutable$3(this.getCharacterList(), haveEqualEntity, filterFn, callback);
  };
  return ContentBlockNode2;
}(Record$5(defaultRecord$3));
var ContentBlockNode_1 = ContentBlockNode$c;
var CharacterMetadata$9 = CharacterMetadata_1;
var _require$5 = immutable$1.exports, Map$e = _require$5.Map;
var ContentStateInlineStyle$1 = {
  add: function add(contentState, selectionState, inlineStyle) {
    return modifyInlineStyle(contentState, selectionState, inlineStyle, true);
  },
  remove: function remove(contentState, selectionState, inlineStyle) {
    return modifyInlineStyle(contentState, selectionState, inlineStyle, false);
  }
};
function modifyInlineStyle(contentState, selectionState, inlineStyle, addOrRemove) {
  var blockMap = contentState.getBlockMap();
  var startKey = selectionState.getStartKey();
  var startOffset = selectionState.getStartOffset();
  var endKey = selectionState.getEndKey();
  var endOffset = selectionState.getEndOffset();
  var newBlocks = blockMap.skipUntil(function(_, k) {
    return k === startKey;
  }).takeUntil(function(_, k) {
    return k === endKey;
  }).concat(Map$e([[endKey, blockMap.get(endKey)]])).map(function(block, blockKey) {
    var sliceStart;
    var sliceEnd;
    if (startKey === endKey) {
      sliceStart = startOffset;
      sliceEnd = endOffset;
    } else {
      sliceStart = blockKey === startKey ? startOffset : 0;
      sliceEnd = blockKey === endKey ? endOffset : block.getLength();
    }
    var chars = block.getCharacterList();
    var current;
    while (sliceStart < sliceEnd) {
      current = chars.get(sliceStart);
      chars = chars.set(sliceStart, addOrRemove ? CharacterMetadata$9.applyStyle(current, inlineStyle) : CharacterMetadata$9.removeStyle(current, inlineStyle));
      sliceStart++;
    }
    return block.set("characterList", chars);
  });
  return contentState.merge({
    blockMap: blockMap.merge(newBlocks),
    selectionBefore: selectionState,
    selectionAfter: selectionState
  });
}
var ContentStateInlineStyle_1 = ContentStateInlineStyle$1;
var CharacterMetadata$8 = CharacterMetadata_1;
function applyEntityToContentBlock$1(contentBlock, startArg, end, entityKey) {
  var start = startArg;
  var characterList = contentBlock.getCharacterList();
  while (start < end) {
    characterList = characterList.set(start, CharacterMetadata$8.applyEntity(characterList.get(start), entityKey));
    start++;
  }
  return contentBlock.set("characterList", characterList);
}
var applyEntityToContentBlock_1 = applyEntityToContentBlock$1;
var applyEntityToContentBlock = applyEntityToContentBlock_1;
var Immutable$n = immutable$1.exports;
function applyEntityToContentState$1(contentState, selectionState, entityKey) {
  var blockMap = contentState.getBlockMap();
  var startKey = selectionState.getStartKey();
  var startOffset = selectionState.getStartOffset();
  var endKey = selectionState.getEndKey();
  var endOffset = selectionState.getEndOffset();
  var newBlocks = blockMap.skipUntil(function(_, k) {
    return k === startKey;
  }).takeUntil(function(_, k) {
    return k === endKey;
  }).toOrderedMap().merge(Immutable$n.OrderedMap([[endKey, blockMap.get(endKey)]])).map(function(block, blockKey) {
    var sliceStart = blockKey === startKey ? startOffset : 0;
    var sliceEnd = blockKey === endKey ? endOffset : block.getLength();
    return applyEntityToContentBlock(block, sliceStart, sliceEnd, entityKey);
  });
  return contentState.merge({
    blockMap: blockMap.merge(newBlocks),
    selectionBefore: selectionState,
    selectionAfter: selectionState
  });
}
var applyEntityToContentState_1 = applyEntityToContentState$1;
var DraftEntitySegments$1 = {
  getRemovalRange: function getRemovalRange(selectionStart, selectionEnd, text, entityStart, direction) {
    var segments = text.split(" ");
    segments = segments.map(function(segment2, ii) {
      if (direction === "forward") {
        if (ii > 0) {
          return " " + segment2;
        }
      } else if (ii < segments.length - 1) {
        return segment2 + " ";
      }
      return segment2;
    });
    var segmentStart = entityStart;
    var segmentEnd;
    var segment;
    var removalStart = null;
    var removalEnd = null;
    for (var jj = 0; jj < segments.length; jj++) {
      segment = segments[jj];
      segmentEnd = segmentStart + segment.length;
      if (selectionStart < segmentEnd && segmentStart < selectionEnd) {
        if (removalStart !== null) {
          removalEnd = segmentEnd;
        } else {
          removalStart = segmentStart;
          removalEnd = segmentEnd;
        }
      } else if (removalStart !== null) {
        break;
      }
      segmentStart = segmentEnd;
    }
    var entityEnd = entityStart + text.length;
    var atStart = removalStart === entityStart;
    var atEnd = removalEnd === entityEnd;
    if (!atStart && atEnd || atStart && !atEnd) {
      if (direction === "forward") {
        if (removalEnd !== entityEnd) {
          removalEnd++;
        }
      } else if (removalStart !== entityStart) {
        removalStart--;
      }
    }
    return {
      start: removalStart,
      end: removalEnd
    };
  }
};
var DraftEntitySegments_1 = DraftEntitySegments$1;
function invariant$w(condition, format) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  if (!condition) {
    var error;
    if (format === void 0) {
      error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    } else {
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function() {
        return String(args[argIndex++]);
      }));
      error.name = "Invariant Violation";
    }
    error.framesToPop = 1;
    throw error;
  }
}
var invariant_1 = invariant$w;
var invariant$v = invariant_1;
function getRangesForDraftEntity$1(block, key) {
  var ranges = [];
  block.findEntityRanges(function(c) {
    return c.getEntity() === key;
  }, function(start, end) {
    ranges.push({
      start,
      end
    });
  });
  !!!ranges.length ? invariant$v(false) : void 0;
  return ranges;
}
var getRangesForDraftEntity_1 = getRangesForDraftEntity$1;
var DraftEntitySegments = DraftEntitySegments_1;
var getRangesForDraftEntity = getRangesForDraftEntity_1;
var invariant$u = invariant_1;
function getCharacterRemovalRange$1(entityMap, startBlock, endBlock, selectionState, direction) {
  var start = selectionState.getStartOffset();
  var end = selectionState.getEndOffset();
  var startEntityKey = startBlock.getEntityAt(start);
  var endEntityKey = endBlock.getEntityAt(end - 1);
  if (!startEntityKey && !endEntityKey) {
    return selectionState;
  }
  var newSelectionState = selectionState;
  if (startEntityKey && startEntityKey === endEntityKey) {
    newSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, true, true);
  } else if (startEntityKey && endEntityKey) {
    var startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);
    var endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);
    newSelectionState = newSelectionState.merge({
      anchorOffset: startSelectionState.getAnchorOffset(),
      focusOffset: endSelectionState.getFocusOffset(),
      isBackward: false
    });
  } else if (startEntityKey) {
    var _startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);
    newSelectionState = newSelectionState.merge({
      anchorOffset: _startSelectionState.getStartOffset(),
      isBackward: false
    });
  } else if (endEntityKey) {
    var _endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);
    newSelectionState = newSelectionState.merge({
      focusOffset: _endSelectionState.getEndOffset(),
      isBackward: false
    });
  }
  return newSelectionState;
}
function getEntityRemovalRange(entityMap, block, selectionState, direction, entityKey, isEntireSelectionWithinEntity, isEntityAtStart) {
  var start = selectionState.getStartOffset();
  var end = selectionState.getEndOffset();
  var entity = entityMap.__get(entityKey);
  var mutability = entity.getMutability();
  var sideToConsider = isEntityAtStart ? start : end;
  if (mutability === "MUTABLE") {
    return selectionState;
  }
  var entityRanges = getRangesForDraftEntity(block, entityKey).filter(function(range) {
    return sideToConsider <= range.end && sideToConsider >= range.start;
  });
  !(entityRanges.length == 1) ? invariant$u(false) : void 0;
  var entityRange = entityRanges[0];
  if (mutability === "IMMUTABLE") {
    return selectionState.merge({
      anchorOffset: entityRange.start,
      focusOffset: entityRange.end,
      isBackward: false
    });
  }
  if (!isEntireSelectionWithinEntity) {
    if (isEntityAtStart) {
      end = entityRange.end;
    } else {
      start = entityRange.start;
    }
  }
  var removalRange = DraftEntitySegments.getRemovalRange(start, end, block.getText().slice(entityRange.start, entityRange.end), entityRange.start, direction);
  return selectionState.merge({
    anchorOffset: removalRange.start,
    focusOffset: removalRange.end,
    isBackward: false
  });
}
var getCharacterRemovalRange_1 = getCharacterRemovalRange$1;
var seenKeys = {};
var MULTIPLIER = Math.pow(2, 24);
function generateRandomKey$a() {
  var key;
  while (key === void 0 || seenKeys.hasOwnProperty(key) || !isNaN(+key)) {
    key = Math.floor(Math.random() * MULTIPLIER).toString(32);
  }
  seenKeys[key] = true;
  return key;
}
var generateRandomKey_1 = generateRandomKey$a;
var ContentBlockNode$b = ContentBlockNode_1;
var generateRandomKey$9 = generateRandomKey_1;
var Immutable$m = immutable$1.exports;
var OrderedMap$6 = Immutable$m.OrderedMap;
var randomizeContentBlockNodeKeys = function randomizeContentBlockNodeKeys2(blockMap) {
  var newKeysRef = {};
  var lastRootBlock;
  return OrderedMap$6(blockMap.withMutations(function(blockMapState) {
    blockMapState.forEach(function(block, index) {
      var oldKey = block.getKey();
      var nextKey = block.getNextSiblingKey();
      var prevKey = block.getPrevSiblingKey();
      var childrenKeys = block.getChildKeys();
      var parentKey = block.getParentKey();
      var key = generateRandomKey$9();
      newKeysRef[oldKey] = key;
      if (nextKey) {
        var nextBlock = blockMapState.get(nextKey);
        if (nextBlock) {
          blockMapState.setIn([nextKey, "prevSibling"], key);
        } else {
          blockMapState.setIn([oldKey, "nextSibling"], null);
        }
      }
      if (prevKey) {
        var prevBlock = blockMapState.get(prevKey);
        if (prevBlock) {
          blockMapState.setIn([prevKey, "nextSibling"], key);
        } else {
          blockMapState.setIn([oldKey, "prevSibling"], null);
        }
      }
      if (parentKey && blockMapState.get(parentKey)) {
        var parentBlock = blockMapState.get(parentKey);
        var parentChildrenList = parentBlock.getChildKeys();
        blockMapState.setIn([parentKey, "children"], parentChildrenList.set(parentChildrenList.indexOf(block.getKey()), key));
      } else {
        blockMapState.setIn([oldKey, "parent"], null);
        if (lastRootBlock) {
          blockMapState.setIn([lastRootBlock.getKey(), "nextSibling"], key);
          blockMapState.setIn([oldKey, "prevSibling"], newKeysRef[lastRootBlock.getKey()]);
        }
        lastRootBlock = blockMapState.get(oldKey);
      }
      childrenKeys.forEach(function(childKey) {
        var childBlock = blockMapState.get(childKey);
        if (childBlock) {
          blockMapState.setIn([childKey, "parent"], key);
        } else {
          blockMapState.setIn([oldKey, "children"], block.getChildKeys().filter(function(child) {
            return child !== childKey;
          }));
        }
      });
    });
  }).toArray().map(function(block) {
    return [newKeysRef[block.getKey()], block.set("key", newKeysRef[block.getKey()])];
  }));
};
var randomizeContentBlockKeys = function randomizeContentBlockKeys2(blockMap) {
  return OrderedMap$6(blockMap.toArray().map(function(block) {
    var key = generateRandomKey$9();
    return [key, block.set("key", key)];
  }));
};
var randomizeBlockMapKeys$2 = function randomizeBlockMapKeys(blockMap) {
  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode$b;
  if (!isTreeBasedBlockMap) {
    return randomizeContentBlockKeys(blockMap);
  }
  return randomizeContentBlockNodeKeys(blockMap);
};
var randomizeBlockMapKeys_1 = randomizeBlockMapKeys$2;
var CharacterMetadata$7 = CharacterMetadata_1;
var findRangesImmutable$2 = findRangesImmutable_1;
var invariant$t = invariant_1;
function removeEntitiesAtEdges$2(contentState, selectionState) {
  var blockMap = contentState.getBlockMap();
  var entityMap = contentState.getEntityMap();
  var updatedBlocks = {};
  var startKey = selectionState.getStartKey();
  var startOffset = selectionState.getStartOffset();
  var startBlock = blockMap.get(startKey);
  var updatedStart = removeForBlock(entityMap, startBlock, startOffset);
  if (updatedStart !== startBlock) {
    updatedBlocks[startKey] = updatedStart;
  }
  var endKey = selectionState.getEndKey();
  var endOffset = selectionState.getEndOffset();
  var endBlock = blockMap.get(endKey);
  if (startKey === endKey) {
    endBlock = updatedStart;
  }
  var updatedEnd = removeForBlock(entityMap, endBlock, endOffset);
  if (updatedEnd !== endBlock) {
    updatedBlocks[endKey] = updatedEnd;
  }
  if (!Object.keys(updatedBlocks).length) {
    return contentState.set("selectionAfter", selectionState);
  }
  return contentState.merge({
    blockMap: blockMap.merge(updatedBlocks),
    selectionAfter: selectionState
  });
}
function getRemovalRange2(characters, entityKey, offset) {
  var removalRange;
  findRangesImmutable$2(characters, function(a, b) {
    return a.getEntity() === b.getEntity();
  }, function(element) {
    return element.getEntity() === entityKey;
  }, function(start, end) {
    if (start <= offset && end >= offset) {
      removalRange = {
        start,
        end
      };
    }
  });
  !(typeof removalRange === "object") ? invariant$t(false) : void 0;
  return removalRange;
}
function removeForBlock(entityMap, block, offset) {
  var chars = block.getCharacterList();
  var charBefore = offset > 0 ? chars.get(offset - 1) : void 0;
  var charAfter = offset < chars.count() ? chars.get(offset) : void 0;
  var entityBeforeCursor = charBefore ? charBefore.getEntity() : void 0;
  var entityAfterCursor = charAfter ? charAfter.getEntity() : void 0;
  if (entityAfterCursor && entityAfterCursor === entityBeforeCursor) {
    var entity = entityMap.__get(entityAfterCursor);
    if (entity.getMutability() !== "MUTABLE") {
      var _getRemovalRange = getRemovalRange2(chars, entityAfterCursor, offset), start = _getRemovalRange.start, end = _getRemovalRange.end;
      var current;
      while (start < end) {
        current = chars.get(start);
        chars = chars.set(start, CharacterMetadata$7.applyEntity(current, null));
        start++;
      }
      return block.set("characterList", chars);
    }
  }
  return block;
}
var removeEntitiesAtEdges_1 = removeEntitiesAtEdges$2;
var randomizeBlockMapKeys$1 = randomizeBlockMapKeys_1;
var removeEntitiesAtEdges$1 = removeEntitiesAtEdges_1;
var getContentStateFragment$4 = function getContentStateFragment(contentState, selectionState) {
  var startKey = selectionState.getStartKey();
  var startOffset = selectionState.getStartOffset();
  var endKey = selectionState.getEndKey();
  var endOffset = selectionState.getEndOffset();
  var contentWithoutEdgeEntities = removeEntitiesAtEdges$1(contentState, selectionState);
  var blockMap = contentWithoutEdgeEntities.getBlockMap();
  var blockKeys = blockMap.keySeq();
  var startIndex = blockKeys.indexOf(startKey);
  var endIndex = blockKeys.indexOf(endKey) + 1;
  return randomizeBlockMapKeys$1(blockMap.slice(startIndex, endIndex).map(function(block, blockKey) {
    var text = block.getText();
    var chars = block.getCharacterList();
    if (startKey === endKey) {
      return block.merge({
        text: text.slice(startOffset, endOffset),
        characterList: chars.slice(startOffset, endOffset)
      });
    }
    if (blockKey === startKey) {
      return block.merge({
        text: text.slice(startOffset),
        characterList: chars.slice(startOffset)
      });
    }
    if (blockKey === endKey) {
      return block.merge({
        text: text.slice(0, endOffset),
        characterList: chars.slice(0, endOffset)
      });
    }
    return block;
  }));
};
var getContentStateFragment_1 = getContentStateFragment$4;
function insertIntoList$2(targetListArg, toInsert, offset) {
  var targetList = targetListArg;
  if (offset === targetList.count()) {
    toInsert.forEach(function(c) {
      targetList = targetList.push(c);
    });
  } else if (offset === 0) {
    toInsert.reverse().forEach(function(c) {
      targetList = targetList.unshift(c);
    });
  } else {
    var head = targetList.slice(0, offset);
    var tail = targetList.slice(offset);
    targetList = head.concat(toInsert, tail).toList();
  }
  return targetList;
}
var insertIntoList_1 = insertIntoList$2;
var BlockMapBuilder$4 = BlockMapBuilder_1;
var ContentBlockNode$a = ContentBlockNode_1;
var Immutable$l = immutable$1.exports;
var insertIntoList$1 = insertIntoList_1;
var invariant$s = invariant_1;
var randomizeBlockMapKeys2 = randomizeBlockMapKeys_1;
var List$d = Immutable$l.List;
var updateExistingBlock = function updateExistingBlock2(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {
  var mergeBlockData2 = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : "REPLACE_WITH_NEW_DATA";
  var targetBlock = blockMap.get(targetKey);
  var text = targetBlock.getText();
  var chars = targetBlock.getCharacterList();
  var finalKey = targetKey;
  var finalOffset = targetOffset + fragmentBlock.getText().length;
  var data = null;
  switch (mergeBlockData2) {
    case "MERGE_OLD_DATA_TO_NEW_DATA":
      data = fragmentBlock.getData().merge(targetBlock.getData());
      break;
    case "REPLACE_WITH_NEW_DATA":
      data = fragmentBlock.getData();
      break;
  }
  var type = targetBlock.getType();
  if (text && type === "unstyled") {
    type = fragmentBlock.getType();
  }
  var newBlock = targetBlock.merge({
    text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),
    characterList: insertIntoList$1(chars, fragmentBlock.getCharacterList(), targetOffset),
    type,
    data
  });
  return contentState.merge({
    blockMap: blockMap.set(targetKey, newBlock),
    selectionBefore: selectionState,
    selectionAfter: selectionState.merge({
      anchorKey: finalKey,
      anchorOffset: finalOffset,
      focusKey: finalKey,
      focusOffset: finalOffset,
      isBackward: false
    })
  });
};
var updateHead = function updateHead2(block, targetOffset, fragment) {
  var text = block.getText();
  var chars = block.getCharacterList();
  var headText = text.slice(0, targetOffset);
  var headCharacters = chars.slice(0, targetOffset);
  var appendToHead = fragment.first();
  return block.merge({
    text: headText + appendToHead.getText(),
    characterList: headCharacters.concat(appendToHead.getCharacterList()),
    type: headText ? block.getType() : appendToHead.getType(),
    data: appendToHead.getData()
  });
};
var updateTail = function updateTail2(block, targetOffset, fragment) {
  var text = block.getText();
  var chars = block.getCharacterList();
  var blockSize = text.length;
  var tailText = text.slice(targetOffset, blockSize);
  var tailCharacters = chars.slice(targetOffset, blockSize);
  var prependToTail = fragment.last();
  return prependToTail.merge({
    text: prependToTail.getText() + tailText,
    characterList: prependToTail.getCharacterList().concat(tailCharacters),
    data: prependToTail.getData()
  });
};
var getRootBlocks = function getRootBlocks2(block, blockMap) {
  var headKey = block.getKey();
  var rootBlock = block;
  var rootBlocks = [];
  if (blockMap.get(headKey)) {
    rootBlocks.push(headKey);
  }
  while (rootBlock && rootBlock.getNextSiblingKey()) {
    var lastSiblingKey = rootBlock.getNextSiblingKey();
    if (!lastSiblingKey) {
      break;
    }
    rootBlocks.push(lastSiblingKey);
    rootBlock = blockMap.get(lastSiblingKey);
  }
  return rootBlocks;
};
var updateBlockMapLinks$3 = function updateBlockMapLinks(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {
  return blockMap.withMutations(function(blockMapState) {
    var targetKey = targetBlock.getKey();
    var headKey = fragmentHeadBlock.getKey();
    var targetNextKey = targetBlock.getNextSiblingKey();
    var targetParentKey = targetBlock.getParentKey();
    var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);
    var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];
    if (blockMapState.get(headKey)) {
      blockMapState.setIn([targetKey, "nextSibling"], headKey);
      blockMapState.setIn([headKey, "prevSibling"], targetKey);
    } else {
      blockMapState.setIn([targetKey, "nextSibling"], fragmentHeadBlock.getNextSiblingKey());
      blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), "prevSibling"], targetKey);
    }
    blockMapState.setIn([lastRootFragmentBlockKey, "nextSibling"], targetNextKey);
    if (targetNextKey) {
      blockMapState.setIn([targetNextKey, "prevSibling"], lastRootFragmentBlockKey);
    }
    fragmentRootBlocks.forEach(function(blockKey) {
      return blockMapState.setIn([blockKey, "parent"], targetParentKey);
    });
    if (targetParentKey) {
      var targetParent = blockMap.get(targetParentKey);
      var originalTargetParentChildKeys = targetParent.getChildKeys();
      var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);
      var insertionIndex = targetBlockIndex + 1;
      var newChildrenKeysArray = originalTargetParentChildKeys.toArray();
      newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));
      blockMapState.setIn([targetParentKey, "children"], List$d(newChildrenKeysArray));
    }
  });
};
var insertFragment$1 = function insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {
  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode$a;
  var newBlockArr = [];
  var fragmentSize = fragment.size;
  var target = blockMap.get(targetKey);
  var head = fragment.first();
  var tail = fragment.last();
  var finalOffset = tail.getLength();
  var finalKey = tail.getKey();
  var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());
  blockMap.forEach(function(block, blockKey) {
    if (blockKey !== targetKey) {
      newBlockArr.push(block);
      return;
    }
    if (shouldNotUpdateFromFragmentBlock) {
      newBlockArr.push(block);
    } else {
      newBlockArr.push(updateHead(block, targetOffset, fragment));
    }
    fragment.slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function(fragmentBlock) {
      return newBlockArr.push(fragmentBlock);
    });
    newBlockArr.push(updateTail(block, targetOffset, fragment));
  });
  var updatedBlockMap = BlockMapBuilder$4.createFromArray(newBlockArr);
  if (isTreeBasedBlockMap) {
    updatedBlockMap = updateBlockMapLinks$3(updatedBlockMap, blockMap, target, head);
  }
  return contentState.merge({
    blockMap: updatedBlockMap,
    selectionBefore: selectionState,
    selectionAfter: selectionState.merge({
      anchorKey: finalKey,
      anchorOffset: finalOffset,
      focusKey: finalKey,
      focusOffset: finalOffset,
      isBackward: false
    })
  });
};
var insertFragmentIntoContentState$1 = function insertFragmentIntoContentState(contentState, selectionState, fragmentBlockMap) {
  var mergeBlockData2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "REPLACE_WITH_NEW_DATA";
  !selectionState.isCollapsed() ? invariant$s(false) : void 0;
  var blockMap = contentState.getBlockMap();
  var fragment = randomizeBlockMapKeys2(fragmentBlockMap);
  var targetKey = selectionState.getStartKey();
  var targetOffset = selectionState.getStartOffset();
  var targetBlock = blockMap.get(targetKey);
  if (targetBlock instanceof ContentBlockNode$a) {
    !targetBlock.getChildKeys().isEmpty() ? invariant$s(false) : void 0;
  }
  if (fragment.size === 1) {
    return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset, mergeBlockData2);
  }
  return insertFragment$1(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);
};
var insertFragmentIntoContentState_1 = insertFragmentIntoContentState$1;
var Immutable$k = immutable$1.exports;
var insertIntoList = insertIntoList_1;
var invariant$r = invariant_1;
var Repeat$4 = Immutable$k.Repeat;
function insertTextIntoContentState$1(contentState, selectionState, text, characterMetadata) {
  !selectionState.isCollapsed() ? invariant$r(false) : void 0;
  var len = null;
  if (text != null) {
    len = text.length;
  }
  if (len == null || len === 0) {
    return contentState;
  }
  var blockMap = contentState.getBlockMap();
  var key = selectionState.getStartKey();
  var offset = selectionState.getStartOffset();
  var block = blockMap.get(key);
  var blockText = block.getText();
  var newBlock = block.merge({
    text: blockText.slice(0, offset) + text + blockText.slice(offset, block.getLength()),
    characterList: insertIntoList(block.getCharacterList(), Repeat$4(characterMetadata, len).toList(), offset)
  });
  var newOffset = offset + len;
  return contentState.merge({
    blockMap: blockMap.set(key, newBlock),
    selectionAfter: selectionState.merge({
      anchorOffset: newOffset,
      focusOffset: newOffset
    })
  });
}
var insertTextIntoContentState_1 = insertTextIntoContentState$1;
var Immutable$j = immutable$1.exports;
var Map$d = Immutable$j.Map;
function modifyBlockForContentState$2(contentState, selectionState, operation) {
  var startKey = selectionState.getStartKey();
  var endKey = selectionState.getEndKey();
  var blockMap = contentState.getBlockMap();
  var newBlocks = blockMap.toSeq().skipUntil(function(_, k) {
    return k === startKey;
  }).takeUntil(function(_, k) {
    return k === endKey;
  }).concat(Map$d([[endKey, blockMap.get(endKey)]])).map(operation);
  return contentState.merge({
    blockMap: blockMap.merge(newBlocks),
    selectionBefore: selectionState,
    selectionAfter: selectionState
  });
}
var modifyBlockForContentState_1 = modifyBlockForContentState$2;
var ContentBlockNode$9 = ContentBlockNode_1;
var getNextDelimiterBlockKey$2 = function getNextDelimiterBlockKey(block, blockMap) {
  var isExperimentalTreeBlock = block instanceof ContentBlockNode$9;
  if (!isExperimentalTreeBlock) {
    return null;
  }
  var nextSiblingKey = block.getNextSiblingKey();
  if (nextSiblingKey) {
    return nextSiblingKey;
  }
  var parent2 = block.getParentKey();
  if (!parent2) {
    return null;
  }
  var nextNonDescendantBlock = blockMap.get(parent2);
  while (nextNonDescendantBlock && !nextNonDescendantBlock.getNextSiblingKey()) {
    var parentKey = nextNonDescendantBlock.getParentKey();
    nextNonDescendantBlock = parentKey ? blockMap.get(parentKey) : null;
  }
  if (!nextNonDescendantBlock) {
    return null;
  }
  return nextNonDescendantBlock.getNextSiblingKey();
};
var getNextDelimiterBlockKey_1 = getNextDelimiterBlockKey$2;
var ContentBlockNode$8 = ContentBlockNode_1;
var getNextDelimiterBlockKey$1 = getNextDelimiterBlockKey_1;
var Immutable$i = immutable$1.exports;
Immutable$i.List;
var Map$c = Immutable$i.Map;
var transformBlock$2 = function transformBlock(key, blockMap, func2) {
  if (!key) {
    return;
  }
  var block = blockMap.get(key);
  if (!block) {
    return;
  }
  blockMap.set(key, func2(block));
};
var getAncestorsKeys = function getAncestorsKeys2(blockKey, blockMap) {
  var parents = [];
  if (!blockKey) {
    return parents;
  }
  var blockNode = blockMap.get(blockKey);
  while (blockNode && blockNode.getParentKey()) {
    var parentKey = blockNode.getParentKey();
    if (parentKey) {
      parents.push(parentKey);
    }
    blockNode = parentKey ? blockMap.get(parentKey) : null;
  }
  return parents;
};
var getNextDelimitersBlockKeys = function getNextDelimitersBlockKeys2(block, blockMap) {
  var nextDelimiters = [];
  if (!block) {
    return nextDelimiters;
  }
  var nextDelimiter = getNextDelimiterBlockKey$1(block, blockMap);
  while (nextDelimiter && blockMap.get(nextDelimiter)) {
    var _block = blockMap.get(nextDelimiter);
    nextDelimiters.push(nextDelimiter);
    nextDelimiter = _block.getParentKey() ? getNextDelimiterBlockKey$1(_block, blockMap) : null;
  }
  return nextDelimiters;
};
var getNextValidSibling = function getNextValidSibling2(block, blockMap, originalBlockMap) {
  if (!block) {
    return null;
  }
  var nextValidSiblingKey = originalBlockMap.get(block.getKey()).getNextSiblingKey();
  while (nextValidSiblingKey && !blockMap.get(nextValidSiblingKey)) {
    nextValidSiblingKey = originalBlockMap.get(nextValidSiblingKey).getNextSiblingKey() || null;
  }
  return nextValidSiblingKey;
};
var getPrevValidSibling = function getPrevValidSibling2(block, blockMap, originalBlockMap) {
  if (!block) {
    return null;
  }
  var prevValidSiblingKey = originalBlockMap.get(block.getKey()).getPrevSiblingKey();
  while (prevValidSiblingKey && !blockMap.get(prevValidSiblingKey)) {
    prevValidSiblingKey = originalBlockMap.get(prevValidSiblingKey).getPrevSiblingKey() || null;
  }
  return prevValidSiblingKey;
};
var updateBlockMapLinks$2 = function updateBlockMapLinks2(blockMap, startBlock, endBlock, originalBlockMap) {
  return blockMap.withMutations(function(blocks) {
    transformBlock$2(startBlock.getKey(), blocks, function(block) {
      return block.merge({
        nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
        prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
      });
    });
    transformBlock$2(endBlock.getKey(), blocks, function(block) {
      return block.merge({
        nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
        prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
      });
    });
    getAncestorsKeys(startBlock.getKey(), originalBlockMap).forEach(function(parentKey) {
      return transformBlock$2(parentKey, blocks, function(block) {
        return block.merge({
          children: block.getChildKeys().filter(function(key) {
            return blocks.get(key);
          }),
          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
        });
      });
    });
    transformBlock$2(startBlock.getNextSiblingKey(), blocks, function(block) {
      return block.merge({
        prevSibling: startBlock.getPrevSiblingKey()
      });
    });
    transformBlock$2(startBlock.getPrevSiblingKey(), blocks, function(block) {
      return block.merge({
        nextSibling: getNextValidSibling(block, blocks, originalBlockMap)
      });
    });
    transformBlock$2(endBlock.getNextSiblingKey(), blocks, function(block) {
      return block.merge({
        prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
      });
    });
    transformBlock$2(endBlock.getPrevSiblingKey(), blocks, function(block) {
      return block.merge({
        nextSibling: endBlock.getNextSiblingKey()
      });
    });
    getAncestorsKeys(endBlock.getKey(), originalBlockMap).forEach(function(parentKey) {
      transformBlock$2(parentKey, blocks, function(block) {
        return block.merge({
          children: block.getChildKeys().filter(function(key) {
            return blocks.get(key);
          }),
          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
        });
      });
    });
    getNextDelimitersBlockKeys(endBlock, originalBlockMap).forEach(function(delimiterKey) {
      return transformBlock$2(delimiterKey, blocks, function(block) {
        return block.merge({
          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),
          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)
        });
      });
    });
    if (blockMap.get(startBlock.getKey()) == null && blockMap.get(endBlock.getKey()) != null && endBlock.getParentKey() === startBlock.getKey() && endBlock.getPrevSiblingKey() == null) {
      var prevSiblingKey = startBlock.getPrevSiblingKey();
      transformBlock$2(endBlock.getKey(), blocks, function(block) {
        return block.merge({
          prevSibling: prevSiblingKey
        });
      });
      transformBlock$2(prevSiblingKey, blocks, function(block) {
        return block.merge({
          nextSibling: endBlock.getKey()
        });
      });
      var prevSibling = prevSiblingKey ? blockMap.get(prevSiblingKey) : null;
      var newParentKey = prevSibling ? prevSibling.getParentKey() : null;
      startBlock.getChildKeys().forEach(function(childKey) {
        transformBlock$2(childKey, blocks, function(block) {
          return block.merge({
            parent: newParentKey
          });
        });
      });
      if (newParentKey != null) {
        var newParent = blockMap.get(newParentKey);
        transformBlock$2(newParentKey, blocks, function(block) {
          return block.merge({
            children: newParent.getChildKeys().concat(startBlock.getChildKeys())
          });
        });
      }
      transformBlock$2(startBlock.getChildKeys().find(function(key) {
        var block = blockMap.get(key);
        return block.getNextSiblingKey() === null;
      }), blocks, function(block) {
        return block.merge({
          nextSibling: startBlock.getNextSiblingKey()
        });
      });
    }
  });
};
var removeRangeFromContentState$1 = function removeRangeFromContentState(contentState, selectionState) {
  if (selectionState.isCollapsed()) {
    return contentState;
  }
  var blockMap = contentState.getBlockMap();
  var startKey = selectionState.getStartKey();
  var startOffset = selectionState.getStartOffset();
  var endKey = selectionState.getEndKey();
  var endOffset = selectionState.getEndOffset();
  var startBlock = blockMap.get(startKey);
  var endBlock = blockMap.get(endKey);
  var isExperimentalTreeBlock = startBlock instanceof ContentBlockNode$8;
  var parentAncestors = [];
  if (isExperimentalTreeBlock) {
    var endBlockchildrenKeys = endBlock.getChildKeys();
    var endBlockAncestors = getAncestorsKeys(endKey, blockMap);
    if (endBlock.getNextSiblingKey()) {
      parentAncestors = parentAncestors.concat(endBlockAncestors);
    }
    if (!endBlockchildrenKeys.isEmpty()) {
      parentAncestors = parentAncestors.concat(endBlockAncestors.concat([endKey]));
    }
    parentAncestors = parentAncestors.concat(getAncestorsKeys(getNextDelimiterBlockKey$1(endBlock, blockMap), blockMap));
  }
  var characterList;
  if (startBlock === endBlock) {
    characterList = removeFromList(startBlock.getCharacterList(), startOffset, endOffset);
  } else {
    characterList = startBlock.getCharacterList().slice(0, startOffset).concat(endBlock.getCharacterList().slice(endOffset));
  }
  var modifiedStart = startBlock.merge({
    text: startBlock.getText().slice(0, startOffset) + endBlock.getText().slice(endOffset),
    characterList
  });
  var shouldDeleteParent = isExperimentalTreeBlock && startOffset === 0 && endOffset === 0 && endBlock.getParentKey() === startKey && endBlock.getPrevSiblingKey() == null;
  var newBlocks = shouldDeleteParent ? Map$c([[startKey, null]]) : blockMap.toSeq().skipUntil(function(_, k) {
    return k === startKey;
  }).takeUntil(function(_, k) {
    return k === endKey;
  }).filter(function(_, k) {
    return parentAncestors.indexOf(k) === -1;
  }).concat(Map$c([[endKey, null]])).map(function(_, k) {
    return k === startKey ? modifiedStart : null;
  });
  var updatedBlockMap = blockMap.merge(newBlocks).filter(function(block) {
    return !!block;
  });
  if (isExperimentalTreeBlock && startBlock !== endBlock) {
    updatedBlockMap = updateBlockMapLinks$2(updatedBlockMap, startBlock, endBlock, blockMap);
  }
  return contentState.merge({
    blockMap: updatedBlockMap,
    selectionBefore: selectionState,
    selectionAfter: selectionState.merge({
      anchorKey: startKey,
      anchorOffset: startOffset,
      focusKey: startKey,
      focusOffset: startOffset,
      isBackward: false
    })
  });
};
var removeFromList = function removeFromList2(targetList, startOffset, endOffset) {
  if (startOffset === 0) {
    while (startOffset < endOffset) {
      targetList = targetList.shift();
      startOffset++;
    }
  } else if (endOffset === targetList.count()) {
    while (endOffset > startOffset) {
      targetList = targetList.pop();
      endOffset--;
    }
  } else {
    var head = targetList.slice(0, startOffset);
    var tail = targetList.slice(endOffset);
    targetList = head.concat(tail).toList();
  }
  return targetList;
};
var removeRangeFromContentState_1 = removeRangeFromContentState$1;
var ContentBlockNode$7 = ContentBlockNode_1;
var generateRandomKey$8 = generateRandomKey_1;
var Immutable$h = immutable$1.exports;
var invariant$q = invariant_1;
var modifyBlockForContentState$1 = modifyBlockForContentState_1;
var List$c = Immutable$h.List, Map$b = Immutable$h.Map;
var transformBlock$1 = function transformBlock2(key, blockMap, func2) {
  if (!key) {
    return;
  }
  var block = blockMap.get(key);
  if (!block) {
    return;
  }
  blockMap.set(key, func2(block));
};
var updateBlockMapLinks$1 = function updateBlockMapLinks3(blockMap, originalBlock, belowBlock) {
  return blockMap.withMutations(function(blocks) {
    var originalBlockKey = originalBlock.getKey();
    var belowBlockKey = belowBlock.getKey();
    transformBlock$1(originalBlock.getParentKey(), blocks, function(block) {
      var parentChildrenList = block.getChildKeys();
      var insertionIndex = parentChildrenList.indexOf(originalBlockKey) + 1;
      var newChildrenArray = parentChildrenList.toArray();
      newChildrenArray.splice(insertionIndex, 0, belowBlockKey);
      return block.merge({
        children: List$c(newChildrenArray)
      });
    });
    transformBlock$1(originalBlock.getNextSiblingKey(), blocks, function(block) {
      return block.merge({
        prevSibling: belowBlockKey
      });
    });
    transformBlock$1(originalBlockKey, blocks, function(block) {
      return block.merge({
        nextSibling: belowBlockKey
      });
    });
    transformBlock$1(belowBlockKey, blocks, function(block) {
      return block.merge({
        prevSibling: originalBlockKey
      });
    });
  });
};
var splitBlockInContentState$1 = function splitBlockInContentState(contentState, selectionState) {
  !selectionState.isCollapsed() ? invariant$q(false) : void 0;
  var key = selectionState.getAnchorKey();
  var blockMap = contentState.getBlockMap();
  var blockToSplit = blockMap.get(key);
  var text = blockToSplit.getText();
  if (!text) {
    var blockType = blockToSplit.getType();
    if (blockType === "unordered-list-item" || blockType === "ordered-list-item") {
      return modifyBlockForContentState$1(contentState, selectionState, function(block) {
        return block.merge({
          type: "unstyled",
          depth: 0
        });
      });
    }
  }
  var offset = selectionState.getAnchorOffset();
  var chars = blockToSplit.getCharacterList();
  var keyBelow = generateRandomKey$8();
  var isExperimentalTreeBlock = blockToSplit instanceof ContentBlockNode$7;
  var blockAbove = blockToSplit.merge({
    text: text.slice(0, offset),
    characterList: chars.slice(0, offset)
  });
  var blockBelow = blockAbove.merge({
    key: keyBelow,
    text: text.slice(offset),
    characterList: chars.slice(offset),
    data: Map$b()
  });
  var blocksBefore = blockMap.toSeq().takeUntil(function(v) {
    return v === blockToSplit;
  });
  var blocksAfter = blockMap.toSeq().skipUntil(function(v) {
    return v === blockToSplit;
  }).rest();
  var newBlocks = blocksBefore.concat([[key, blockAbove], [keyBelow, blockBelow]], blocksAfter).toOrderedMap();
  if (isExperimentalTreeBlock) {
    !blockToSplit.getChildKeys().isEmpty() ? invariant$q(false) : void 0;
    newBlocks = updateBlockMapLinks$1(newBlocks, blockAbove, blockBelow);
  }
  return contentState.merge({
    blockMap: newBlocks,
    selectionBefore: selectionState,
    selectionAfter: selectionState.merge({
      anchorKey: keyBelow,
      anchorOffset: 0,
      focusKey: keyBelow,
      focusOffset: 0,
      isBackward: false
    })
  });
};
var splitBlockInContentState_1 = splitBlockInContentState$1;
var CharacterMetadata$6 = CharacterMetadata_1;
var ContentStateInlineStyle = ContentStateInlineStyle_1;
var applyEntityToContentState = applyEntityToContentState_1;
var getCharacterRemovalRange = getCharacterRemovalRange_1;
var getContentStateFragment$3 = getContentStateFragment_1;
var Immutable$g = immutable$1.exports;
var insertFragmentIntoContentState2 = insertFragmentIntoContentState_1;
var insertTextIntoContentState = insertTextIntoContentState_1;
var invariant$p = invariant_1;
var modifyBlockForContentState = modifyBlockForContentState_1;
var removeEntitiesAtEdges = removeEntitiesAtEdges_1;
var removeRangeFromContentState2 = removeRangeFromContentState_1;
var splitBlockInContentState2 = splitBlockInContentState_1;
var OrderedSet$4 = Immutable$g.OrderedSet;
var DraftModifier$e = {
  replaceText: function replaceText(contentState, rangeToReplace, text, inlineStyle, entityKey) {
    var withoutEntities = removeEntitiesAtEdges(contentState, rangeToReplace);
    var withoutText = removeRangeFromContentState2(withoutEntities, rangeToReplace);
    var character = CharacterMetadata$6.create({
      style: inlineStyle || OrderedSet$4(),
      entity: entityKey || null
    });
    return insertTextIntoContentState(withoutText, withoutText.getSelectionAfter(), text, character);
  },
  insertText: function insertText(contentState, targetRange, text, inlineStyle, entityKey) {
    !targetRange.isCollapsed() ? invariant$p(false) : void 0;
    return DraftModifier$e.replaceText(contentState, targetRange, text, inlineStyle, entityKey);
  },
  moveText: function moveText(contentState, removalRange, targetRange) {
    var movedFragment = getContentStateFragment$3(contentState, removalRange);
    var afterRemoval = DraftModifier$e.removeRange(contentState, removalRange, "backward");
    return DraftModifier$e.replaceWithFragment(afterRemoval, targetRange, movedFragment);
  },
  replaceWithFragment: function replaceWithFragment(contentState, targetRange, fragment) {
    var mergeBlockData2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "REPLACE_WITH_NEW_DATA";
    var withoutEntities = removeEntitiesAtEdges(contentState, targetRange);
    var withoutText = removeRangeFromContentState2(withoutEntities, targetRange);
    return insertFragmentIntoContentState2(withoutText, withoutText.getSelectionAfter(), fragment, mergeBlockData2);
  },
  removeRange: function removeRange(contentState, rangeToRemove, removalDirection) {
    var startKey, endKey, startBlock, endBlock;
    if (rangeToRemove.getIsBackward()) {
      rangeToRemove = rangeToRemove.merge({
        anchorKey: rangeToRemove.getFocusKey(),
        anchorOffset: rangeToRemove.getFocusOffset(),
        focusKey: rangeToRemove.getAnchorKey(),
        focusOffset: rangeToRemove.getAnchorOffset(),
        isBackward: false
      });
    }
    startKey = rangeToRemove.getAnchorKey();
    endKey = rangeToRemove.getFocusKey();
    startBlock = contentState.getBlockForKey(startKey);
    endBlock = contentState.getBlockForKey(endKey);
    var startOffset = rangeToRemove.getStartOffset();
    var endOffset = rangeToRemove.getEndOffset();
    var startEntityKey = startBlock.getEntityAt(startOffset);
    var endEntityKey = endBlock.getEntityAt(endOffset - 1);
    if (startKey === endKey) {
      if (startEntityKey && startEntityKey === endEntityKey) {
        var adjustedRemovalRange = getCharacterRemovalRange(contentState.getEntityMap(), startBlock, endBlock, rangeToRemove, removalDirection);
        return removeRangeFromContentState2(contentState, adjustedRemovalRange);
      }
    }
    var withoutEntities = removeEntitiesAtEdges(contentState, rangeToRemove);
    return removeRangeFromContentState2(withoutEntities, rangeToRemove);
  },
  splitBlock: function splitBlock(contentState, selectionState) {
    var withoutEntities = removeEntitiesAtEdges(contentState, selectionState);
    var withoutText = removeRangeFromContentState2(withoutEntities, selectionState);
    return splitBlockInContentState2(withoutText, withoutText.getSelectionAfter());
  },
  applyInlineStyle: function applyInlineStyle(contentState, selectionState, inlineStyle) {
    return ContentStateInlineStyle.add(contentState, selectionState, inlineStyle);
  },
  removeInlineStyle: function removeInlineStyle(contentState, selectionState, inlineStyle) {
    return ContentStateInlineStyle.remove(contentState, selectionState, inlineStyle);
  },
  setBlockType: function setBlockType(contentState, selectionState, blockType) {
    return modifyBlockForContentState(contentState, selectionState, function(block) {
      return block.merge({
        type: blockType,
        depth: 0
      });
    });
  },
  setBlockData: function setBlockData(contentState, selectionState, blockData) {
    return modifyBlockForContentState(contentState, selectionState, function(block) {
      return block.merge({
        data: blockData
      });
    });
  },
  mergeBlockData: function mergeBlockData(contentState, selectionState, blockData) {
    return modifyBlockForContentState(contentState, selectionState, function(block) {
      return block.merge({
        data: block.getData().merge(blockData)
      });
    });
  },
  applyEntity: function applyEntity(contentState, selectionState, entityKey) {
    var withoutEntities = removeEntitiesAtEdges(contentState, selectionState);
    return applyEntityToContentState(withoutEntities, selectionState, entityKey);
  }
};
var DraftModifier_1 = DraftModifier$e;
function getOwnObjectValues$2(obj) {
  return Object.keys(obj).map(function(key) {
    return obj[key];
  });
}
var getOwnObjectValues_1 = getOwnObjectValues$2;
function _objectSpread$e(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty$m(target, key, source[key]);
    });
  }
  return target;
}
function _defineProperty$m(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var findRangesImmutable$1 = findRangesImmutable_1;
var getOwnObjectValues$1 = getOwnObjectValues_1;
var Immutable$f = immutable$1.exports;
var List$b = Immutable$f.List, Repeat$3 = Immutable$f.Repeat, Record$4 = Immutable$f.Record;
var returnTrue$1 = function returnTrue() {
  return true;
};
var defaultLeafRange = {
  start: null,
  end: null
};
var LeafRange = Record$4(defaultLeafRange);
var defaultDecoratorRange = {
  start: null,
  end: null,
  decoratorKey: null,
  leaves: null
};
var DecoratorRange = Record$4(defaultDecoratorRange);
var BlockTree$1 = {
  generate: function generate(contentState, block, decorator2) {
    var textLength = block.getLength();
    if (!textLength) {
      return List$b.of(new DecoratorRange({
        start: 0,
        end: 0,
        decoratorKey: null,
        leaves: List$b.of(new LeafRange({
          start: 0,
          end: 0
        }))
      }));
    }
    var leafSets = [];
    var decorations = decorator2 ? decorator2.getDecorations(block, contentState) : List$b(Repeat$3(null, textLength));
    var chars = block.getCharacterList();
    findRangesImmutable$1(decorations, areEqual$1, returnTrue$1, function(start, end) {
      leafSets.push(new DecoratorRange({
        start,
        end,
        decoratorKey: decorations.get(start),
        leaves: generateLeaves(chars.slice(start, end).toList(), start)
      }));
    });
    return List$b(leafSets);
  },
  fromJS: function fromJS(_ref) {
    var leaves = _ref.leaves, other = _objectWithoutPropertiesLoose(_ref, ["leaves"]);
    return new DecoratorRange(_objectSpread$e({}, other, {
      leaves: leaves != null ? List$b(Array.isArray(leaves) ? leaves : getOwnObjectValues$1(leaves)).map(function(leaf) {
        return LeafRange(leaf);
      }) : null
    }));
  }
};
function generateLeaves(characters, offset) {
  var leaves = [];
  var inlineStyles = characters.map(function(c) {
    return c.getStyle();
  }).toList();
  findRangesImmutable$1(inlineStyles, areEqual$1, returnTrue$1, function(start, end) {
    leaves.push(new LeafRange({
      start: start + offset,
      end: end + offset
    }));
  });
  return List$b(leaves);
}
function areEqual$1(a, b) {
  return a === b;
}
var BlockTree_1 = BlockTree$1;
function _inheritsLoose$c(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var Immutable$e = immutable$1.exports;
var Record$3 = Immutable$e.Record;
var DraftEntityInstanceRecord = Record$3({
  type: "TOKEN",
  mutability: "IMMUTABLE",
  data: Object
});
var DraftEntityInstance$2 = /* @__PURE__ */ function(_DraftEntityInstanceR) {
  _inheritsLoose$c(DraftEntityInstance2, _DraftEntityInstanceR);
  function DraftEntityInstance2() {
    return _DraftEntityInstanceR.apply(this, arguments) || this;
  }
  var _proto = DraftEntityInstance2.prototype;
  _proto.getType = function getType() {
    return this.get("type");
  };
  _proto.getMutability = function getMutability() {
    return this.get("mutability");
  };
  _proto.getData = function getData2() {
    return this.get("data");
  };
  return DraftEntityInstance2;
}(DraftEntityInstanceRecord);
var DraftEntityInstance_1 = DraftEntityInstance$2;
function uuid$1() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    var r2 = Math.random() * 16 | 0;
    var v = c == "x" ? r2 : r2 & 3 | 8;
    return v.toString(16);
  });
}
var uuid_1 = uuid$1;
function _objectSpread$d(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty$l(target, key, source[key]);
    });
  }
  return target;
}
function _defineProperty$l(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DraftEntityInstance$1 = DraftEntityInstance_1;
var Immutable$d = immutable$1.exports;
var invariant$o = invariant_1;
var uuid = uuid_1;
var Map$a = Immutable$d.Map;
var instances = Map$a();
var instanceKey = uuid();
function logWarning(oldMethodCall, newMethodCall) {
  console.warn("WARNING: " + oldMethodCall + ' will be deprecated soon!\nPlease use "' + newMethodCall + '" instead.');
}
var DraftEntity$4 = {
  getLastCreatedEntityKey: function getLastCreatedEntityKey() {
    logWarning("DraftEntity.getLastCreatedEntityKey", "contentState.getLastCreatedEntityKey");
    return DraftEntity$4.__getLastCreatedEntityKey();
  },
  create: function create(type, mutability, data) {
    logWarning("DraftEntity.create", "contentState.createEntity");
    return DraftEntity$4.__create(type, mutability, data);
  },
  add: function add2(instance) {
    logWarning("DraftEntity.add", "contentState.addEntity");
    return DraftEntity$4.__add(instance);
  },
  get: function get(key) {
    logWarning("DraftEntity.get", "contentState.getEntity");
    return DraftEntity$4.__get(key);
  },
  __getAll: function __getAll() {
    return instances;
  },
  __loadWithEntities: function __loadWithEntities(entities) {
    instances = entities;
    instanceKey = uuid();
  },
  mergeData: function mergeData(key, toMerge) {
    logWarning("DraftEntity.mergeData", "contentState.mergeEntityData");
    return DraftEntity$4.__mergeData(key, toMerge);
  },
  replaceData: function replaceData(key, newData) {
    logWarning("DraftEntity.replaceData", "contentState.replaceEntityData");
    return DraftEntity$4.__replaceData(key, newData);
  },
  __getLastCreatedEntityKey: function __getLastCreatedEntityKey() {
    return instanceKey;
  },
  __create: function __create(type, mutability, data) {
    return DraftEntity$4.__add(new DraftEntityInstance$1({
      type,
      mutability,
      data: data || {}
    }));
  },
  __add: function __add(instance) {
    instanceKey = uuid();
    instances = instances.set(instanceKey, instance);
    return instanceKey;
  },
  __get: function __get(key) {
    var instance = instances.get(key);
    !!!instance ? invariant$o(false) : void 0;
    return instance;
  },
  __mergeData: function __mergeData(key, toMerge) {
    var instance = DraftEntity$4.__get(key);
    var newData = _objectSpread$d({}, instance.getData(), toMerge);
    var newInstance = instance.set("data", newData);
    instances = instances.set(key, newInstance);
    return newInstance;
  },
  __replaceData: function __replaceData(key, newData) {
    var instance = DraftEntity$4.__get(key);
    var newInstance = instance.set("data", newData);
    instances = instances.set(key, newInstance);
    return newInstance;
  }
};
var DraftEntity_1 = DraftEntity$4;
function _inheritsLoose$b(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var Immutable$c = immutable$1.exports;
var Record$2 = Immutable$c.Record;
var defaultRecord$2 = {
  anchorKey: "",
  anchorOffset: 0,
  focusKey: "",
  focusOffset: 0,
  isBackward: false,
  hasFocus: false
};
var SelectionStateRecord = Record$2(defaultRecord$2);
var SelectionState$4 = /* @__PURE__ */ function(_SelectionStateRecord) {
  _inheritsLoose$b(SelectionState2, _SelectionStateRecord);
  function SelectionState2() {
    return _SelectionStateRecord.apply(this, arguments) || this;
  }
  var _proto = SelectionState2.prototype;
  _proto.serialize = function serialize() {
    return "Anchor: " + this.getAnchorKey() + ":" + this.getAnchorOffset() + ", Focus: " + this.getFocusKey() + ":" + this.getFocusOffset() + ", Is Backward: " + String(this.getIsBackward()) + ", Has Focus: " + String(this.getHasFocus());
  };
  _proto.getAnchorKey = function getAnchorKey() {
    return this.get("anchorKey");
  };
  _proto.getAnchorOffset = function getAnchorOffset() {
    return this.get("anchorOffset");
  };
  _proto.getFocusKey = function getFocusKey() {
    return this.get("focusKey");
  };
  _proto.getFocusOffset = function getFocusOffset() {
    return this.get("focusOffset");
  };
  _proto.getIsBackward = function getIsBackward() {
    return this.get("isBackward");
  };
  _proto.getHasFocus = function getHasFocus() {
    return this.get("hasFocus");
  };
  _proto.hasEdgeWithin = function hasEdgeWithin(blockKey, start, end) {
    var anchorKey = this.getAnchorKey();
    var focusKey = this.getFocusKey();
    if (anchorKey === focusKey && anchorKey === blockKey) {
      var selectionStart = this.getStartOffset();
      var selectionEnd = this.getEndOffset();
      return start <= selectionStart && selectionStart <= end || start <= selectionEnd && selectionEnd <= end;
    }
    if (blockKey !== anchorKey && blockKey !== focusKey) {
      return false;
    }
    var offsetToCheck = blockKey === anchorKey ? this.getAnchorOffset() : this.getFocusOffset();
    return start <= offsetToCheck && end >= offsetToCheck;
  };
  _proto.isCollapsed = function isCollapsed() {
    return this.getAnchorKey() === this.getFocusKey() && this.getAnchorOffset() === this.getFocusOffset();
  };
  _proto.getStartKey = function getStartKey() {
    return this.getIsBackward() ? this.getFocusKey() : this.getAnchorKey();
  };
  _proto.getStartOffset = function getStartOffset() {
    return this.getIsBackward() ? this.getFocusOffset() : this.getAnchorOffset();
  };
  _proto.getEndKey = function getEndKey() {
    return this.getIsBackward() ? this.getAnchorKey() : this.getFocusKey();
  };
  _proto.getEndOffset = function getEndOffset() {
    return this.getIsBackward() ? this.getAnchorOffset() : this.getFocusOffset();
  };
  SelectionState2.createEmpty = function createEmpty(key) {
    return new SelectionState2({
      anchorKey: key,
      anchorOffset: 0,
      focusKey: key,
      focusOffset: 0,
      isBackward: false,
      hasFocus: false
    });
  };
  return SelectionState2;
}(SelectionStateRecord);
var SelectionState_1 = SelectionState$4;
var gkx$8 = function(name) {
  if (typeof window !== "undefined" && window.__DRAFT_GKX) {
    return !!window.__DRAFT_GKX[name];
  }
  return false;
};
var REGEX_BLOCK_DELIMITER$1 = new RegExp("\r", "g");
function sanitizeDraftText$3(input) {
  return input.replace(REGEX_BLOCK_DELIMITER$1, "");
}
var sanitizeDraftText_1 = sanitizeDraftText$3;
function _objectSpread$c(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty$k(target, key, source[key]);
    });
  }
  return target;
}
function _defineProperty$k(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inheritsLoose$a(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var BlockMapBuilder$3 = BlockMapBuilder_1;
var CharacterMetadata$5 = CharacterMetadata_1;
var ContentBlock$6 = ContentBlock_1;
var ContentBlockNode$6 = ContentBlockNode_1;
var DraftEntity$3 = DraftEntity_1;
var SelectionState$3 = SelectionState_1;
var generateRandomKey$7 = generateRandomKey_1;
var getOwnObjectValues = getOwnObjectValues_1;
var gkx$7 = gkx$8;
var Immutable$b = immutable$1.exports;
var sanitizeDraftText$2 = sanitizeDraftText_1;
var List$a = Immutable$b.List, Record$1 = Immutable$b.Record, Repeat$2 = Immutable$b.Repeat, ImmutableMap = Immutable$b.Map, OrderedMap$5 = Immutable$b.OrderedMap;
var defaultRecord$1 = {
  entityMap: null,
  blockMap: null,
  selectionBefore: null,
  selectionAfter: null
};
var ContentStateRecord = Record$1(defaultRecord$1);
var ContentBlockNodeRecord = gkx$7("draft_tree_data_support") ? ContentBlockNode$6 : ContentBlock$6;
var ContentState$3 = /* @__PURE__ */ function(_ContentStateRecord) {
  _inheritsLoose$a(ContentState2, _ContentStateRecord);
  function ContentState2() {
    return _ContentStateRecord.apply(this, arguments) || this;
  }
  var _proto = ContentState2.prototype;
  _proto.getEntityMap = function getEntityMap() {
    return DraftEntity$3;
  };
  _proto.getBlockMap = function getBlockMap() {
    return this.get("blockMap");
  };
  _proto.getSelectionBefore = function getSelectionBefore() {
    return this.get("selectionBefore");
  };
  _proto.getSelectionAfter = function getSelectionAfter() {
    return this.get("selectionAfter");
  };
  _proto.getBlockForKey = function getBlockForKey(key) {
    var block = this.getBlockMap().get(key);
    return block;
  };
  _proto.getKeyBefore = function getKeyBefore(key) {
    return this.getBlockMap().reverse().keySeq().skipUntil(function(v) {
      return v === key;
    }).skip(1).first();
  };
  _proto.getKeyAfter = function getKeyAfter(key) {
    return this.getBlockMap().keySeq().skipUntil(function(v) {
      return v === key;
    }).skip(1).first();
  };
  _proto.getBlockAfter = function getBlockAfter(key) {
    return this.getBlockMap().skipUntil(function(_, k) {
      return k === key;
    }).skip(1).first();
  };
  _proto.getBlockBefore = function getBlockBefore(key) {
    return this.getBlockMap().reverse().skipUntil(function(_, k) {
      return k === key;
    }).skip(1).first();
  };
  _proto.getBlocksAsArray = function getBlocksAsArray() {
    return this.getBlockMap().toArray();
  };
  _proto.getFirstBlock = function getFirstBlock() {
    return this.getBlockMap().first();
  };
  _proto.getLastBlock = function getLastBlock() {
    return this.getBlockMap().last();
  };
  _proto.getPlainText = function getPlainText(delimiter) {
    return this.getBlockMap().map(function(block) {
      return block ? block.getText() : "";
    }).join(delimiter || "\n");
  };
  _proto.getLastCreatedEntityKey = function getLastCreatedEntityKey2() {
    return DraftEntity$3.__getLastCreatedEntityKey();
  };
  _proto.hasText = function hasText() {
    var blockMap = this.getBlockMap();
    return blockMap.size > 1 || escape(blockMap.first().getText()).replace(/%u200B/g, "").length > 0;
  };
  _proto.createEntity = function createEntity(type, mutability, data) {
    DraftEntity$3.__create(type, mutability, data);
    return this;
  };
  _proto.mergeEntityData = function mergeEntityData(key, toMerge) {
    DraftEntity$3.__mergeData(key, toMerge);
    return this;
  };
  _proto.replaceEntityData = function replaceEntityData(key, newData) {
    DraftEntity$3.__replaceData(key, newData);
    return this;
  };
  _proto.addEntity = function addEntity(instance) {
    DraftEntity$3.__add(instance);
    return this;
  };
  _proto.getEntity = function getEntity2(key) {
    return DraftEntity$3.__get(key);
  };
  _proto.getAllEntities = function getAllEntities() {
    return DraftEntity$3.__getAll();
  };
  _proto.loadWithEntities = function loadWithEntities(entities) {
    return DraftEntity$3.__loadWithEntities(entities);
  };
  ContentState2.createFromBlockArray = function createFromBlockArray(blocks, entityMap) {
    var theBlocks = Array.isArray(blocks) ? blocks : blocks.contentBlocks;
    var blockMap = BlockMapBuilder$3.createFromArray(theBlocks);
    var selectionState = blockMap.isEmpty() ? new SelectionState$3() : SelectionState$3.createEmpty(blockMap.first().getKey());
    return new ContentState2({
      blockMap,
      entityMap: entityMap || DraftEntity$3,
      selectionBefore: selectionState,
      selectionAfter: selectionState
    });
  };
  ContentState2.createFromText = function createFromText(text) {
    var delimiter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /\r\n?|\n/g;
    var strings = text.split(delimiter);
    var blocks = strings.map(function(block) {
      block = sanitizeDraftText$2(block);
      return new ContentBlockNodeRecord({
        key: generateRandomKey$7(),
        text: block,
        type: "unstyled",
        characterList: List$a(Repeat$2(CharacterMetadata$5.EMPTY, block.length))
      });
    });
    return ContentState2.createFromBlockArray(blocks);
  };
  ContentState2.fromJS = function fromJS2(state) {
    return new ContentState2(_objectSpread$c({}, state, {
      blockMap: OrderedMap$5(state.blockMap).map(ContentState2.createContentBlockFromJS),
      selectionBefore: new SelectionState$3(state.selectionBefore),
      selectionAfter: new SelectionState$3(state.selectionAfter)
    }));
  };
  ContentState2.createContentBlockFromJS = function createContentBlockFromJS(block) {
    var characterList = block.characterList;
    return new ContentBlockNodeRecord(_objectSpread$c({}, block, {
      data: ImmutableMap(block.data),
      characterList: characterList != null ? List$a((Array.isArray(characterList) ? characterList : getOwnObjectValues(characterList)).map(function(c) {
        return CharacterMetadata$5.fromJS(c);
      })) : void 0
    }));
  };
  return ContentState2;
}(ContentStateRecord);
var ContentState_1 = ContentState$3;
var invariant$n = invariant_1;
var NEUTRAL = "NEUTRAL";
var LTR = "LTR";
var RTL = "RTL";
var globalDir = null;
function isStrong(dir) {
  return dir === LTR || dir === RTL;
}
function getHTMLDir(dir) {
  !isStrong(dir) ? invariant$n(false) : void 0;
  return dir === LTR ? "ltr" : "rtl";
}
function getHTMLDirIfDifferent(dir, otherDir) {
  !isStrong(dir) ? invariant$n(false) : void 0;
  !isStrong(otherDir) ? invariant$n(false) : void 0;
  return dir === otherDir ? null : getHTMLDir(dir);
}
function setGlobalDir(dir) {
  globalDir = dir;
}
function initGlobalDir() {
  setGlobalDir(LTR);
}
function getGlobalDir() {
  if (!globalDir) {
    this.initGlobalDir();
  }
  !globalDir ? invariant$n(false) : void 0;
  return globalDir;
}
var UnicodeBidiDirection$4 = {
  NEUTRAL,
  LTR,
  RTL,
  isStrong,
  getHTMLDir,
  getHTMLDirIfDifferent,
  setGlobalDir,
  initGlobalDir,
  getGlobalDir
};
var UnicodeBidiDirection_1 = UnicodeBidiDirection$4;
var UnicodeBidiDirection$3 = UnicodeBidiDirection_1;
var invariant$m = invariant_1;
var RANGE_BY_BIDI_TYPE = {
  L: "A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u01BA\u01BB\u01BC-\u01BF\u01C0-\u01C3\u01C4-\u0293\u0294\u0295-\u02AF\u02B0-\u02B8\u02BB-\u02C1\u02D0-\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376-\u0377\u037A\u037B-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0482\u048A-\u052F\u0531-\u0556\u0559\u055A-\u055F\u0561-\u0587\u0589\u0903\u0904-\u0939\u093B\u093D\u093E-\u0940\u0949-\u094C\u094E-\u094F\u0950\u0958-\u0961\u0964-\u0965\u0966-\u096F\u0970\u0971\u0972-\u0980\u0982-\u0983\u0985-\u098C\u098F-\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09BE-\u09C0\u09C7-\u09C8\u09CB-\u09CC\u09CE\u09D7\u09DC-\u09DD\u09DF-\u09E1\u09E6-\u09EF\u09F0-\u09F1\u09F4-\u09F9\u09FA\u0A03\u0A05-\u0A0A\u0A0F-\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32-\u0A33\u0A35-\u0A36\u0A38-\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2-\u0AB3\u0AB5-\u0AB9\u0ABD\u0ABE-\u0AC0\u0AC9\u0ACB-\u0ACC\u0AD0\u0AE0-\u0AE1\u0AE6-\u0AEF\u0AF0\u0B02-\u0B03\u0B05-\u0B0C\u0B0F-\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32-\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47-\u0B48\u0B4B-\u0B4C\u0B57\u0B5C-\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B70\u0B71\u0B72-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99-\u0B9A\u0B9C\u0B9E-\u0B9F\u0BA3-\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BBF\u0BC1-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BEF\u0BF0-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C59\u0C60-\u0C61\u0C66-\u0C6F\u0C7F\u0C82-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CBE\u0CBF\u0CC0-\u0CC4\u0CC6\u0CC7-\u0CC8\u0CCA-\u0CCB\u0CD5-\u0CD6\u0CDE\u0CE0-\u0CE1\u0CE6-\u0CEF\u0CF1-\u0CF2\u0D02-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D57\u0D60-\u0D61\u0D66-\u0D6F\u0D70-\u0D75\u0D79\u0D7A-\u0D7F\u0D82-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF3\u0DF4\u0E01-\u0E30\u0E32-\u0E33\u0E40-\u0E45\u0E46\u0E4F\u0E50-\u0E59\u0E5A-\u0E5B\u0E81-\u0E82\u0E84\u0E87-\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA-\u0EAB\u0EAD-\u0EB0\u0EB2-\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F01-\u0F03\u0F04-\u0F12\u0F13\u0F14\u0F15-\u0F17\u0F1A-\u0F1F\u0F20-\u0F29\u0F2A-\u0F33\u0F34\u0F36\u0F38\u0F3E-\u0F3F\u0F40-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FCF\u0FD0-\u0FD4\u0FD5-\u0FD8\u0FD9-\u0FDA\u1000-\u102A\u102B-\u102C\u1031\u1038\u103B-\u103C\u103F\u1040-\u1049\u104A-\u104F\u1050-\u1055\u1056-\u1057\u105A-\u105D\u1061\u1062-\u1064\u1065-\u1066\u1067-\u106D\u106E-\u1070\u1075-\u1081\u1083-\u1084\u1087-\u108C\u108E\u108F\u1090-\u1099\u109A-\u109C\u109E-\u109F\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FB\u10FC\u10FD-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u1368\u1369-\u137C\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166D-\u166E\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EB-\u16ED\u16EE-\u16F0\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1735-\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7-\u17C8\u17D4-\u17D6\u17D7\u17D8-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1842\u1843\u1844-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930-\u1931\u1933-\u1938\u1946-\u194F\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C0\u19C1-\u19C7\u19C8-\u19C9\u19D0-\u19D9\u19DA\u1A00-\u1A16\u1A19-\u1A1A\u1A1E-\u1A1F\u1A20-\u1A54\u1A55\u1A57\u1A61\u1A63-\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AA6\u1AA7\u1AA8-\u1AAD\u1B04\u1B05-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B44\u1B45-\u1B4B\u1B50-\u1B59\u1B5A-\u1B60\u1B61-\u1B6A\u1B74-\u1B7C\u1B82\u1B83-\u1BA0\u1BA1\u1BA6-\u1BA7\u1BAA\u1BAE-\u1BAF\u1BB0-\u1BB9\u1BBA-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2-\u1BF3\u1BFC-\u1BFF\u1C00-\u1C23\u1C24-\u1C2B\u1C34-\u1C35\u1C3B-\u1C3F\u1C40-\u1C49\u1C4D-\u1C4F\u1C50-\u1C59\u1C5A-\u1C77\u1C78-\u1C7D\u1C7E-\u1C7F\u1CC0-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF2-\u1CF3\u1CF5-\u1CF6\u1D00-\u1D2B\u1D2C-\u1D6A\u1D6B-\u1D77\u1D78\u1D79-\u1D9A\u1D9B-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2134\u2135-\u2138\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2182\u2183-\u2184\u2185-\u2188\u2336-\u237A\u2395\u249C-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2C7B\u2C7C-\u2C7D\u2C7E-\u2CE4\u2CEB-\u2CEE\u2CF2-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005\u3006\u3007\u3021-\u3029\u302E-\u302F\u3031-\u3035\u3038-\u303A\u303B\u303C\u3041-\u3096\u309D-\u309E\u309F\u30A1-\u30FA\u30FC-\u30FE\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u3191\u3192-\u3195\u3196-\u319F\u31A0-\u31BA\u31F0-\u31FF\u3200-\u321C\u3220-\u3229\u322A-\u3247\u3248-\u324F\u3260-\u327B\u327F\u3280-\u3289\u328A-\u32B0\u32C0-\u32CB\u32D0-\u32FE\u3300-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA014\uA015\uA016-\uA48C\uA4D0-\uA4F7\uA4F8-\uA4FD\uA4FE-\uA4FF\uA500-\uA60B\uA60C\uA610-\uA61F\uA620-\uA629\uA62A-\uA62B\uA640-\uA66D\uA66E\uA680-\uA69B\uA69C-\uA69D\uA6A0-\uA6E5\uA6E6-\uA6EF\uA6F2-\uA6F7\uA722-\uA76F\uA770\uA771-\uA787\uA789-\uA78A\uA78B-\uA78E\uA790-\uA7AD\uA7B0-\uA7B1\uA7F7\uA7F8-\uA7F9\uA7FA\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA823-\uA824\uA827\uA830-\uA835\uA836-\uA837\uA840-\uA873\uA880-\uA881\uA882-\uA8B3\uA8B4-\uA8C3\uA8CE-\uA8CF\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8F8-\uA8FA\uA8FB\uA900-\uA909\uA90A-\uA925\uA92E-\uA92F\uA930-\uA946\uA952-\uA953\uA95F\uA960-\uA97C\uA983\uA984-\uA9B2\uA9B4-\uA9B5\uA9BA-\uA9BB\uA9BD-\uA9C0\uA9C1-\uA9CD\uA9CF\uA9D0-\uA9D9\uA9DE-\uA9DF\uA9E0-\uA9E4\uA9E6\uA9E7-\uA9EF\uA9F0-\uA9F9\uA9FA-\uA9FE\uAA00-\uAA28\uAA2F-\uAA30\uAA33-\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA5F\uAA60-\uAA6F\uAA70\uAA71-\uAA76\uAA77-\uAA79\uAA7A\uAA7B\uAA7D\uAA7E-\uAAAF\uAAB1\uAAB5-\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADC\uAADD\uAADE-\uAADF\uAAE0-\uAAEA\uAAEB\uAAEE-\uAAEF\uAAF0-\uAAF1\uAAF2\uAAF3-\uAAF4\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5B\uAB5C-\uAB5F\uAB64-\uAB65\uABC0-\uABE2\uABE3-\uABE4\uABE6-\uABE7\uABE9-\uABEA\uABEB\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uE000-\uF8FF\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFF6F\uFF70\uFF71-\uFF9D\uFF9E-\uFF9F\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  R: "\u0590\u05BE\u05C0\u05C3\u05C6\u05C8-\u05CF\u05D0-\u05EA\u05EB-\u05EF\u05F0-\u05F2\u05F3-\u05F4\u05F5-\u05FF\u07C0-\u07C9\u07CA-\u07EA\u07F4-\u07F5\u07FA\u07FB-\u07FF\u0800-\u0815\u081A\u0824\u0828\u082E-\u082F\u0830-\u083E\u083F\u0840-\u0858\u085C-\u085D\u085E\u085F-\u089F\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB37\uFB38-\uFB3C\uFB3D\uFB3E\uFB3F\uFB40-\uFB41\uFB42\uFB43-\uFB44\uFB45\uFB46-\uFB4F",
  AL: "\u0608\u060B\u060D\u061B\u061C\u061D\u061E-\u061F\u0620-\u063F\u0640\u0641-\u064A\u066D\u066E-\u066F\u0671-\u06D3\u06D4\u06D5\u06E5-\u06E6\u06EE-\u06EF\u06FA-\u06FC\u06FD-\u06FE\u06FF\u0700-\u070D\u070E\u070F\u0710\u0712-\u072F\u074B-\u074C\u074D-\u07A5\u07B1\u07B2-\u07BF\u08A0-\u08B2\u08B3-\u08E3\uFB50-\uFBB1\uFBB2-\uFBC1\uFBC2-\uFBD2\uFBD3-\uFD3D\uFD40-\uFD4F\uFD50-\uFD8F\uFD90-\uFD91\uFD92-\uFDC7\uFDC8-\uFDCF\uFDF0-\uFDFB\uFDFC\uFDFE-\uFDFF\uFE70-\uFE74\uFE75\uFE76-\uFEFC\uFEFD-\uFEFE"
};
var REGEX_STRONG = new RegExp("[" + RANGE_BY_BIDI_TYPE.L + RANGE_BY_BIDI_TYPE.R + RANGE_BY_BIDI_TYPE.AL + "]");
var REGEX_RTL = new RegExp("[" + RANGE_BY_BIDI_TYPE.R + RANGE_BY_BIDI_TYPE.AL + "]");
function firstStrongChar(str) {
  var match3 = REGEX_STRONG.exec(str);
  return match3 == null ? null : match3[0];
}
function firstStrongCharDir(str) {
  var strongChar = firstStrongChar(str);
  if (strongChar == null) {
    return UnicodeBidiDirection$3.NEUTRAL;
  }
  return REGEX_RTL.exec(strongChar) ? UnicodeBidiDirection$3.RTL : UnicodeBidiDirection$3.LTR;
}
function resolveBlockDir(str, fallback3) {
  fallback3 = fallback3 || UnicodeBidiDirection$3.NEUTRAL;
  if (!str.length) {
    return fallback3;
  }
  var blockDir = firstStrongCharDir(str);
  return blockDir === UnicodeBidiDirection$3.NEUTRAL ? fallback3 : blockDir;
}
function getDirection(str, strongFallback) {
  if (!strongFallback) {
    strongFallback = UnicodeBidiDirection$3.getGlobalDir();
  }
  !UnicodeBidiDirection$3.isStrong(strongFallback) ? invariant$m(false) : void 0;
  return resolveBlockDir(str, strongFallback);
}
function isDirectionLTR(str, strongFallback) {
  return getDirection(str, strongFallback) === UnicodeBidiDirection$3.LTR;
}
function isDirectionRTL(str, strongFallback) {
  return getDirection(str, strongFallback) === UnicodeBidiDirection$3.RTL;
}
var UnicodeBidi$3 = {
  firstStrongChar,
  firstStrongCharDir,
  resolveBlockDir,
  getDirection,
  isDirectionLTR,
  isDirectionRTL
};
var UnicodeBidi_1 = UnicodeBidi$3;
function _defineProperty$j(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var UnicodeBidi$2 = UnicodeBidi_1;
var UnicodeBidiDirection$2 = UnicodeBidiDirection_1;
var invariant$l = invariant_1;
var UnicodeBidiService$1 = /* @__PURE__ */ function() {
  function UnicodeBidiService2(defaultDir) {
    _defineProperty$j(this, "_defaultDir", void 0);
    _defineProperty$j(this, "_lastDir", void 0);
    if (!defaultDir) {
      defaultDir = UnicodeBidiDirection$2.getGlobalDir();
    } else {
      !UnicodeBidiDirection$2.isStrong(defaultDir) ? invariant$l(false) : void 0;
    }
    this._defaultDir = defaultDir;
    this.reset();
  }
  var _proto = UnicodeBidiService2.prototype;
  _proto.reset = function reset() {
    this._lastDir = this._defaultDir;
  };
  _proto.getDirection = function getDirection2(str) {
    this._lastDir = UnicodeBidi$2.getDirection(str, this._lastDir);
    return this._lastDir;
  };
  return UnicodeBidiService2;
}();
var UnicodeBidiService_1 = UnicodeBidiService$1;
var nullthrows$f = function nullthrows(x) {
  if (x != null) {
    return x;
  }
  throw new Error("Got unexpected null or undefined");
};
var nullthrows_1 = nullthrows$f;
var UnicodeBidiService = UnicodeBidiService_1;
var Immutable$a = immutable$1.exports;
var nullthrows$e = nullthrows_1;
var OrderedMap$4 = Immutable$a.OrderedMap;
var bidiService;
var EditorBidiService$1 = {
  getDirectionMap: function getDirectionMap(content, prevBidiMap) {
    if (!bidiService) {
      bidiService = new UnicodeBidiService();
    } else {
      bidiService.reset();
    }
    var blockMap = content.getBlockMap();
    var nextBidi = blockMap.valueSeq().map(function(block) {
      return nullthrows$e(bidiService).getDirection(block.getText());
    });
    var bidiMap = OrderedMap$4(blockMap.keySeq().zip(nextBidi));
    if (prevBidiMap != null && Immutable$a.is(prevBidiMap, bidiMap)) {
      return prevBidiMap;
    }
    return bidiMap;
  }
};
var EditorBidiService_1 = EditorBidiService$1;
function _objectSpread$b(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty$i(target, key, source[key]);
    });
  }
  return target;
}
function _defineProperty$i(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var BlockTree = BlockTree_1;
var ContentState$2 = ContentState_1;
var EditorBidiService = EditorBidiService_1;
var SelectionState$2 = SelectionState_1;
var Immutable$9 = immutable$1.exports;
var OrderedSet$3 = Immutable$9.OrderedSet, Record = Immutable$9.Record, Stack$5 = Immutable$9.Stack, OrderedMap$3 = Immutable$9.OrderedMap, List$9 = Immutable$9.List;
var defaultRecord = {
  allowUndo: true,
  currentContent: null,
  decorator: null,
  directionMap: null,
  forceSelection: false,
  inCompositionMode: false,
  inlineStyleOverride: null,
  lastChangeType: null,
  nativelyRenderedContent: null,
  redoStack: Stack$5(),
  selection: null,
  treeMap: null,
  undoStack: Stack$5()
};
var EditorStateRecord = Record(defaultRecord);
var EditorState$q = /* @__PURE__ */ function() {
  EditorState2.createEmpty = function createEmpty(decorator2) {
    return this.createWithText("", decorator2);
  };
  EditorState2.createWithText = function createWithText(text, decorator2) {
    return EditorState2.createWithContent(ContentState$2.createFromText(text), decorator2);
  };
  EditorState2.createWithContent = function createWithContent(contentState, decorator2) {
    if (contentState.getBlockMap().count() === 0) {
      return EditorState2.createEmpty(decorator2);
    }
    var firstKey = contentState.getBlockMap().first().getKey();
    return EditorState2.create({
      currentContent: contentState,
      undoStack: Stack$5(),
      redoStack: Stack$5(),
      decorator: decorator2 || null,
      selection: SelectionState$2.createEmpty(firstKey)
    });
  };
  EditorState2.create = function create2(config) {
    var currentContent = config.currentContent, decorator2 = config.decorator;
    var recordConfig = _objectSpread$b({}, config, {
      treeMap: generateNewTreeMap(currentContent, decorator2),
      directionMap: EditorBidiService.getDirectionMap(currentContent)
    });
    return new EditorState2(new EditorStateRecord(recordConfig));
  };
  EditorState2.fromJS = function fromJS2(config) {
    return new EditorState2(new EditorStateRecord(_objectSpread$b({}, config, {
      directionMap: config.directionMap != null ? OrderedMap$3(config.directionMap) : config.directionMap,
      inlineStyleOverride: config.inlineStyleOverride != null ? OrderedSet$3(config.inlineStyleOverride) : config.inlineStyleOverride,
      nativelyRenderedContent: config.nativelyRenderedContent != null ? ContentState$2.fromJS(config.nativelyRenderedContent) : config.nativelyRenderedContent,
      redoStack: config.redoStack != null ? Stack$5(config.redoStack.map(function(v) {
        return ContentState$2.fromJS(v);
      })) : config.redoStack,
      selection: config.selection != null ? new SelectionState$2(config.selection) : config.selection,
      treeMap: config.treeMap != null ? OrderedMap$3(config.treeMap).map(function(v) {
        return List$9(v).map(function(v2) {
          return BlockTree.fromJS(v2);
        });
      }) : config.treeMap,
      undoStack: config.undoStack != null ? Stack$5(config.undoStack.map(function(v) {
        return ContentState$2.fromJS(v);
      })) : config.undoStack,
      currentContent: ContentState$2.fromJS(config.currentContent)
    })));
  };
  EditorState2.set = function set3(editorState, put) {
    var map2 = editorState.getImmutable().withMutations(function(state) {
      var existingDecorator = state.get("decorator");
      var decorator2 = existingDecorator;
      if (put.decorator === null) {
        decorator2 = null;
      } else if (put.decorator) {
        decorator2 = put.decorator;
      }
      var newContent = put.currentContent || editorState.getCurrentContent();
      if (decorator2 !== existingDecorator) {
        var treeMap = state.get("treeMap");
        var newTreeMap;
        if (decorator2 && existingDecorator) {
          newTreeMap = regenerateTreeForNewDecorator(newContent, newContent.getBlockMap(), treeMap, decorator2, existingDecorator);
        } else {
          newTreeMap = generateNewTreeMap(newContent, decorator2);
        }
        state.merge({
          decorator: decorator2,
          treeMap: newTreeMap,
          nativelyRenderedContent: null
        });
        return;
      }
      var existingContent = editorState.getCurrentContent();
      if (newContent !== existingContent) {
        state.set("treeMap", regenerateTreeForNewBlocks(editorState, newContent.getBlockMap(), newContent.getEntityMap(), decorator2));
      }
      state.merge(put);
    });
    return new EditorState2(map2);
  };
  var _proto = EditorState2.prototype;
  _proto.toJS = function toJS2() {
    return this.getImmutable().toJS();
  };
  _proto.getAllowUndo = function getAllowUndo() {
    return this.getImmutable().get("allowUndo");
  };
  _proto.getCurrentContent = function getCurrentContent() {
    return this.getImmutable().get("currentContent");
  };
  _proto.getUndoStack = function getUndoStack() {
    return this.getImmutable().get("undoStack");
  };
  _proto.getRedoStack = function getRedoStack() {
    return this.getImmutable().get("redoStack");
  };
  _proto.getSelection = function getSelection() {
    return this.getImmutable().get("selection");
  };
  _proto.getDecorator = function getDecorator() {
    return this.getImmutable().get("decorator");
  };
  _proto.isInCompositionMode = function isInCompositionMode() {
    return this.getImmutable().get("inCompositionMode");
  };
  _proto.mustForceSelection = function mustForceSelection() {
    return this.getImmutable().get("forceSelection");
  };
  _proto.getNativelyRenderedContent = function getNativelyRenderedContent() {
    return this.getImmutable().get("nativelyRenderedContent");
  };
  _proto.getLastChangeType = function getLastChangeType() {
    return this.getImmutable().get("lastChangeType");
  };
  _proto.getInlineStyleOverride = function getInlineStyleOverride() {
    return this.getImmutable().get("inlineStyleOverride");
  };
  EditorState2.setInlineStyleOverride = function setInlineStyleOverride(editorState, inlineStyleOverride) {
    return EditorState2.set(editorState, {
      inlineStyleOverride
    });
  };
  _proto.getCurrentInlineStyle = function getCurrentInlineStyle() {
    var override = this.getInlineStyleOverride();
    if (override != null) {
      return override;
    }
    var content = this.getCurrentContent();
    var selection = this.getSelection();
    if (selection.isCollapsed()) {
      return getInlineStyleForCollapsedSelection(content, selection);
    }
    return getInlineStyleForNonCollapsedSelection(content, selection);
  };
  _proto.getBlockTree = function getBlockTree(blockKey) {
    return this.getImmutable().getIn(["treeMap", blockKey]);
  };
  _proto.isSelectionAtStartOfContent = function isSelectionAtStartOfContent() {
    var firstKey = this.getCurrentContent().getBlockMap().first().getKey();
    return this.getSelection().hasEdgeWithin(firstKey, 0, 0);
  };
  _proto.isSelectionAtEndOfContent = function isSelectionAtEndOfContent() {
    var content = this.getCurrentContent();
    var blockMap = content.getBlockMap();
    var last4 = blockMap.last();
    var end = last4.getLength();
    return this.getSelection().hasEdgeWithin(last4.getKey(), end, end);
  };
  _proto.getDirectionMap = function getDirectionMap2() {
    return this.getImmutable().get("directionMap");
  };
  EditorState2.acceptSelection = function acceptSelection(editorState, selection) {
    return updateSelection(editorState, selection, false);
  };
  EditorState2.forceSelection = function forceSelection2(editorState, selection) {
    if (!selection.getHasFocus()) {
      selection = selection.set("hasFocus", true);
    }
    return updateSelection(editorState, selection, true);
  };
  EditorState2.moveSelectionToEnd = function moveSelectionToEnd(editorState) {
    var content = editorState.getCurrentContent();
    var lastBlock = content.getLastBlock();
    var lastKey = lastBlock.getKey();
    var length = lastBlock.getLength();
    return EditorState2.acceptSelection(editorState, new SelectionState$2({
      anchorKey: lastKey,
      anchorOffset: length,
      focusKey: lastKey,
      focusOffset: length,
      isBackward: false
    }));
  };
  EditorState2.moveFocusToEnd = function moveFocusToEnd(editorState) {
    var afterSelectionMove = EditorState2.moveSelectionToEnd(editorState);
    return EditorState2.forceSelection(afterSelectionMove, afterSelectionMove.getSelection());
  };
  EditorState2.push = function push2(editorState, contentState, changeType) {
    var forceSelection2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
    if (editorState.getCurrentContent() === contentState) {
      return editorState;
    }
    var directionMap = EditorBidiService.getDirectionMap(contentState, editorState.getDirectionMap());
    if (!editorState.getAllowUndo()) {
      return EditorState2.set(editorState, {
        currentContent: contentState,
        directionMap,
        lastChangeType: changeType,
        selection: contentState.getSelectionAfter(),
        forceSelection: forceSelection2,
        inlineStyleOverride: null
      });
    }
    var selection = editorState.getSelection();
    var currentContent = editorState.getCurrentContent();
    var undoStack = editorState.getUndoStack();
    var newContent = contentState;
    if (selection !== currentContent.getSelectionAfter() || mustBecomeBoundary(editorState, changeType)) {
      undoStack = undoStack.push(currentContent);
      newContent = newContent.set("selectionBefore", selection);
    } else if (changeType === "insert-characters" || changeType === "backspace-character" || changeType === "delete-character") {
      newContent = newContent.set("selectionBefore", currentContent.getSelectionBefore());
    }
    var inlineStyleOverride = editorState.getInlineStyleOverride();
    var overrideChangeTypes = ["adjust-depth", "change-block-type", "split-block"];
    if (overrideChangeTypes.indexOf(changeType) === -1) {
      inlineStyleOverride = null;
    }
    var editorStateChanges = {
      currentContent: newContent,
      directionMap,
      undoStack,
      redoStack: Stack$5(),
      lastChangeType: changeType,
      selection: contentState.getSelectionAfter(),
      forceSelection: forceSelection2,
      inlineStyleOverride
    };
    return EditorState2.set(editorState, editorStateChanges);
  };
  EditorState2.undo = function undo(editorState) {
    if (!editorState.getAllowUndo()) {
      return editorState;
    }
    var undoStack = editorState.getUndoStack();
    var newCurrentContent = undoStack.peek();
    if (!newCurrentContent) {
      return editorState;
    }
    var currentContent = editorState.getCurrentContent();
    var directionMap = EditorBidiService.getDirectionMap(newCurrentContent, editorState.getDirectionMap());
    return EditorState2.set(editorState, {
      currentContent: newCurrentContent,
      directionMap,
      undoStack: undoStack.shift(),
      redoStack: editorState.getRedoStack().push(currentContent),
      forceSelection: true,
      inlineStyleOverride: null,
      lastChangeType: "undo",
      nativelyRenderedContent: null,
      selection: currentContent.getSelectionBefore()
    });
  };
  EditorState2.redo = function redo(editorState) {
    if (!editorState.getAllowUndo()) {
      return editorState;
    }
    var redoStack = editorState.getRedoStack();
    var newCurrentContent = redoStack.peek();
    if (!newCurrentContent) {
      return editorState;
    }
    var currentContent = editorState.getCurrentContent();
    var directionMap = EditorBidiService.getDirectionMap(newCurrentContent, editorState.getDirectionMap());
    return EditorState2.set(editorState, {
      currentContent: newCurrentContent,
      directionMap,
      undoStack: editorState.getUndoStack().push(currentContent),
      redoStack: redoStack.shift(),
      forceSelection: true,
      inlineStyleOverride: null,
      lastChangeType: "redo",
      nativelyRenderedContent: null,
      selection: newCurrentContent.getSelectionAfter()
    });
  };
  function EditorState2(immutable2) {
    _defineProperty$i(this, "_immutable", void 0);
    this._immutable = immutable2;
  }
  _proto.getImmutable = function getImmutable() {
    return this._immutable;
  };
  return EditorState2;
}();
function updateSelection(editorState, selection, forceSelection2) {
  return EditorState$q.set(editorState, {
    selection,
    forceSelection: forceSelection2,
    nativelyRenderedContent: null,
    inlineStyleOverride: null
  });
}
function generateNewTreeMap(contentState, decorator2) {
  return contentState.getBlockMap().map(function(block) {
    return BlockTree.generate(contentState, block, decorator2);
  }).toOrderedMap();
}
function regenerateTreeForNewBlocks(editorState, newBlockMap, newEntityMap, decorator2) {
  var contentState = editorState.getCurrentContent().set("entityMap", newEntityMap);
  var prevBlockMap = contentState.getBlockMap();
  var prevTreeMap = editorState.getImmutable().get("treeMap");
  return prevTreeMap.merge(newBlockMap.toSeq().filter(function(block, key) {
    return block !== prevBlockMap.get(key);
  }).map(function(block) {
    return BlockTree.generate(contentState, block, decorator2);
  }));
}
function regenerateTreeForNewDecorator(content, blockMap, previousTreeMap, decorator2, existingDecorator) {
  return previousTreeMap.merge(blockMap.toSeq().filter(function(block) {
    return decorator2.getDecorations(block, content) !== existingDecorator.getDecorations(block, content);
  }).map(function(block) {
    return BlockTree.generate(content, block, decorator2);
  }));
}
function mustBecomeBoundary(editorState, changeType) {
  var lastChangeType = editorState.getLastChangeType();
  return changeType !== lastChangeType || changeType !== "insert-characters" && changeType !== "backspace-character" && changeType !== "delete-character";
}
function getInlineStyleForCollapsedSelection(content, selection) {
  var startKey = selection.getStartKey();
  var startOffset = selection.getStartOffset();
  var startBlock = content.getBlockForKey(startKey);
  if (startOffset > 0) {
    return startBlock.getInlineStyleAt(startOffset - 1);
  }
  if (startBlock.getLength()) {
    return startBlock.getInlineStyleAt(0);
  }
  return lookUpwardForInlineStyle(content, startKey);
}
function getInlineStyleForNonCollapsedSelection(content, selection) {
  var startKey = selection.getStartKey();
  var startOffset = selection.getStartOffset();
  var startBlock = content.getBlockForKey(startKey);
  if (startOffset < startBlock.getLength()) {
    return startBlock.getInlineStyleAt(startOffset);
  }
  if (startOffset > 0) {
    return startBlock.getInlineStyleAt(startOffset - 1);
  }
  return lookUpwardForInlineStyle(content, startKey);
}
function lookUpwardForInlineStyle(content, fromKey) {
  var lastNonEmpty = content.getBlockMap().reverse().skipUntil(function(_, k) {
    return k === fromKey;
  }).skip(1).skipUntil(function(block, _) {
    return block.getLength();
  }).first();
  if (lastNonEmpty) {
    return lastNonEmpty.getInlineStyleAt(lastNonEmpty.getLength() - 1);
  }
  return OrderedSet$3();
}
var EditorState_1 = EditorState$q;
var ContentBlockNode$5 = ContentBlockNode_1;
var getNextDelimiterBlockKey2 = getNextDelimiterBlockKey_1;
var Immutable$8 = immutable$1.exports;
var invariant$k = invariant_1;
var OrderedMap$2 = Immutable$8.OrderedMap, List$8 = Immutable$8.List;
var transformBlock3 = function transformBlock4(key, blockMap, func2) {
  if (!key) {
    return;
  }
  var block = blockMap.get(key);
  if (!block) {
    return;
  }
  blockMap.set(key, func2(block));
};
var updateBlockMapLinks4 = function updateBlockMapLinks5(blockMap, originalBlockToBeMoved, originalTargetBlock, insertionMode, isExperimentalTreeBlock) {
  if (!isExperimentalTreeBlock) {
    return blockMap;
  }
  var isInsertedAfterTarget = insertionMode === "after";
  var originalBlockKey = originalBlockToBeMoved.getKey();
  var originalTargetKey = originalTargetBlock.getKey();
  var originalParentKey = originalBlockToBeMoved.getParentKey();
  var originalNextSiblingKey = originalBlockToBeMoved.getNextSiblingKey();
  var originalPrevSiblingKey = originalBlockToBeMoved.getPrevSiblingKey();
  var newParentKey = originalTargetBlock.getParentKey();
  var newNextSiblingKey = isInsertedAfterTarget ? originalTargetBlock.getNextSiblingKey() : originalTargetKey;
  var newPrevSiblingKey = isInsertedAfterTarget ? originalTargetKey : originalTargetBlock.getPrevSiblingKey();
  return blockMap.withMutations(function(blocks) {
    transformBlock3(originalParentKey, blocks, function(block) {
      var parentChildrenList = block.getChildKeys();
      return block.merge({
        children: parentChildrenList["delete"](parentChildrenList.indexOf(originalBlockKey))
      });
    });
    transformBlock3(originalPrevSiblingKey, blocks, function(block) {
      return block.merge({
        nextSibling: originalNextSiblingKey
      });
    });
    transformBlock3(originalNextSiblingKey, blocks, function(block) {
      return block.merge({
        prevSibling: originalPrevSiblingKey
      });
    });
    transformBlock3(newNextSiblingKey, blocks, function(block) {
      return block.merge({
        prevSibling: originalBlockKey
      });
    });
    transformBlock3(newPrevSiblingKey, blocks, function(block) {
      return block.merge({
        nextSibling: originalBlockKey
      });
    });
    transformBlock3(newParentKey, blocks, function(block) {
      var newParentChildrenList = block.getChildKeys();
      var targetBlockIndex = newParentChildrenList.indexOf(originalTargetKey);
      var insertionIndex = isInsertedAfterTarget ? targetBlockIndex + 1 : targetBlockIndex !== 0 ? targetBlockIndex - 1 : 0;
      var newChildrenArray = newParentChildrenList.toArray();
      newChildrenArray.splice(insertionIndex, 0, originalBlockKey);
      return block.merge({
        children: List$8(newChildrenArray)
      });
    });
    transformBlock3(originalBlockKey, blocks, function(block) {
      return block.merge({
        nextSibling: newNextSiblingKey,
        prevSibling: newPrevSiblingKey,
        parent: newParentKey
      });
    });
  });
};
var moveBlockInContentState$1 = function moveBlockInContentState(contentState, blockToBeMoved, targetBlock, insertionMode) {
  !(insertionMode !== "replace") ? invariant$k(false) : void 0;
  var targetKey = targetBlock.getKey();
  var blockKey = blockToBeMoved.getKey();
  !(blockKey !== targetKey) ? invariant$k(false) : void 0;
  var blockMap = contentState.getBlockMap();
  var isExperimentalTreeBlock = blockToBeMoved instanceof ContentBlockNode$5;
  var blocksToBeMoved = [blockToBeMoved];
  var blockMapWithoutBlocksToBeMoved = blockMap["delete"](blockKey);
  if (isExperimentalTreeBlock) {
    blocksToBeMoved = [];
    blockMapWithoutBlocksToBeMoved = blockMap.withMutations(function(blocks) {
      var nextSiblingKey = blockToBeMoved.getNextSiblingKey();
      var nextDelimiterBlockKey = getNextDelimiterBlockKey2(blockToBeMoved, blocks);
      blocks.toSeq().skipUntil(function(block) {
        return block.getKey() === blockKey;
      }).takeWhile(function(block) {
        var key = block.getKey();
        var isBlockToBeMoved = key === blockKey;
        var hasNextSiblingAndIsNotNextSibling = nextSiblingKey && key !== nextSiblingKey;
        var doesNotHaveNextSiblingAndIsNotDelimiter = !nextSiblingKey && block.getParentKey() && (!nextDelimiterBlockKey || key !== nextDelimiterBlockKey);
        return !!(isBlockToBeMoved || hasNextSiblingAndIsNotNextSibling || doesNotHaveNextSiblingAndIsNotDelimiter);
      }).forEach(function(block) {
        blocksToBeMoved.push(block);
        blocks["delete"](block.getKey());
      });
    });
  }
  var blocksBefore = blockMapWithoutBlocksToBeMoved.toSeq().takeUntil(function(v) {
    return v === targetBlock;
  });
  var blocksAfter = blockMapWithoutBlocksToBeMoved.toSeq().skipUntil(function(v) {
    return v === targetBlock;
  }).skip(1);
  var slicedBlocks = blocksToBeMoved.map(function(block) {
    return [block.getKey(), block];
  });
  var newBlocks = OrderedMap$2();
  if (insertionMode === "before") {
    var blockBefore = contentState.getBlockBefore(targetKey);
    !(!blockBefore || blockBefore.getKey() !== blockToBeMoved.getKey()) ? invariant$k(false) : void 0;
    newBlocks = blocksBefore.concat([].concat(slicedBlocks, [[targetKey, targetBlock]]), blocksAfter).toOrderedMap();
  } else if (insertionMode === "after") {
    var blockAfter = contentState.getBlockAfter(targetKey);
    !(!blockAfter || blockAfter.getKey() !== blockKey) ? invariant$k(false) : void 0;
    newBlocks = blocksBefore.concat([[targetKey, targetBlock]].concat(slicedBlocks), blocksAfter).toOrderedMap();
  }
  return contentState.merge({
    blockMap: updateBlockMapLinks4(newBlocks, blockToBeMoved, targetBlock, insertionMode, isExperimentalTreeBlock),
    selectionBefore: contentState.getSelectionAfter(),
    selectionAfter: contentState.getSelectionAfter().merge({
      anchorKey: blockKey,
      focusKey: blockKey
    })
  });
};
var moveBlockInContentState_1 = moveBlockInContentState$1;
function _objectSpread$a(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty$h(target, key, source[key]);
    });
  }
  return target;
}
function _defineProperty$h(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var BlockMapBuilder$2 = BlockMapBuilder_1;
var CharacterMetadata$4 = CharacterMetadata_1;
var ContentBlock$5 = ContentBlock_1;
var ContentBlockNode$4 = ContentBlockNode_1;
var DraftModifier$d = DraftModifier_1;
var EditorState$p = EditorState_1;
var generateRandomKey$6 = generateRandomKey_1;
var gkx$6 = gkx$8;
var Immutable$7 = immutable$1.exports;
var moveBlockInContentState2 = moveBlockInContentState_1;
var experimentalTreeDataSupport$5 = gkx$6("draft_tree_data_support");
var ContentBlockRecord$1 = experimentalTreeDataSupport$5 ? ContentBlockNode$4 : ContentBlock$5;
var List$7 = Immutable$7.List, Repeat$1 = Immutable$7.Repeat;
var AtomicBlockUtils$1 = {
  insertAtomicBlock: function insertAtomicBlock(editorState, entityKey, character) {
    var contentState = editorState.getCurrentContent();
    var selectionState = editorState.getSelection();
    var afterRemoval = DraftModifier$d.removeRange(contentState, selectionState, "backward");
    var targetSelection = afterRemoval.getSelectionAfter();
    var afterSplit = DraftModifier$d.splitBlock(afterRemoval, targetSelection);
    var insertionTarget = afterSplit.getSelectionAfter();
    var asAtomicBlock = DraftModifier$d.setBlockType(afterSplit, insertionTarget, "atomic");
    var charData = CharacterMetadata$4.create({
      entity: entityKey
    });
    var atomicBlockConfig = {
      key: generateRandomKey$6(),
      type: "atomic",
      text: character,
      characterList: List$7(Repeat$1(charData, character.length))
    };
    var atomicDividerBlockConfig = {
      key: generateRandomKey$6(),
      type: "unstyled"
    };
    if (experimentalTreeDataSupport$5) {
      atomicBlockConfig = _objectSpread$a({}, atomicBlockConfig, {
        nextSibling: atomicDividerBlockConfig.key
      });
      atomicDividerBlockConfig = _objectSpread$a({}, atomicDividerBlockConfig, {
        prevSibling: atomicBlockConfig.key
      });
    }
    var fragmentArray = [new ContentBlockRecord$1(atomicBlockConfig), new ContentBlockRecord$1(atomicDividerBlockConfig)];
    var fragment = BlockMapBuilder$2.createFromArray(fragmentArray);
    var withAtomicBlock = DraftModifier$d.replaceWithFragment(asAtomicBlock, insertionTarget, fragment);
    var newContent = withAtomicBlock.merge({
      selectionBefore: selectionState,
      selectionAfter: withAtomicBlock.getSelectionAfter().set("hasFocus", true)
    });
    return EditorState$p.push(editorState, newContent, "insert-fragment");
  },
  moveAtomicBlock: function moveAtomicBlock(editorState, atomicBlock, targetRange, insertionMode) {
    var contentState = editorState.getCurrentContent();
    var selectionState = editorState.getSelection();
    var withMovedAtomicBlock;
    if (insertionMode === "before" || insertionMode === "after") {
      var targetBlock = contentState.getBlockForKey(insertionMode === "before" ? targetRange.getStartKey() : targetRange.getEndKey());
      withMovedAtomicBlock = moveBlockInContentState2(contentState, atomicBlock, targetBlock, insertionMode);
    } else {
      var afterRemoval = DraftModifier$d.removeRange(contentState, targetRange, "backward");
      var selectionAfterRemoval = afterRemoval.getSelectionAfter();
      var _targetBlock = afterRemoval.getBlockForKey(selectionAfterRemoval.getFocusKey());
      if (selectionAfterRemoval.getStartOffset() === 0) {
        withMovedAtomicBlock = moveBlockInContentState2(afterRemoval, atomicBlock, _targetBlock, "before");
      } else if (selectionAfterRemoval.getEndOffset() === _targetBlock.getLength()) {
        withMovedAtomicBlock = moveBlockInContentState2(afterRemoval, atomicBlock, _targetBlock, "after");
      } else {
        var afterSplit = DraftModifier$d.splitBlock(afterRemoval, selectionAfterRemoval);
        var selectionAfterSplit = afterSplit.getSelectionAfter();
        var _targetBlock2 = afterSplit.getBlockForKey(selectionAfterSplit.getFocusKey());
        withMovedAtomicBlock = moveBlockInContentState2(afterSplit, atomicBlock, _targetBlock2, "before");
      }
    }
    var newContent = withMovedAtomicBlock.merge({
      selectionBefore: selectionState,
      selectionAfter: withMovedAtomicBlock.getSelectionAfter().set("hasFocus", true)
    });
    return EditorState$p.push(editorState, newContent, "move-block");
  }
};
var AtomicBlockUtils_1 = AtomicBlockUtils$1;
function _defineProperty$g(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Immutable$6 = immutable$1.exports;
var List$6 = Immutable$6.List;
var DELIMITER = ".";
var CompositeDraftDecorator$1 = /* @__PURE__ */ function() {
  function CompositeDraftDecorator2(decorators) {
    _defineProperty$g(this, "_decorators", void 0);
    this._decorators = decorators.slice();
  }
  var _proto = CompositeDraftDecorator2.prototype;
  _proto.getDecorations = function getDecorations(block, contentState) {
    var decorations = Array(block.getText().length).fill(null);
    this._decorators.forEach(function(decorator2, ii) {
      var counter = 0;
      var strategy = decorator2.strategy;
      var callback = function callback2(start, end) {
        if (canOccupySlice(decorations, start, end)) {
          occupySlice(decorations, start, end, ii + DELIMITER + counter);
          counter++;
        }
      };
      strategy(block, callback, contentState);
    });
    return List$6(decorations);
  };
  _proto.getComponentForKey = function getComponentForKey(key) {
    var componentKey = parseInt(key.split(DELIMITER)[0], 10);
    return this._decorators[componentKey].component;
  };
  _proto.getPropsForKey = function getPropsForKey(key) {
    var componentKey = parseInt(key.split(DELIMITER)[0], 10);
    return this._decorators[componentKey].props;
  };
  return CompositeDraftDecorator2;
}();
function canOccupySlice(decorations, start, end) {
  for (var ii = start; ii < end; ii++) {
    if (decorations[ii] != null) {
      return false;
    }
  }
  return true;
}
function occupySlice(targetArr, start, end, componentKey) {
  for (var ii = start; ii < end; ii++) {
    targetArr[ii] = componentKey;
  }
}
var CompositeDraftDecorator_1 = CompositeDraftDecorator$1;
var jsxRuntime$1 = { exports: {} };
var reactJsxRuntime_production_min = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$i = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject$1(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
  var from;
  var to = toObject$1(target);
  var symbols;
  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);
    for (var key in from) {
      if (hasOwnProperty$i.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }
  return to;
};
/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f = React$a, g = 60103;
reactJsxRuntime_production_min.Fragment = 60107;
if (typeof Symbol === "function" && Symbol.for) {
  var h = Symbol.for;
  g = h("react.element");
  reactJsxRuntime_production_min.Fragment = h("react.fragment");
}
var m$1 = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, n = Object.prototype.hasOwnProperty, p$1 = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
function q$1(c, a, k) {
  var b, d = {}, e = null, l2 = null;
  k !== void 0 && (e = "" + k);
  a.key !== void 0 && (e = "" + a.key);
  a.ref !== void 0 && (l2 = a.ref);
  for (b in a)
    n.call(a, b) && !p$1.hasOwnProperty(b) && (d[b] = a[b]);
  if (c && c.defaultProps)
    for (b in a = c.defaultProps, a)
      d[b] === void 0 && (d[b] = a[b]);
  return {
    $$typeof: g,
    type: c,
    key: e,
    ref: l2,
    props: d,
    _owner: m$1.current
  };
}
reactJsxRuntime_production_min.jsx = q$1;
reactJsxRuntime_production_min.jsxs = q$1;
{
  jsxRuntime$1.exports = reactJsxRuntime_production_min;
}
const jsx = jsxRuntime$1.exports.jsx;
const jsxs = jsxRuntime$1.exports.jsxs;
const Fragment = jsxRuntime$1.exports.Fragment;
var jsxRuntime = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  jsx,
  jsxs,
  Fragment
});
var require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(jsxRuntime);
function cx$7(classNames2) {
  if (typeof classNames2 == "object") {
    return Object.keys(classNames2).filter(function(className) {
      return classNames2[className];
    }).map(replace$1).join(" ");
  }
  return Array.prototype.map.call(arguments, replace$1).join(" ");
}
function replace$1(str) {
  return str.replace(/\//g, "-");
}
var cx_1 = cx$7;
var _jsx$9 = require$$0$1.jsx;
var cx$6 = cx_1;
var _require$4 = immutable$1.exports, Map$9 = _require$4.Map;
var UL_WRAP = /* @__PURE__ */ _jsx$9("ul", {
  className: cx$6("public/DraftStyleDefault/ul")
});
var OL_WRAP = /* @__PURE__ */ _jsx$9("ol", {
  className: cx$6("public/DraftStyleDefault/ol")
});
var PRE_WRAP = /* @__PURE__ */ _jsx$9("pre", {
  className: cx$6("public/DraftStyleDefault/pre")
});
var DefaultDraftBlockRenderMap$3 = Map$9({
  "header-one": {
    element: "h1"
  },
  "header-two": {
    element: "h2"
  },
  "header-three": {
    element: "h3"
  },
  "header-four": {
    element: "h4"
  },
  "header-five": {
    element: "h5"
  },
  "header-six": {
    element: "h6"
  },
  section: {
    element: "section"
  },
  article: {
    element: "article"
  },
  "unordered-list-item": {
    element: "li",
    wrapper: UL_WRAP
  },
  "ordered-list-item": {
    element: "li",
    wrapper: OL_WRAP
  },
  blockquote: {
    element: "blockquote"
  },
  atomic: {
    element: "figure"
  },
  "code-block": {
    element: "pre",
    wrapper: PRE_WRAP
  },
  unstyled: {
    element: "div",
    aliasedElements: ["p"]
  }
});
var DefaultDraftBlockRenderMap_1 = DefaultDraftBlockRenderMap$3;
var DefaultDraftInlineStyle$2 = {
  BOLD: {
    fontWeight: "bold"
  },
  CODE: {
    fontFamily: "monospace",
    wordWrap: "break-word"
  },
  ITALIC: {
    fontStyle: "italic"
  },
  STRIKETHROUGH: {
    textDecoration: "line-through"
  },
  UNDERLINE: {
    textDecoration: "underline"
  }
};
var uaParser = { exports: {} };
/*!@license
 * UAParser.js v0.7.28
 * Lightweight JavaScript-based User-Agent string parser
 * https://github.com/faisalman/ua-parser-js
 *
 * Copyright © 2012-2021 Faisal Salman <f@faisalman.com>
 * Licensed under MIT License
 */
(function(module, exports) {
  (function(window2, undefined$12) {
    var LIBVERSION = "0.7.28", EMPTY2 = "", UNKNOWN2 = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 255;
    var util2 = {
      extend: function(regexes2, extensions) {
        var mergedRegexes = {};
        for (var i in regexes2) {
          if (extensions[i] && extensions[i].length % 2 === 0) {
            mergedRegexes[i] = extensions[i].concat(regexes2[i]);
          } else {
            mergedRegexes[i] = regexes2[i];
          }
        }
        return mergedRegexes;
      },
      has: function(str1, str2) {
        return typeof str1 === STR_TYPE ? str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1 : false;
      },
      lowerize: function(str) {
        return str.toLowerCase();
      },
      major: function(version) {
        return typeof version === STR_TYPE ? version.replace(/[^\d\.]/g, "").split(".")[0] : undefined$12;
      },
      trim: function(str, len) {
        str = str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
        return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
      }
    };
    var mapper = {
      rgx: function(ua2, arrays) {
        var i = 0, j, k, p2, q2, matches, match3;
        while (i < arrays.length && !matches) {
          var regex2 = arrays[i], props = arrays[i + 1];
          j = k = 0;
          while (j < regex2.length && !matches) {
            matches = regex2[j++].exec(ua2);
            if (!!matches) {
              for (p2 = 0; p2 < props.length; p2++) {
                match3 = matches[++k];
                q2 = props[p2];
                if (typeof q2 === OBJ_TYPE && q2.length > 0) {
                  if (q2.length == 2) {
                    if (typeof q2[1] == FUNC_TYPE) {
                      this[q2[0]] = q2[1].call(this, match3);
                    } else {
                      this[q2[0]] = q2[1];
                    }
                  } else if (q2.length == 3) {
                    if (typeof q2[1] === FUNC_TYPE && !(q2[1].exec && q2[1].test)) {
                      this[q2[0]] = match3 ? q2[1].call(this, match3, q2[2]) : undefined$12;
                    } else {
                      this[q2[0]] = match3 ? match3.replace(q2[1], q2[2]) : undefined$12;
                    }
                  } else if (q2.length == 4) {
                    this[q2[0]] = match3 ? q2[3].call(this, match3.replace(q2[1], q2[2])) : undefined$12;
                  }
                } else {
                  this[q2] = match3 ? match3 : undefined$12;
                }
              }
            }
          }
          i += 2;
        }
      },
      str: function(str, map2) {
        for (var i in map2) {
          if (typeof map2[i] === OBJ_TYPE && map2[i].length > 0) {
            for (var j = 0; j < map2[i].length; j++) {
              if (util2.has(map2[i][j], str)) {
                return i === UNKNOWN2 ? undefined$12 : i;
              }
            }
          } else if (util2.has(map2[i], str)) {
            return i === UNKNOWN2 ? undefined$12 : i;
          }
        }
        return str;
      }
    };
    var maps = {
      browser: {
        oldSafari: {
          version: {
            "1.0": "/8",
            "1.2": "/1",
            "1.3": "/3",
            "2.0": "/412",
            "2.0.2": "/416",
            "2.0.3": "/417",
            "2.0.4": "/419",
            "?": "/"
          }
        },
        oldEdge: {
          version: {
            "0.1": "12.",
            "21": "13.",
            "31": "14.",
            "39": "15.",
            "41": "16.",
            "42": "17.",
            "44": "18."
          }
        }
      },
      os: {
        windows: {
          version: {
            "ME": "4.90",
            "NT 3.11": "NT3.51",
            "NT 4.0": "NT4.0",
            "2000": "NT 5.0",
            "XP": ["NT 5.1", "NT 5.2"],
            "Vista": "NT 6.0",
            "7": "NT 6.1",
            "8": "NT 6.2",
            "8.1": "NT 6.3",
            "10": ["NT 6.4", "NT 10.0"],
            "RT": "ARM"
          }
        }
      }
    };
    var regexes = {
      browser: [[
        /\b(?:crmo|crios)\/([\w\.]+)/i
      ], [VERSION, [NAME, "Chrome"]], [
        /edg(?:e|ios|a)?\/([\w\.]+)/i
      ], [VERSION, [NAME, "Edge"]], [
        /(opera\smini)\/([\w\.-]+)/i,
        /(opera\s[mobiletab]{3,6})\b.+version\/([\w\.-]+)/i,
        /(opera)(?:.+version\/|[\/\s]+)([\w\.]+)/i
      ], [NAME, VERSION], [
        /opios[\/\s]+([\w\.]+)/i
      ], [VERSION, [NAME, "Opera Mini"]], [
        /\sopr\/([\w\.]+)/i
      ], [VERSION, [NAME, "Opera"]], [
        /(kindle)\/([\w\.]+)/i,
        /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]*)/i,
        /(avant\s|iemobile|slim)(?:browser)?[\/\s]?([\w\.]*)/i,
        /(ba?idubrowser)[\/\s]?([\w\.]+)/i,
        /(?:ms|\()(ie)\s([\w\.]+)/i,
        /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon)\/([\w\.-]+)/i,
        /(rekonq|puffin|brave|whale|qqbrowserlite|qq)\/([\w\.]+)/i,
        /(weibo)__([\d\.]+)/i
      ], [NAME, VERSION], [
        /(?:[\s\/]uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i
      ], [VERSION, [NAME, "UCBrowser"]], [
        /(?:windowswechat)?\sqbcore\/([\w\.]+)\b.*(?:windowswechat)?/i
      ], [VERSION, [NAME, "WeChat(Win) Desktop"]], [
        /micromessenger\/([\w\.]+)/i
      ], [VERSION, [NAME, "WeChat"]], [
        /konqueror\/([\w\.]+)/i
      ], [VERSION, [NAME, "Konqueror"]], [
        /trident.+rv[:\s]([\w\.]{1,9})\b.+like\sgecko/i
      ], [VERSION, [NAME, "IE"]], [
        /yabrowser\/([\w\.]+)/i
      ], [VERSION, [NAME, "Yandex"]], [
        /(avast|avg)\/([\w\.]+)/i
      ], [[NAME, /(.+)/, "$1 Secure Browser"], VERSION], [
        /focus\/([\w\.]+)/i
      ], [VERSION, [NAME, "Firefox Focus"]], [
        /opt\/([\w\.]+)/i
      ], [VERSION, [NAME, "Opera Touch"]], [
        /coc_coc_browser\/([\w\.]+)/i
      ], [VERSION, [NAME, "Coc Coc"]], [
        /dolfin\/([\w\.]+)/i
      ], [VERSION, [NAME, "Dolphin"]], [
        /coast\/([\w\.]+)/i
      ], [VERSION, [NAME, "Opera Coast"]], [
        /xiaomi\/miuibrowser\/([\w\.]+)/i
      ], [VERSION, [NAME, "MIUI Browser"]], [
        /fxios\/([\w\.-]+)/i
      ], [VERSION, [NAME, "Firefox"]], [
        /(qihu|qhbrowser|qihoobrowser|360browser)/i
      ], [[NAME, "360 Browser"]], [/(oculus|samsung|sailfish)browser\/([\w\.]+)/i], [[NAME, /(.+)/, "$1 Browser"], VERSION], [
        /(comodo_dragon)\/([\w\.]+)/i
      ], [[NAME, /_/g, " "], VERSION], [
        /\s(electron)\/([\w\.]+)\ssafari/i,
        /(tesla)(?:\sqtcarbrowser|\/(20[12]\d\.[\w\.-]+))/i,
        /m?(qqbrowser|baiduboxapp|2345Explorer)[\/\s]?([\w\.]+)/i
      ], [NAME, VERSION], [
        /(MetaSr)[\/\s]?([\w\.]+)/i,
        /(LBBROWSER)/i
      ], [NAME], [
        /;fbav\/([\w\.]+);/i
      ], [VERSION, [NAME, "Facebook"]], [
        /FBAN\/FBIOS|FB_IAB\/FB4A/i
      ], [[NAME, "Facebook"]], [
        /safari\s(line)\/([\w\.]+)/i,
        /\b(line)\/([\w\.]+)\/iab/i,
        /(chromium|instagram)[\/\s]([\w\.-]+)/i
      ], [NAME, VERSION], [
        /\bgsa\/([\w\.]+)\s.*safari\//i
      ], [VERSION, [NAME, "GSA"]], [
        /headlesschrome(?:\/([\w\.]+)|\s)/i
      ], [VERSION, [NAME, "Chrome Headless"]], [
        /\swv\).+(chrome)\/([\w\.]+)/i
      ], [[NAME, "Chrome WebView"], VERSION], [
        /droid.+\sversion\/([\w\.]+)\b.+(?:mobile\ssafari|safari)/i
      ], [VERSION, [NAME, "Android Browser"]], [
        /(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i
      ], [NAME, VERSION], [
        /version\/([\w\.]+)\s.*mobile\/\w+\s(safari)/i
      ], [VERSION, [NAME, "Mobile Safari"]], [
        /version\/([\w\.]+)\s.*(mobile\s?safari|safari)/i
      ], [VERSION, NAME], [
        /webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i
      ], [NAME, [VERSION, mapper.str, maps.browser.oldSafari.version]], [/(webkit|khtml)\/([\w\.]+)/i], [NAME, VERSION], [
        /(navigator|netscape)\/([\w\.-]+)/i
      ], [[NAME, "Netscape"], VERSION], [
        /ile\svr;\srv:([\w\.]+)\).+firefox/i
      ], [VERSION, [NAME, "Firefox Reality"]], [
        /ekiohf.+(flow)\/([\w\.]+)/i,
        /(swiftfox)/i,
        /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,
        /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([\w\.-]+)$/i,
        /(firefox)\/([\w\.]+)\s[\w\s\-]+\/[\w\.]+$/i,
        /(mozilla)\/([\w\.]+)\s.+rv\:.+gecko\/\d+/i,
        /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,
        /(links)\s\(([\w\.]+)/i,
        /(gobrowser)\/?([\w\.]*)/i,
        /(ice\s?browser)\/v?([\w\._]+)/i,
        /(mosaic)[\/\s]([\w\.]+)/i
      ], [NAME, VERSION]],
      cpu: [[
        /(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i
      ], [[ARCHITECTURE, "amd64"]], [
        /(ia32(?=;))/i
      ], [[ARCHITECTURE, util2.lowerize]], [
        /((?:i[346]|x)86)[;\)]/i
      ], [[ARCHITECTURE, "ia32"]], [
        /\b(aarch64|armv?8e?l?)\b/i
      ], [[ARCHITECTURE, "arm64"]], [
        /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i
      ], [[ARCHITECTURE, "armhf"]], [
        /windows\s(ce|mobile);\sppc;/i
      ], [[ARCHITECTURE, "arm"]], [
        /((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i
      ], [[ARCHITECTURE, /ower/, "", util2.lowerize]], [
        /(sun4\w)[;\)]/i
      ], [[ARCHITECTURE, "sparc"]], [
        /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?:64|(?=v(?:[1-7]|[5-7]1)l?|;|eabi))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
      ], [[ARCHITECTURE, util2.lowerize]]],
      device: [[
        /\b(sch-i[89]0\d|shw-m380s|sm-[pt]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus\s10)/i
      ], [MODEL, [VENDOR, "Samsung"], [TYPE, TABLET]], [/\b((?:s[cgp]h|gt|sm)-\w+|galaxy\snexus)/i, /\ssamsung[\s-]([\w-]+)/i, /sec-(sgh\w+)/i], [MODEL, [VENDOR, "Samsung"], [TYPE, MOBILE]], [
        /\((ip(?:hone|od)[\s\w]*);/i
      ], [MODEL, [VENDOR, "Apple"], [TYPE, MOBILE]], [
        /\((ipad);[\w\s\),;-]+apple/i,
        /applecoremedia\/[\w\.]+\s\((ipad)/i,
        /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
      ], [MODEL, [VENDOR, "Apple"], [TYPE, TABLET]], [
        /\b((?:agr|ags[23]|bah2?|sht?)-a?[lw]\d{2})/i
      ], [MODEL, [VENDOR, "Huawei"], [TYPE, TABLET]], [/d\/huawei([\w\s-]+)[;\)]/i, /\b(nexus\s6p|vog-[at]?l\d\d|ane-[at]?l[x\d]\d|eml-a?l\d\da?|lya-[at]?l\d[\dc]|clt-a?l\d\di?|ele-l\d\d)/i, /\b(\w{2,4}-[atu][ln][01259][019])[;\)\s]/i], [MODEL, [VENDOR, "Huawei"], [TYPE, MOBILE]], [
        /\b(poco[\s\w]+)(?:\sbuild|\))/i,
        /\b;\s(\w+)\sbuild\/hm\1/i,
        /\b(hm[\s\-_]?note?[\s_]?(?:\d\w)?)\sbuild/i,
        /\b(redmi[\s\-_]?(?:note|k)?[\w\s_]+)(?:\sbuild|\))/i,
        /\b(mi[\s\-_]?(?:a\d|one|one[\s_]plus|note lte)?[\s_]?(?:\d?\w?)[\s_]?(?:plus)?)\sbuild/i
      ], [[MODEL, /_/g, " "], [VENDOR, "Xiaomi"], [TYPE, MOBILE]], [
        /\b(mi[\s\-_]?(?:pad)(?:[\w\s_]+))(?:\sbuild|\))/i
      ], [[MODEL, /_/g, " "], [VENDOR, "Xiaomi"], [TYPE, TABLET]], [
        /;\s(\w+)\sbuild.+\soppo/i,
        /\s(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007)\b/i
      ], [MODEL, [VENDOR, "OPPO"], [TYPE, MOBILE]], [
        /\svivo\s(\w+)(?:\sbuild|\))/i,
        /\s(v[12]\d{3}\w?[at])(?:\sbuild|;)/i
      ], [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]], [
        /\s(rmx[12]\d{3})(?:\sbuild|;)/i
      ], [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]], [
        /\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?:?(\s4g)?)\b[\w\s]+build\//i,
        /\smot(?:orola)?[\s-](\w*)/i,
        /((?:moto[\s\w\(\)]+|xt\d{3,4}|nexus\s6)(?=\sbuild|\)))/i
      ], [MODEL, [VENDOR, "Motorola"], [TYPE, MOBILE]], [/\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i], [MODEL, [VENDOR, "Motorola"], [TYPE, TABLET]], [
        /((?=lg)?[vl]k\-?\d{3})\sbuild|\s3\.[\s\w;-]{10}lg?-([06cv9]{3,4})/i
      ], [MODEL, [VENDOR, "LG"], [TYPE, TABLET]], [/(lm-?f100[nv]?|nexus\s[45])/i, /lg[e;\s\/-]+((?!browser|netcast)\w+)/i, /\blg(\-?[\d\w]+)\sbuild/i], [MODEL, [VENDOR, "LG"], [TYPE, MOBILE]], [
        /(ideatab[\w\-\s]+)/i,
        /lenovo\s?(s(?:5000|6000)(?:[\w-]+)|tab(?:[\s\w]+)|yt[\d\w-]{6}|tb[\d\w-]{6})/i
      ], [MODEL, [VENDOR, "Lenovo"], [TYPE, TABLET]], [
        /(?:maemo|nokia).*(n900|lumia\s\d+)/i,
        /nokia[\s_-]?([\w\.-]*)/i
      ], [[MODEL, /_/g, " "], [VENDOR, "Nokia"], [TYPE, MOBILE]], [
        /droid.+;\s(pixel\sc)[\s)]/i
      ], [MODEL, [VENDOR, "Google"], [TYPE, TABLET]], [
        /droid.+;\s(pixel[\s\daxl]{0,6})(?:\sbuild|\))/i
      ], [MODEL, [VENDOR, "Google"], [TYPE, MOBILE]], [
        /droid.+\s([c-g]\d{4}|so[-l]\w+|xq-a\w[4-7][12])(?=\sbuild\/|\).+chrome\/(?![1-6]{0,1}\d\.))/i
      ], [MODEL, [VENDOR, "Sony"], [TYPE, MOBILE]], [/sony\stablet\s[ps]\sbuild\//i, /(?:sony)?sgp\w+(?:\sbuild\/|\))/i], [[MODEL, "Xperia Tablet"], [VENDOR, "Sony"], [TYPE, TABLET]], [
        /\s(kb2005|in20[12]5|be20[12][59])\b/i,
        /\ba000(1)\sbuild/i,
        /\boneplus\s(a\d{4})[\s)]/i
      ], [MODEL, [VENDOR, "OnePlus"], [TYPE, MOBILE]], [
        /(alexa)webm/i,
        /(kf[a-z]{2}wi)(\sbuild\/|\))/i,
        /(kf[a-z]+)(\sbuild\/|\)).+silk\//i
      ], [MODEL, [VENDOR, "Amazon"], [TYPE, TABLET]], [
        /(sd|kf)[0349hijorstuw]+(\sbuild\/|\)).+silk\//i
      ], [[MODEL, "Fire Phone"], [VENDOR, "Amazon"], [TYPE, MOBILE]], [
        /\((playbook);[\w\s\),;-]+(rim)/i
      ], [MODEL, VENDOR, [TYPE, TABLET]], [
        /((?:bb[a-f]|st[hv])100-\d)/i,
        /\(bb10;\s(\w+)/i
      ], [MODEL, [VENDOR, "BlackBerry"], [TYPE, MOBILE]], [
        /(?:\b|asus_)(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus\s7|padfone|p00[cj])/i
      ], [MODEL, [VENDOR, "ASUS"], [TYPE, TABLET]], [/\s(z[es]6[027][01][km][ls]|zenfone\s\d\w?)\b/i], [MODEL, [VENDOR, "ASUS"], [TYPE, MOBILE]], [
        /(nexus\s9)/i
      ], [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]], [
        /(htc)[;_\s-]{1,2}([\w\s]+(?=\)|\sbuild)|\w+)/i,
        /(zte)-(\w*)/i,
        /(alcatel|geeksphone|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i
      ], [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]], [
        /droid[x\d\.\s;]+\s([ab][1-7]\-?[0178a]\d\d?)/i
      ], [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]], [
        /droid.+;\s(m[1-5]\snote)\sbuild/i,
        /\bmz-([\w-]{2,})/i
      ], [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]], [
        /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]*)/i,
        /(hp)\s([\w\s]+\w)/i,
        /(asus)-?(\w+)/i,
        /(microsoft);\s(lumia[\s\w]+)/i,
        /(lenovo)[_\s-]?([\w-]+)/i,
        /linux;.+(jolla);/i,
        /droid.+;\s(oppo)\s?([\w\s]+)\sbuild/i
      ], [VENDOR, MODEL, [TYPE, MOBILE]], [
        /(archos)\s(gamepad2?)/i,
        /(hp).+(touchpad(?!.+tablet)|tablet)/i,
        /(kindle)\/([\w\.]+)/i,
        /\s(nook)[\w\s]+build\/(\w+)/i,
        /(dell)\s(strea[kpr\s\d]*[\dko])/i,
        /[;\/]\s?(le[\s\-]+pan)[\s\-]+(\w{1,9})\sbuild/i,
        /[;\/]\s?(trinity)[\-\s]*(t\d{3})\sbuild/i,
        /\b(gigaset)[\s\-]+(q\w{1,9})\sbuild/i,
        /\b(vodafone)\s([\w\s]+)(?:\)|\sbuild)/i
      ], [VENDOR, MODEL, [TYPE, TABLET]], [
        /\s(surface\sduo)\s/i
      ], [MODEL, [VENDOR, "Microsoft"], [TYPE, TABLET]], [/droid\s[\d\.]+;\s(fp\du?)\sbuild/i], [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]], [
        /\s(u304aa)\sbuild/i
      ], [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]], [
        /sie-(\w*)/i
      ], [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]], [
        /[;\/]\s?(rct\w+)\sbuild/i
      ], [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]], [
        /[;\/\s](venue[\d\s]{2,7})\sbuild/i
      ], [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]], [
        /[;\/]\s?(q(?:mv|ta)\w+)\sbuild/i
      ], [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]], [
        /[;\/]\s(?:barnes[&\s]+noble\s|bn[rt])([\w\s\+]*)\sbuild/i
      ], [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]], [/[;\/]\s(tm\d{3}\w+)\sbuild/i], [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]], [
        /;\s(k88)\sbuild/i
      ], [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]], [
        /;\s(nx\d{3}j)\sbuild/i
      ], [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]], [
        /[;\/]\s?(gen\d{3})\sbuild.*49h/i
      ], [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]], [
        /[;\/]\s?(zur\d{3})\sbuild/i
      ], [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]], [
        /[;\/]\s?((zeki)?tb.*\b)\sbuild/i
      ], [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]], [
        /[;\/]\s([yr]\d{2})\sbuild/i,
        /[;\/]\s(dragon[\-\s]+touch\s|dt)(\w{5})\sbuild/i
      ], [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]], [
        /[;\/]\s?(ns-?\w{0,9})\sbuild/i
      ], [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]], [
        /[;\/]\s?((nxa|Next)-?\w{0,9})\sbuild/i
      ], [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]], [/[;\/]\s?(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05]))\sbuild/i], [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]], [
        /[;\/]\s?(lvtel\-)?(v1[12])\sbuild/i
      ], [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]], [/;\s(ph-1)\s/i], [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]], [
        /[;\/]\s?(v(100md|700na|7011|917g).*\b)\sbuild/i
      ], [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]], [
        /[;\/]\s?(trio[\s\w\-\.]+)\sbuild/i
      ], [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]], [
        /[;\/]\s?tu_(1491)\sbuild/i
      ], [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]], [
        /(shield[\w\s]+)\sbuild/i
      ], [MODEL, [VENDOR, "Nvidia"], [TYPE, TABLET]], [
        /(sprint)\s(\w+)/i
      ], [VENDOR, MODEL, [TYPE, MOBILE]], [
        /(kin\.[onetw]{3})/i
      ], [[MODEL, /\./g, " "], [VENDOR, "Microsoft"], [TYPE, MOBILE]], [
        /droid\s[\d\.]+;\s(cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i
      ], [MODEL, [VENDOR, "Zebra"], [TYPE, TABLET]], [/droid\s[\d\.]+;\s(ec30|ps20|tc[2-8]\d[kx])\)/i], [MODEL, [VENDOR, "Zebra"], [TYPE, MOBILE]], [
        /\s(ouya)\s/i,
        /(nintendo)\s([wids3utch]+)/i
      ], [VENDOR, MODEL, [TYPE, CONSOLE]], [
        /droid.+;\s(shield)\sbuild/i
      ], [MODEL, [VENDOR, "Nvidia"], [TYPE, CONSOLE]], [
        /(playstation\s[345portablevi]+)/i
      ], [MODEL, [VENDOR, "Sony"], [TYPE, CONSOLE]], [
        /[\s\(;](xbox(?:\sone)?(?!;\sxbox))[\s\);]/i
      ], [MODEL, [VENDOR, "Microsoft"], [TYPE, CONSOLE]], [
        /smart-tv.+(samsung)/i
      ], [VENDOR, [TYPE, SMARTTV]], [/hbbtv.+maple;(\d+)/i], [[MODEL, /^/, "SmartTV"], [VENDOR, "Samsung"], [TYPE, SMARTTV]], [
        /(?:linux;\snetcast.+smarttv|lg\snetcast\.tv-201\d)/i
      ], [[VENDOR, "LG"], [TYPE, SMARTTV]], [
        /(apple)\s?tv/i
      ], [VENDOR, [MODEL, "Apple TV"], [TYPE, SMARTTV]], [
        /crkey/i
      ], [[MODEL, "Chromecast"], [VENDOR, "Google"], [TYPE, SMARTTV]], [
        /droid.+aft([\w])(\sbuild\/|\))/i
      ], [MODEL, [VENDOR, "Amazon"], [TYPE, SMARTTV]], [
        /\(dtv[\);].+(aquos)/i
      ], [MODEL, [VENDOR, "Sharp"], [TYPE, SMARTTV]], [
        /hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i
      ], [[VENDOR, util2.trim], [MODEL, util2.trim], [TYPE, SMARTTV]], [
        /[\s\/\(](android\s|smart[-\s]?|opera\s)tv[;\)\s]/i
      ], [[TYPE, SMARTTV]], [
        /((pebble))app\/[\d\.]+\s/i
      ], [VENDOR, MODEL, [TYPE, WEARABLE]], [
        /droid.+;\s(glass)\s\d/i
      ], [MODEL, [VENDOR, "Google"], [TYPE, WEARABLE]], [/droid\s[\d\.]+;\s(wt63?0{2,3})\)/i], [MODEL, [VENDOR, "Zebra"], [TYPE, WEARABLE]], [
        /(tesla)(?:\sqtcarbrowser|\/20[12]\d\.[\w\.-]+)/i
      ], [VENDOR, [TYPE, EMBEDDED]], [
        /droid .+?; ([^;]+?)(?: build|\) applewebkit).+? mobile safari/i
      ], [MODEL, [TYPE, MOBILE]], [
        /droid .+?;\s([^;]+?)(?: build|\) applewebkit).+?(?! mobile) safari/i
      ], [MODEL, [TYPE, TABLET]], [
        /\s(tablet|tab)[;\/]/i,
        /\s(mobile)(?:[;\/]|\ssafari)/i
      ], [[TYPE, util2.lowerize]], [
        /(android[\w\.\s\-]{0,9});.+build/i
      ], [MODEL, [VENDOR, "Generic"]], [/(phone)/i], [[TYPE, MOBILE]]],
      engine: [[
        /windows.+\sedge\/([\w\.]+)/i
      ], [VERSION, [NAME, "EdgeHTML"]], [
        /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i
      ], [VERSION, [NAME, "Blink"]], [
        /(presto)\/([\w\.]+)/i,
        /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
        /ekioh(flow)\/([\w\.]+)/i,
        /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,
        /(icab)[\/\s]([23]\.[\d\.]+)/i
      ], [NAME, VERSION], [
        /rv\:([\w\.]{1,9})\b.+(gecko)/i
      ], [VERSION, NAME]],
      os: [[
        /microsoft\s(windows)\s(vista|xp)/i
      ], [NAME, VERSION], [
        /(windows)\snt\s6\.2;\s(arm)/i,
        /(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s\w]*)/i,
        /(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)(?!.+xbox)/i
      ], [NAME, [VERSION, mapper.str, maps.os.windows.version]], [/(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i], [[NAME, "Windows"], [VERSION, mapper.str, maps.os.windows.version]], [
        /ip[honead]{2,4}\b(?:.*os\s([\w]+)\slike\smac|;\sopera)/i,
        /cfnetwork\/.+darwin/i
      ], [[VERSION, /_/g, "."], [NAME, "iOS"]], [
        /(mac\sos\sx)\s?([\w\s\.]*)/i,
        /(macintosh|mac(?=_powerpc)\s)(?!.+haiku)/i
      ], [[NAME, "Mac OS"], [VERSION, /_/g, "."]], [
        /(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|sailfish|contiki)[\/\s-]?([\w\.]*)/i,
        /(blackberry)\w*\/([\w\.]*)/i,
        /(tizen|kaios)[\/\s]([\w\.]+)/i,
        /\((series40);/i
      ], [NAME, VERSION], [
        /\(bb(10);/i
      ], [VERSION, [NAME, "BlackBerry"]], [
        /(?:symbian\s?os|symbos|s60(?=;)|series60)[\/\s-]?([\w\.]*)/i
      ], [VERSION, [NAME, "Symbian"]], [
        /mozilla.+\(mobile;.+gecko.+firefox/i
      ], [[NAME, "Firefox OS"]], [
        /web0s;.+rt(tv)/i,
        /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i
      ], [VERSION, [NAME, "webOS"]], [
        /crkey\/([\d\.]+)/i
      ], [VERSION, [NAME, "Chromecast"]], [
        /(cros)\s[\w]+\s([\w\.]+\w)/i
      ], [[NAME, "Chromium OS"], VERSION], [
        /(nintendo|playstation)\s([wids345portablevuch]+)/i,
        /(xbox);\s+xbox\s([^\);]+)/i,
        /(mint)[\/\s\(\)]?(\w*)/i,
        /(mageia|vectorlinux)[;\s]/i,
        /(joli|[kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?=\slinux)|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus|raspbian)(?:\sgnu\/linux)?(?:\slinux)?[\/\s-]?(?!chrom|package)([\w\.-]*)/i,
        /(hurd|linux)\s?([\w\.]*)/i,
        /(gnu)\s?([\w\.]*)/i,
        /\s([frentopc-]{0,4}bsd|dragonfly)\s?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
        /(haiku)\s(\w+)/i
      ], [NAME, VERSION], [
        /(sunos)\s?([\w\.\d]*)/i
      ], [[NAME, "Solaris"], VERSION], [
        /((?:open)?solaris)[\/\s-]?([\w\.]*)/i,
        /(aix)\s((\d)(?=\.|\)|\s)[\w\.])*/i,
        /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms|fuchsia)/i,
        /(unix)\s?([\w\.]*)/i
      ], [NAME, VERSION]]
    };
    var UAParser2 = function(ua2, extensions) {
      if (typeof ua2 === "object") {
        extensions = ua2;
        ua2 = undefined$12;
      }
      if (!(this instanceof UAParser2)) {
        return new UAParser2(ua2, extensions).getResult();
      }
      var _ua = ua2 || (typeof window2 !== "undefined" && window2.navigator && window2.navigator.userAgent ? window2.navigator.userAgent : EMPTY2);
      var _rgxmap = extensions ? util2.extend(regexes, extensions) : regexes;
      this.getBrowser = function() {
        var _browser = {
          name: undefined$12,
          version: undefined$12
        };
        mapper.rgx.call(_browser, _ua, _rgxmap.browser);
        _browser.major = util2.major(_browser.version);
        return _browser;
      };
      this.getCPU = function() {
        var _cpu = {
          architecture: undefined$12
        };
        mapper.rgx.call(_cpu, _ua, _rgxmap.cpu);
        return _cpu;
      };
      this.getDevice = function() {
        var _device = {
          vendor: undefined$12,
          model: undefined$12,
          type: undefined$12
        };
        mapper.rgx.call(_device, _ua, _rgxmap.device);
        return _device;
      };
      this.getEngine = function() {
        var _engine = {
          name: undefined$12,
          version: undefined$12
        };
        mapper.rgx.call(_engine, _ua, _rgxmap.engine);
        return _engine;
      };
      this.getOS = function() {
        var _os = {
          name: undefined$12,
          version: undefined$12
        };
        mapper.rgx.call(_os, _ua, _rgxmap.os);
        return _os;
      };
      this.getResult = function() {
        return {
          ua: this.getUA(),
          browser: this.getBrowser(),
          engine: this.getEngine(),
          os: this.getOS(),
          device: this.getDevice(),
          cpu: this.getCPU()
        };
      };
      this.getUA = function() {
        return _ua;
      };
      this.setUA = function(ua3) {
        _ua = typeof ua3 === STR_TYPE && ua3.length > UA_MAX_LENGTH ? util2.trim(ua3, UA_MAX_LENGTH) : ua3;
        return this;
      };
      this.setUA(_ua);
      return this;
    };
    UAParser2.VERSION = LIBVERSION;
    UAParser2.BROWSER = {
      NAME,
      MAJOR,
      VERSION
    };
    UAParser2.CPU = {
      ARCHITECTURE
    };
    UAParser2.DEVICE = {
      MODEL,
      VENDOR,
      TYPE,
      CONSOLE,
      MOBILE,
      SMARTTV,
      TABLET,
      WEARABLE,
      EMBEDDED
    };
    UAParser2.ENGINE = {
      NAME,
      VERSION
    };
    UAParser2.OS = {
      NAME,
      VERSION
    };
    {
      if (module.exports) {
        exports = module.exports = UAParser2;
      }
      exports.UAParser = UAParser2;
    }
    var $ = typeof window2 !== "undefined" && (window2.jQuery || window2.Zepto);
    if ($ && !$.ua) {
      var parser2 = new UAParser2();
      $.ua = parser2.getResult();
      $.ua.get = function() {
        return parser2.getUA();
      };
      $.ua.set = function(uastring) {
        parser2.setUA(uastring);
        var result = parser2.getResult();
        for (var prop in result) {
          $.ua[prop] = result[prop];
        }
      };
    }
  })(typeof window === "object" ? window : commonjsGlobal);
})(uaParser, uaParser.exports);
var UAParser = uaParser.exports;
var UNKNOWN = "Unknown";
var PLATFORM_MAP = {
  "Mac OS": "Mac OS X"
};
function convertPlatformName(name) {
  return PLATFORM_MAP[name] || name;
}
function getBrowserVersion(version) {
  if (!version) {
    return {
      major: "",
      minor: ""
    };
  }
  var parts = version.split(".");
  return {
    major: parts[0],
    minor: parts[1]
  };
}
var parser = new UAParser();
var results = parser.getResult();
var browserVersionData = getBrowserVersion(results.browser.version);
var uaData = {
  browserArchitecture: results.cpu.architecture || UNKNOWN,
  browserFullVersion: results.browser.version || UNKNOWN,
  browserMinorVersion: browserVersionData.minor || UNKNOWN,
  browserName: results.browser.name || UNKNOWN,
  browserVersion: results.browser.major || UNKNOWN,
  deviceName: results.device.model || UNKNOWN,
  engineName: results.engine.name || UNKNOWN,
  engineVersion: results.engine.version || UNKNOWN,
  platformArchitecture: results.cpu.architecture || UNKNOWN,
  platformName: convertPlatformName(results.os.name) || UNKNOWN,
  platformVersion: results.os.version || UNKNOWN,
  platformFullVersion: results.os.version || UNKNOWN
};
var UserAgentData$1 = uaData;
var invariant$j = invariant_1;
var componentRegex = /\./;
var orRegex = /\|\|/;
var rangeRegex = /\s+\-\s+/;
var modifierRegex = /^(<=|<|=|>=|~>|~|>|)?\s*(.+)/;
var numericRegex = /^(\d*)(.*)/;
function checkOrExpression(range, version) {
  var expressions = range.split(orRegex);
  if (expressions.length > 1) {
    return expressions.some(function(range2) {
      return VersionRange$1.contains(range2, version);
    });
  } else {
    range = expressions[0].trim();
    return checkRangeExpression(range, version);
  }
}
function checkRangeExpression(range, version) {
  var expressions = range.split(rangeRegex);
  !(expressions.length > 0 && expressions.length <= 2) ? invariant$j(false) : void 0;
  if (expressions.length === 1) {
    return checkSimpleExpression(expressions[0], version);
  } else {
    var startVersion = expressions[0], endVersion = expressions[1];
    !(isSimpleVersion(startVersion) && isSimpleVersion(endVersion)) ? invariant$j(false) : void 0;
    return checkSimpleExpression(">=" + startVersion, version) && checkSimpleExpression("<=" + endVersion, version);
  }
}
function checkSimpleExpression(range, version) {
  range = range.trim();
  if (range === "") {
    return true;
  }
  var versionComponents = version.split(componentRegex);
  var _getModifierAndCompon = getModifierAndComponents(range), modifier = _getModifierAndCompon.modifier, rangeComponents = _getModifierAndCompon.rangeComponents;
  switch (modifier) {
    case "<":
      return checkLessThan(versionComponents, rangeComponents);
    case "<=":
      return checkLessThanOrEqual(versionComponents, rangeComponents);
    case ">=":
      return checkGreaterThanOrEqual(versionComponents, rangeComponents);
    case ">":
      return checkGreaterThan(versionComponents, rangeComponents);
    case "~":
    case "~>":
      return checkApproximateVersion(versionComponents, rangeComponents);
    default:
      return checkEqual(versionComponents, rangeComponents);
  }
}
function checkLessThan(a, b) {
  return compareComponents(a, b) === -1;
}
function checkLessThanOrEqual(a, b) {
  var result = compareComponents(a, b);
  return result === -1 || result === 0;
}
function checkEqual(a, b) {
  return compareComponents(a, b) === 0;
}
function checkGreaterThanOrEqual(a, b) {
  var result = compareComponents(a, b);
  return result === 1 || result === 0;
}
function checkGreaterThan(a, b) {
  return compareComponents(a, b) === 1;
}
function checkApproximateVersion(a, b) {
  var lowerBound = b.slice();
  var upperBound = b.slice();
  if (upperBound.length > 1) {
    upperBound.pop();
  }
  var lastIndex = upperBound.length - 1;
  var numeric = parseInt(upperBound[lastIndex], 10);
  if (isNumber$1(numeric)) {
    upperBound[lastIndex] = numeric + 1 + "";
  }
  return checkGreaterThanOrEqual(a, lowerBound) && checkLessThan(a, upperBound);
}
function getModifierAndComponents(range) {
  var rangeComponents = range.split(componentRegex);
  var matches = rangeComponents[0].match(modifierRegex);
  !matches ? invariant$j(false) : void 0;
  return {
    modifier: matches[1],
    rangeComponents: [matches[2]].concat(rangeComponents.slice(1))
  };
}
function isNumber$1(number) {
  return !isNaN(number) && isFinite(number);
}
function isSimpleVersion(range) {
  return !getModifierAndComponents(range).modifier;
}
function zeroPad(array, length) {
  for (var i = array.length; i < length; i++) {
    array[i] = "0";
  }
}
function normalizeVersions(a, b) {
  a = a.slice();
  b = b.slice();
  zeroPad(a, b.length);
  for (var i = 0; i < b.length; i++) {
    var matches = b[i].match(/^[x*]$/i);
    if (matches) {
      b[i] = a[i] = "0";
      if (matches[0] === "*" && i === b.length - 1) {
        for (var j = i; j < a.length; j++) {
          a[j] = "0";
        }
      }
    }
  }
  zeroPad(b, a.length);
  return [a, b];
}
function compareNumeric(a, b) {
  var aPrefix = a.match(numericRegex)[1];
  var bPrefix = b.match(numericRegex)[1];
  var aNumeric = parseInt(aPrefix, 10);
  var bNumeric = parseInt(bPrefix, 10);
  if (isNumber$1(aNumeric) && isNumber$1(bNumeric) && aNumeric !== bNumeric) {
    return compare$1(aNumeric, bNumeric);
  } else {
    return compare$1(a, b);
  }
}
function compare$1(a, b) {
  !(typeof a === typeof b) ? invariant$j(false) : void 0;
  if (a > b) {
    return 1;
  } else if (a < b) {
    return -1;
  } else {
    return 0;
  }
}
function compareComponents(a, b) {
  var _normalizeVersions = normalizeVersions(a, b), aNormalized = _normalizeVersions[0], bNormalized = _normalizeVersions[1];
  for (var i = 0; i < bNormalized.length; i++) {
    var result = compareNumeric(aNormalized[i], bNormalized[i]);
    if (result) {
      return result;
    }
  }
  return 0;
}
var VersionRange$1 = {
  contains: function contains(range, version) {
    return checkOrExpression(range.trim(), version.trim());
  }
};
var VersionRange_1 = VersionRange$1;
var hasOwnProperty$h = Object.prototype.hasOwnProperty;
function mapObject$1(object, callback, context) {
  if (!object) {
    return null;
  }
  var result = {};
  for (var name in object) {
    if (hasOwnProperty$h.call(object, name)) {
      result[name] = callback.call(context, object[name], name, object);
    }
  }
  return result;
}
var mapObject_1 = mapObject$1;
function memoizeStringOnly$1(callback) {
  var cache = {};
  return function(string) {
    if (!cache.hasOwnProperty(string)) {
      cache[string] = callback.call(this, string);
    }
    return cache[string];
  };
}
var memoizeStringOnly_1 = memoizeStringOnly$1;
var UserAgentData = UserAgentData$1;
var VersionRange = VersionRange_1;
var mapObject = mapObject_1;
var memoizeStringOnly = memoizeStringOnly_1;
function compare(name, version, query, normalizer) {
  if (name === query) {
    return true;
  }
  if (!query.startsWith(name)) {
    return false;
  }
  var range = query.slice(name.length);
  if (version) {
    range = normalizer ? normalizer(range) : range;
    return VersionRange.contains(range, version);
  }
  return false;
}
function normalizePlatformVersion(version) {
  if (UserAgentData.platformName === "Windows") {
    return version.replace(/^\s*NT/, "");
  }
  return version;
}
var UserAgent$e = {
  isBrowser: function isBrowser(query) {
    return compare(UserAgentData.browserName, UserAgentData.browserFullVersion, query);
  },
  isBrowserArchitecture: function isBrowserArchitecture(query) {
    return compare(UserAgentData.browserArchitecture, null, query);
  },
  isDevice: function isDevice(query) {
    return compare(UserAgentData.deviceName, null, query);
  },
  isEngine: function isEngine(query) {
    return compare(UserAgentData.engineName, UserAgentData.engineVersion, query);
  },
  isPlatform: function isPlatform(query) {
    return compare(UserAgentData.platformName, UserAgentData.platformFullVersion, query, normalizePlatformVersion);
  },
  isPlatformArchitecture: function isPlatformArchitecture(query) {
    return compare(UserAgentData.platformArchitecture, null, query);
  }
};
var UserAgent_1 = mapObject(UserAgent$e, memoizeStringOnly);
function getCorrectDocumentFromNode$4(node) {
  if (!node || !node.ownerDocument) {
    return document;
  }
  return node.ownerDocument;
}
var getCorrectDocumentFromNode_1 = getCorrectDocumentFromNode$4;
function isElement$8(node) {
  if (!node || !node.ownerDocument) {
    return false;
  }
  return node.nodeType === Node.ELEMENT_NODE;
}
var isElement_1 = isElement$8;
var isElement$7 = isElement_1;
function getSelectionOffsetKeyForNode$2(node) {
  if (isElement$7(node)) {
    var castedNode = node;
    var offsetKey = castedNode.getAttribute("data-offset-key");
    if (offsetKey) {
      return offsetKey;
    }
    for (var ii = 0; ii < castedNode.childNodes.length; ii++) {
      var childOffsetKey = getSelectionOffsetKeyForNode$2(castedNode.childNodes[ii]);
      if (childOffsetKey) {
        return childOffsetKey;
      }
    }
  }
  return null;
}
var getSelectionOffsetKeyForNode_1 = getSelectionOffsetKeyForNode$2;
var getCorrectDocumentFromNode$3 = getCorrectDocumentFromNode_1;
var getSelectionOffsetKeyForNode$1 = getSelectionOffsetKeyForNode_1;
function findAncestorOffsetKey$4(node) {
  var searchNode = node;
  while (searchNode && searchNode !== getCorrectDocumentFromNode$3(node).documentElement) {
    var key = getSelectionOffsetKeyForNode$1(searchNode);
    if (key != null) {
      return key;
    }
    searchNode = searchNode.parentNode;
  }
  return null;
}
var findAncestorOffsetKey_1 = findAncestorOffsetKey$4;
function getWindowForNode$2(node) {
  if (!node || !node.ownerDocument || !node.ownerDocument.defaultView) {
    return window;
  }
  return node.ownerDocument.defaultView;
}
var getWindowForNode_1 = getWindowForNode$2;
function _defineProperty$f(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var UserAgent$d = UserAgent_1;
var findAncestorOffsetKey$3 = findAncestorOffsetKey_1;
var getWindowForNode$1 = getWindowForNode_1;
var Immutable$5 = immutable$1.exports;
var invariant$i = invariant_1;
var nullthrows$d = nullthrows_1;
var Map$8 = Immutable$5.Map;
var DOM_OBSERVER_OPTIONS = {
  subtree: true,
  characterData: true,
  childList: true,
  characterDataOldValue: false,
  attributes: false
};
var USE_CHAR_DATA = UserAgent$d.isBrowser("IE <= 11");
var DOMObserver$1 = /* @__PURE__ */ function() {
  function DOMObserver2(container) {
    var _this = this;
    _defineProperty$f(this, "observer", void 0);
    _defineProperty$f(this, "container", void 0);
    _defineProperty$f(this, "mutations", void 0);
    _defineProperty$f(this, "onCharData", void 0);
    this.container = container;
    this.mutations = Map$8();
    var containerWindow = getWindowForNode$1(container);
    if (containerWindow.MutationObserver && !USE_CHAR_DATA) {
      this.observer = new containerWindow.MutationObserver(function(mutations) {
        return _this.registerMutations(mutations);
      });
    } else {
      this.onCharData = function(e) {
        !(e.target instanceof Node) ? invariant$i(false) : void 0;
        _this.registerMutation({
          type: "characterData",
          target: e.target
        });
      };
    }
  }
  var _proto = DOMObserver2.prototype;
  _proto.start = function start() {
    if (this.observer) {
      this.observer.observe(this.container, DOM_OBSERVER_OPTIONS);
    } else {
      this.container.addEventListener("DOMCharacterDataModified", this.onCharData);
    }
  };
  _proto.stopAndFlushMutations = function stopAndFlushMutations() {
    var observer = this.observer;
    if (observer) {
      this.registerMutations(observer.takeRecords());
      observer.disconnect();
    } else {
      this.container.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    var mutations = this.mutations;
    this.mutations = Map$8();
    return mutations;
  };
  _proto.registerMutations = function registerMutations(mutations) {
    for (var i = 0; i < mutations.length; i++) {
      this.registerMutation(mutations[i]);
    }
  };
  _proto.getMutationTextContent = function getMutationTextContent(mutation) {
    var type = mutation.type, target = mutation.target, removedNodes = mutation.removedNodes;
    if (type === "characterData") {
      if (target.textContent !== "") {
        if (USE_CHAR_DATA) {
          return target.textContent.replace("\n", "");
        }
        return target.textContent;
      }
    } else if (type === "childList") {
      if (removedNodes && removedNodes.length) {
        return "";
      } else if (target.textContent !== "") {
        return target.textContent;
      }
    }
    return null;
  };
  _proto.registerMutation = function registerMutation(mutation) {
    var textContent = this.getMutationTextContent(mutation);
    if (textContent != null) {
      var offsetKey = nullthrows$d(findAncestorOffsetKey$3(mutation.target));
      this.mutations = this.mutations.set(offsetKey, textContent);
    }
  };
  return DOMObserver2;
}();
var DOMObserver_1 = DOMObserver$1;
var KEY_DELIMITER = "-";
var DraftOffsetKey$9 = {
  encode: function encode(blockKey, decoratorKey, leafKey) {
    return blockKey + KEY_DELIMITER + decoratorKey + KEY_DELIMITER + leafKey;
  },
  decode: function decode(offsetKey) {
    var _offsetKey$split$reve = offsetKey.split(KEY_DELIMITER).reverse(), leafKey = _offsetKey$split$reve[0], decoratorKey = _offsetKey$split$reve[1], blockKeyParts = _offsetKey$split$reve.slice(2);
    return {
      blockKey: blockKeyParts.reverse().join(KEY_DELIMITER),
      decoratorKey: parseInt(decoratorKey, 10),
      leafKey: parseInt(leafKey, 10)
    };
  }
};
var DraftOffsetKey_1 = DraftOffsetKey$9;
var Keys$4 = {
  BACKSPACE: 8,
  TAB: 9,
  RETURN: 13,
  ALT: 18,
  ESC: 27,
  SPACE: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  DELETE: 46,
  COMMA: 188,
  PERIOD: 190,
  A: 65,
  Z: 90,
  ZERO: 48,
  NUMPAD_0: 96,
  NUMPAD_9: 105
};
var DraftJsDebugLogging$2 = {
  logBlockedSelectionEvent: function logBlockedSelectionEvent() {
    return null;
  },
  logSelectionStateFailure: function logSelectionStateFailure() {
    return null;
  }
};
function isHTMLElement$5(node) {
  if (!node || !node.ownerDocument) {
    return false;
  }
  if (!node.ownerDocument.defaultView) {
    return node instanceof HTMLElement;
  }
  if (node instanceof node.ownerDocument.defaultView.HTMLElement) {
    return true;
  }
  return false;
}
var isHTMLElement_1 = isHTMLElement$5;
var invariant$h = invariant_1;
var isHTMLElement$4 = isHTMLElement_1;
function getContentEditableContainer$2(editor) {
  var editorNode = editor.editorContainer;
  !editorNode ? invariant$h(false) : void 0;
  !isHTMLElement$4(editorNode.firstChild) ? invariant$h(false) : void 0;
  var htmlElement = editorNode.firstChild;
  return htmlElement;
}
var getContentEditableContainer_1 = getContentEditableContainer$2;
var DraftOffsetKey$8 = DraftOffsetKey_1;
var nullthrows$c = nullthrows_1;
function getUpdatedSelectionState$2(editorState, anchorKey, anchorOffset, focusKey, focusOffset) {
  var selection = nullthrows$c(editorState.getSelection());
  if (!anchorKey || !focusKey) {
    return selection;
  }
  var anchorPath = DraftOffsetKey$8.decode(anchorKey);
  var anchorBlockKey = anchorPath.blockKey;
  var anchorLeafBlockTree = editorState.getBlockTree(anchorBlockKey);
  var anchorLeaf = anchorLeafBlockTree && anchorLeafBlockTree.getIn([anchorPath.decoratorKey, "leaves", anchorPath.leafKey]);
  var focusPath = DraftOffsetKey$8.decode(focusKey);
  var focusBlockKey = focusPath.blockKey;
  var focusLeafBlockTree = editorState.getBlockTree(focusBlockKey);
  var focusLeaf = focusLeafBlockTree && focusLeafBlockTree.getIn([focusPath.decoratorKey, "leaves", focusPath.leafKey]);
  if (!anchorLeaf || !focusLeaf) {
    return selection;
  }
  var anchorLeafStart = anchorLeaf.get("start");
  var focusLeafStart = focusLeaf.get("start");
  var anchorBlockOffset = anchorLeaf ? anchorLeafStart + anchorOffset : null;
  var focusBlockOffset = focusLeaf ? focusLeafStart + focusOffset : null;
  var areEqual3 = selection.getAnchorKey() === anchorBlockKey && selection.getAnchorOffset() === anchorBlockOffset && selection.getFocusKey() === focusBlockKey && selection.getFocusOffset() === focusBlockOffset;
  if (areEqual3) {
    return selection;
  }
  var isBackward = false;
  if (anchorBlockKey === focusBlockKey) {
    var anchorLeafEnd = anchorLeaf.get("end");
    var focusLeafEnd = focusLeaf.get("end");
    if (focusLeafStart === anchorLeafStart && focusLeafEnd === anchorLeafEnd) {
      isBackward = focusOffset < anchorOffset;
    } else {
      isBackward = focusLeafStart < anchorLeafStart;
    }
  } else {
    var startKey = editorState.getCurrentContent().getBlockMap().keySeq().skipUntil(function(v) {
      return v === anchorBlockKey || v === focusBlockKey;
    }).first();
    isBackward = startKey === focusBlockKey;
  }
  return selection.merge({
    anchorKey: anchorBlockKey,
    anchorOffset: anchorBlockOffset,
    focusKey: focusBlockKey,
    focusOffset: focusBlockOffset,
    isBackward
  });
}
var getUpdatedSelectionState_1 = getUpdatedSelectionState$2;
var findAncestorOffsetKey$2 = findAncestorOffsetKey_1;
var getSelectionOffsetKeyForNode = getSelectionOffsetKeyForNode_1;
var getUpdatedSelectionState$1 = getUpdatedSelectionState_1;
var invariant$g = invariant_1;
var isElement$6 = isElement_1;
var nullthrows$b = nullthrows_1;
function getDraftEditorSelectionWithNodes$2(editorState, root2, anchorNode, anchorOffset, focusNode, focusOffset) {
  var anchorIsTextNode = anchorNode.nodeType === Node.TEXT_NODE;
  var focusIsTextNode = focusNode.nodeType === Node.TEXT_NODE;
  if (anchorIsTextNode && focusIsTextNode) {
    return {
      selectionState: getUpdatedSelectionState$1(editorState, nullthrows$b(findAncestorOffsetKey$2(anchorNode)), anchorOffset, nullthrows$b(findAncestorOffsetKey$2(focusNode)), focusOffset),
      needsRecovery: false
    };
  }
  var anchorPoint = null;
  var focusPoint = null;
  var needsRecovery = true;
  if (anchorIsTextNode) {
    anchorPoint = {
      key: nullthrows$b(findAncestorOffsetKey$2(anchorNode)),
      offset: anchorOffset
    };
    focusPoint = getPointForNonTextNode(root2, focusNode, focusOffset);
  } else if (focusIsTextNode) {
    focusPoint = {
      key: nullthrows$b(findAncestorOffsetKey$2(focusNode)),
      offset: focusOffset
    };
    anchorPoint = getPointForNonTextNode(root2, anchorNode, anchorOffset);
  } else {
    anchorPoint = getPointForNonTextNode(root2, anchorNode, anchorOffset);
    focusPoint = getPointForNonTextNode(root2, focusNode, focusOffset);
    if (anchorNode === focusNode && anchorOffset === focusOffset) {
      needsRecovery = !!anchorNode.firstChild && anchorNode.firstChild.nodeName !== "BR";
    }
  }
  return {
    selectionState: getUpdatedSelectionState$1(editorState, anchorPoint.key, anchorPoint.offset, focusPoint.key, focusPoint.offset),
    needsRecovery
  };
}
function getFirstLeaf(node) {
  while (node.firstChild && (isElement$6(node.firstChild) && node.firstChild.getAttribute("data-blocks") === "true" || getSelectionOffsetKeyForNode(node.firstChild))) {
    node = node.firstChild;
  }
  return node;
}
function getLastLeaf(node) {
  while (node.lastChild && (isElement$6(node.lastChild) && node.lastChild.getAttribute("data-blocks") === "true" || getSelectionOffsetKeyForNode(node.lastChild))) {
    node = node.lastChild;
  }
  return node;
}
function getPointForNonTextNode(editorRoot, startNode, childOffset) {
  var node = startNode;
  var offsetKey = findAncestorOffsetKey$2(node);
  !(offsetKey != null || editorRoot && (editorRoot === node || editorRoot.firstChild === node)) ? invariant$g(false) : void 0;
  if (editorRoot === node) {
    node = node.firstChild;
    !isElement$6(node) ? invariant$g(false) : void 0;
    var castedNode = node;
    node = castedNode;
    !(node.getAttribute("data-contents") === "true") ? invariant$g(false) : void 0;
    if (childOffset > 0) {
      childOffset = node.childNodes.length;
    }
  }
  if (childOffset === 0) {
    var key = null;
    if (offsetKey != null) {
      key = offsetKey;
    } else {
      var firstLeaf = getFirstLeaf(node);
      key = nullthrows$b(getSelectionOffsetKeyForNode(firstLeaf));
    }
    return {
      key,
      offset: 0
    };
  }
  var nodeBeforeCursor = node.childNodes[childOffset - 1];
  var leafKey = null;
  var textLength = null;
  if (!getSelectionOffsetKeyForNode(nodeBeforeCursor)) {
    leafKey = nullthrows$b(offsetKey);
    textLength = getTextContentLength(nodeBeforeCursor);
  } else {
    var lastLeaf = getLastLeaf(nodeBeforeCursor);
    leafKey = nullthrows$b(getSelectionOffsetKeyForNode(lastLeaf));
    textLength = getTextContentLength(lastLeaf);
  }
  return {
    key: leafKey,
    offset: textLength
  };
}
function getTextContentLength(node) {
  var textContent = node.textContent;
  return textContent === "\n" ? 0 : textContent.length;
}
var getDraftEditorSelectionWithNodes_1 = getDraftEditorSelectionWithNodes$2;
var getDraftEditorSelectionWithNodes$1 = getDraftEditorSelectionWithNodes_1;
function getDraftEditorSelection$2(editorState, root2) {
  var selection = root2.ownerDocument.defaultView.getSelection();
  var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset, rangeCount = selection.rangeCount;
  if (rangeCount === 0 || anchorNode == null || focusNode == null) {
    return {
      selectionState: editorState.getSelection().set("hasFocus", false),
      needsRecovery: false
    };
  }
  return getDraftEditorSelectionWithNodes$1(editorState, root2, anchorNode, anchorOffset, focusNode, focusOffset);
}
var getDraftEditorSelection_1 = getDraftEditorSelection$2;
var DraftJsDebugLogging$1 = DraftJsDebugLogging$2;
var EditorState$o = EditorState_1;
var getContentEditableContainer$1 = getContentEditableContainer_1;
var getDraftEditorSelection$1 = getDraftEditorSelection_1;
function editOnSelect$1(editor) {
  if (editor._blockSelectEvents || editor._latestEditorState !== editor.props.editorState) {
    if (editor._blockSelectEvents) {
      var _editorState = editor.props.editorState;
      var selectionState = _editorState.getSelection();
      DraftJsDebugLogging$1.logBlockedSelectionEvent({
        anonymizedDom: "N/A",
        extraParams: JSON.stringify({
          stacktrace: new Error().stack
        }),
        selectionState: JSON.stringify(selectionState.toJS())
      });
    }
    return;
  }
  var editorState = editor.props.editorState;
  var documentSelection = getDraftEditorSelection$1(editorState, getContentEditableContainer$1(editor));
  var updatedSelectionState = documentSelection.selectionState;
  if (updatedSelectionState !== editorState.getSelection()) {
    if (documentSelection.needsRecovery) {
      editorState = EditorState$o.forceSelection(editorState, updatedSelectionState);
    } else {
      editorState = EditorState$o.acceptSelection(editorState, updatedSelectionState);
    }
    editor.update(editorState);
  }
}
var editOnSelect_1 = editOnSelect$1;
function notEmptyKey$2(key) {
  return key != null && key != "";
}
var draftKeyUtils = {
  notEmptyKey: notEmptyKey$2
};
var _require$3 = draftKeyUtils, notEmptyKey$1 = _require$3.notEmptyKey;
function getEntityKeyForSelection$3(contentState, targetSelection) {
  var entityKey;
  if (targetSelection.isCollapsed()) {
    var key = targetSelection.getAnchorKey();
    var offset = targetSelection.getAnchorOffset();
    if (offset > 0) {
      entityKey = contentState.getBlockForKey(key).getEntityAt(offset - 1);
      if (entityKey !== contentState.getBlockForKey(key).getEntityAt(offset)) {
        return null;
      }
      return filterKey(contentState.getEntityMap(), entityKey);
    }
    return null;
  }
  var startKey = targetSelection.getStartKey();
  var startOffset = targetSelection.getStartOffset();
  var startBlock = contentState.getBlockForKey(startKey);
  entityKey = startOffset === startBlock.getLength() ? null : startBlock.getEntityAt(startOffset);
  return filterKey(contentState.getEntityMap(), entityKey);
}
function filterKey(entityMap, entityKey) {
  if (notEmptyKey$1(entityKey)) {
    var entity = entityMap.__get(entityKey);
    return entity.getMutability() === "MUTABLE" ? entityKey : null;
  }
  return null;
}
var getEntityKeyForSelection_1 = getEntityKeyForSelection$3;
var DOMObserver = DOMObserver_1;
var DraftModifier$c = DraftModifier_1;
var DraftOffsetKey$7 = DraftOffsetKey_1;
var EditorState$n = EditorState_1;
var Keys$3 = Keys$4;
var UserAgent$c = UserAgent_1;
var editOnSelect = editOnSelect_1;
var getContentEditableContainer = getContentEditableContainer_1;
var getDraftEditorSelection = getDraftEditorSelection_1;
var getEntityKeyForSelection$2 = getEntityKeyForSelection_1;
var nullthrows$a = nullthrows_1;
var isIE$2 = UserAgent$c.isBrowser("IE");
var RESOLVE_DELAY = 20;
var resolved = false;
var stillComposing = false;
var domObserver = null;
function startDOMObserver(editor) {
  if (!domObserver) {
    domObserver = new DOMObserver(getContentEditableContainer(editor));
    domObserver.start();
  }
}
var DraftEditorCompositionHandler$1 = {
  onCompositionStart: function onCompositionStart(editor) {
    stillComposing = true;
    startDOMObserver(editor);
  },
  onCompositionEnd: function onCompositionEnd(editor) {
    resolved = false;
    stillComposing = false;
    setTimeout(function() {
      if (!resolved) {
        DraftEditorCompositionHandler$1.resolveComposition(editor);
      }
    }, RESOLVE_DELAY);
  },
  onSelect: editOnSelect,
  onKeyDown: function onKeyDown(editor, e) {
    if (!stillComposing) {
      DraftEditorCompositionHandler$1.resolveComposition(editor);
      editor._onKeyDown(e);
      return;
    }
    if (e.which === Keys$3.RIGHT || e.which === Keys$3.LEFT) {
      e.preventDefault();
    }
  },
  onKeyPress: function onKeyPress(_editor, e) {
    if (e.which === Keys$3.RETURN) {
      e.preventDefault();
    }
  },
  resolveComposition: function resolveComposition(editor) {
    if (stillComposing) {
      return;
    }
    var mutations = nullthrows$a(domObserver).stopAndFlushMutations();
    domObserver = null;
    resolved = true;
    var editorState = EditorState$n.set(editor._latestEditorState, {
      inCompositionMode: false
    });
    editor.exitCurrentMode();
    if (!mutations.size) {
      editor.update(editorState);
      return;
    }
    var contentState = editorState.getCurrentContent();
    mutations.forEach(function(composedChars, offsetKey) {
      var _DraftOffsetKey$decod = DraftOffsetKey$7.decode(offsetKey), blockKey = _DraftOffsetKey$decod.blockKey, decoratorKey = _DraftOffsetKey$decod.decoratorKey, leafKey = _DraftOffsetKey$decod.leafKey;
      var _editorState$getBlock = editorState.getBlockTree(blockKey).getIn([decoratorKey, "leaves", leafKey]), start = _editorState$getBlock.start, end = _editorState$getBlock.end;
      var replacementRange = editorState.getSelection().merge({
        anchorKey: blockKey,
        focusKey: blockKey,
        anchorOffset: start,
        focusOffset: end,
        isBackward: false
      });
      var entityKey = getEntityKeyForSelection$2(contentState, replacementRange);
      var currentStyle = contentState.getBlockForKey(blockKey).getInlineStyleAt(start);
      contentState = DraftModifier$c.replaceText(contentState, replacementRange, composedChars, currentStyle, entityKey);
      editorState = EditorState$n.set(editorState, {
        currentContent: contentState
      });
    });
    var documentSelection = getDraftEditorSelection(editorState, getContentEditableContainer(editor));
    var compositionEndSelectionState = documentSelection.selectionState;
    editor.restoreEditorDOM();
    var editorStateWithUpdatedSelection = isIE$2 ? EditorState$n.forceSelection(editorState, compositionEndSelectionState) : EditorState$n.acceptSelection(editorState, compositionEndSelectionState);
    editor.update(EditorState$n.push(editorStateWithUpdatedSelection, contentState, "insert-characters"));
  }
};
var DraftEditorCompositionHandler_1 = DraftEditorCompositionHandler$1;
var _createElement$3 = React$a.createElement;
function _inheritsLoose$9(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var DraftOffsetKey$6 = DraftOffsetKey_1;
var React$9 = React$a;
var UnicodeBidi$1 = UnicodeBidi_1;
var UnicodeBidiDirection$1 = UnicodeBidiDirection_1;
var DraftEditorDecoratedLeaves$1 = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$9(DraftEditorDecoratedLeaves2, _React$Component);
  function DraftEditorDecoratedLeaves2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = DraftEditorDecoratedLeaves2.prototype;
  _proto.render = function render() {
    var _this$props = this.props, block = _this$props.block, children = _this$props.children, contentState = _this$props.contentState, decorator2 = _this$props.decorator, decoratorKey = _this$props.decoratorKey, direction = _this$props.direction, leafSet = _this$props.leafSet, text = _this$props.text;
    var blockKey = block.getKey();
    var leavesForLeafSet = leafSet.get("leaves");
    var DecoratorComponent = decorator2.getComponentForKey(decoratorKey);
    var decoratorProps = decorator2.getPropsForKey(decoratorKey);
    var decoratorOffsetKey = DraftOffsetKey$6.encode(blockKey, parseInt(decoratorKey, 10), 0);
    var decoratedText = text.slice(leavesForLeafSet.first().get("start"), leavesForLeafSet.last().get("end"));
    var dir = UnicodeBidiDirection$1.getHTMLDirIfDifferent(UnicodeBidi$1.getDirection(decoratedText), direction);
    return /* @__PURE__ */ _createElement$3(DecoratorComponent, __spreadProps(__spreadValues({}, decoratorProps), {
      contentState,
      decoratedText,
      dir,
      key: decoratorOffsetKey,
      entityKey: block.getEntityAt(leafSet.get("start")),
      offsetKey: decoratorOffsetKey
    }), children);
  };
  return DraftEditorDecoratedLeaves2;
}(React$9.Component);
var DraftEditorDecoratedLeaves_react = DraftEditorDecoratedLeaves$1;
var _jsx$8 = require$$0$1.jsx;
function _assertThisInitialized$4(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _inheritsLoose$8(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _defineProperty$e(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var React$8 = React$a;
var UserAgent$b = UserAgent_1;
var invariant$f = invariant_1;
var isElement$5 = isElement_1;
var useNewlineChar = UserAgent$b.isBrowser("IE <= 11");
function isNewline(node) {
  return useNewlineChar ? node.textContent === "\n" : node.tagName === "BR";
}
var NEWLINE_A = function NEWLINE_A2(ref) {
  return useNewlineChar ? /* @__PURE__ */ _jsx$8("span", {
    "data-text": "true",
    ref
  }, "A") : /* @__PURE__ */ _jsx$8("br", {
    "data-text": "true",
    ref
  }, "A");
};
var NEWLINE_B = function NEWLINE_B2(ref) {
  return useNewlineChar ? /* @__PURE__ */ _jsx$8("span", {
    "data-text": "true",
    ref
  }, "B") : /* @__PURE__ */ _jsx$8("br", {
    "data-text": "true",
    ref
  }, "B");
};
var DraftEditorTextNode$1 = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$8(DraftEditorTextNode2, _React$Component);
  function DraftEditorTextNode2(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    _defineProperty$e(_assertThisInitialized$4(_this), "_forceFlag", void 0);
    _defineProperty$e(_assertThisInitialized$4(_this), "_node", void 0);
    _this._forceFlag = false;
    return _this;
  }
  var _proto = DraftEditorTextNode2.prototype;
  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
    var node = this._node;
    var shouldBeNewline = nextProps.children === "";
    !isElement$5(node) ? invariant$f(false) : void 0;
    var elementNode = node;
    if (shouldBeNewline) {
      return !isNewline(elementNode);
    }
    return elementNode.textContent !== nextProps.children;
  };
  _proto.componentDidMount = function componentDidMount() {
    this._forceFlag = !this._forceFlag;
  };
  _proto.componentDidUpdate = function componentDidUpdate() {
    this._forceFlag = !this._forceFlag;
  };
  _proto.render = function render() {
    var _this2 = this;
    if (this.props.children === "") {
      return this._forceFlag ? NEWLINE_A(function(ref) {
        return _this2._node = ref;
      }) : NEWLINE_B(function(ref) {
        return _this2._node = ref;
      });
    }
    return /* @__PURE__ */ _jsx$8("span", {
      "data-text": "true",
      ref: function ref(_ref) {
        return _this2._node = _ref;
      },
      children: this.props.children
    }, this._forceFlag ? "A" : "B");
  };
  return DraftEditorTextNode2;
}(React$8.Component);
var DraftEditorTextNode_react = DraftEditorTextNode$1;
var isElement$4 = isElement_1;
function isHTMLBRElement$2(node) {
  if (!node || !node.ownerDocument) {
    return false;
  }
  return isElement$4(node) && node.nodeName === "BR";
}
var isHTMLBRElement_1 = isHTMLBRElement$2;
function isNode$2(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === "function" ? object instanceof defaultView.Node : typeof object === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string"));
}
var isNode_1 = isNode$2;
var isNode$1 = isNode_1;
function isTextNode$1(object) {
  return isNode$1(object) && object.nodeType == 3;
}
var isTextNode_1 = isTextNode$1;
var isTextNode = isTextNode_1;
function containsNode$3(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode$3(outerNode, innerNode.parentNode);
  } else if ("contains" in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}
var containsNode_1 = containsNode$3;
function getActiveElement$2(doc) {
  doc = doc || (typeof document !== "undefined" ? document : void 0);
  if (typeof doc === "undefined") {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}
var getActiveElement_1 = getActiveElement$2;
var DraftJsDebugLogging = DraftJsDebugLogging$2;
var UserAgent$a = UserAgent_1;
var containsNode$2 = containsNode_1;
var getActiveElement$1 = getActiveElement_1;
var getCorrectDocumentFromNode$2 = getCorrectDocumentFromNode_1;
var invariant$e = invariant_1;
var isElement$3 = isElement_1;
var isIE$1 = UserAgent$a.isBrowser("IE");
function getAnonymizedDOM(node, getNodeLabels) {
  if (!node) {
    return "[empty]";
  }
  var anonymized = anonymizeTextWithin(node, getNodeLabels);
  if (anonymized.nodeType === Node.TEXT_NODE) {
    return anonymized.textContent;
  }
  !isElement$3(anonymized) ? invariant$e(false) : void 0;
  var castedElement = anonymized;
  return castedElement.outerHTML;
}
function anonymizeTextWithin(node, getNodeLabels) {
  var labels = getNodeLabels !== void 0 ? getNodeLabels(node) : [];
  if (node.nodeType === Node.TEXT_NODE) {
    var length = node.textContent.length;
    return getCorrectDocumentFromNode$2(node).createTextNode("[text " + length + (labels.length ? " | " + labels.join(", ") : "") + "]");
  }
  var clone2 = node.cloneNode();
  if (clone2.nodeType === 1 && labels.length) {
    clone2.setAttribute("data-labels", labels.join(", "));
  }
  var childNodes = node.childNodes;
  for (var ii = 0; ii < childNodes.length; ii++) {
    clone2.appendChild(anonymizeTextWithin(childNodes[ii], getNodeLabels));
  }
  return clone2;
}
function getAnonymizedEditorDOM(node, getNodeLabels) {
  var currentNode = node;
  var castedNode = currentNode;
  while (currentNode) {
    if (isElement$3(currentNode) && castedNode.hasAttribute("contenteditable")) {
      return getAnonymizedDOM(currentNode, getNodeLabels);
    } else {
      currentNode = currentNode.parentNode;
      castedNode = currentNode;
    }
  }
  return "Could not find contentEditable parent of node";
}
function getNodeLength$1(node) {
  return node.nodeValue === null ? node.childNodes.length : node.nodeValue.length;
}
function setDraftEditorSelection$1(selectionState, node, blockKey, nodeStart, nodeEnd) {
  var documentObject = getCorrectDocumentFromNode$2(node);
  if (!containsNode$2(documentObject.documentElement, node)) {
    return;
  }
  var selection = documentObject.defaultView.getSelection();
  var anchorKey = selectionState.getAnchorKey();
  var anchorOffset = selectionState.getAnchorOffset();
  var focusKey = selectionState.getFocusKey();
  var focusOffset = selectionState.getFocusOffset();
  var isBackward = selectionState.getIsBackward();
  if (!selection.extend && isBackward) {
    var tempKey = anchorKey;
    var tempOffset = anchorOffset;
    anchorKey = focusKey;
    anchorOffset = focusOffset;
    focusKey = tempKey;
    focusOffset = tempOffset;
    isBackward = false;
  }
  var hasAnchor = anchorKey === blockKey && nodeStart <= anchorOffset && nodeEnd >= anchorOffset;
  var hasFocus = focusKey === blockKey && nodeStart <= focusOffset && nodeEnd >= focusOffset;
  if (hasAnchor && hasFocus) {
    selection.removeAllRanges();
    addPointToSelection(selection, node, anchorOffset - nodeStart, selectionState);
    addFocusToSelection(selection, node, focusOffset - nodeStart, selectionState);
    return;
  }
  if (!isBackward) {
    if (hasAnchor) {
      selection.removeAllRanges();
      addPointToSelection(selection, node, anchorOffset - nodeStart, selectionState);
    }
    if (hasFocus) {
      addFocusToSelection(selection, node, focusOffset - nodeStart, selectionState);
    }
  } else {
    if (hasFocus) {
      selection.removeAllRanges();
      addPointToSelection(selection, node, focusOffset - nodeStart, selectionState);
    }
    if (hasAnchor) {
      var storedFocusNode = selection.focusNode;
      var storedFocusOffset = selection.focusOffset;
      selection.removeAllRanges();
      addPointToSelection(selection, node, anchorOffset - nodeStart, selectionState);
      addFocusToSelection(selection, storedFocusNode, storedFocusOffset, selectionState);
    }
  }
}
function addFocusToSelection(selection, node, offset, selectionState) {
  var activeElement = getActiveElement$1();
  var extend = selection.extend;
  if (extend && node != null && containsNode$2(activeElement, node)) {
    if (offset > getNodeLength$1(node)) {
      DraftJsDebugLogging.logSelectionStateFailure({
        anonymizedDom: getAnonymizedEditorDOM(node),
        extraParams: JSON.stringify({
          offset
        }),
        selectionState: JSON.stringify(selectionState.toJS())
      });
    }
    var nodeWasFocus = node === selection.focusNode;
    try {
      if (selection.rangeCount > 0 && selection.extend) {
        selection.extend(node, offset);
      }
    } catch (e) {
      DraftJsDebugLogging.logSelectionStateFailure({
        anonymizedDom: getAnonymizedEditorDOM(node, function(n2) {
          var labels = [];
          if (n2 === activeElement) {
            labels.push("active element");
          }
          if (n2 === selection.anchorNode) {
            labels.push("selection anchor node");
          }
          if (n2 === selection.focusNode) {
            labels.push("selection focus node");
          }
          return labels;
        }),
        extraParams: JSON.stringify({
          activeElementName: activeElement ? activeElement.nodeName : null,
          nodeIsFocus: node === selection.focusNode,
          nodeWasFocus,
          selectionRangeCount: selection.rangeCount,
          selectionAnchorNodeName: selection.anchorNode ? selection.anchorNode.nodeName : null,
          selectionAnchorOffset: selection.anchorOffset,
          selectionFocusNodeName: selection.focusNode ? selection.focusNode.nodeName : null,
          selectionFocusOffset: selection.focusOffset,
          message: e ? "" + e : null,
          offset
        }, null, 2),
        selectionState: JSON.stringify(selectionState.toJS(), null, 2)
      });
      throw e;
    }
  } else {
    if (node && selection.rangeCount > 0) {
      var range = selection.getRangeAt(0);
      range.setEnd(node, offset);
      selection.addRange(range.cloneRange());
    }
  }
}
function addPointToSelection(selection, node, offset, selectionState) {
  var range = getCorrectDocumentFromNode$2(node).createRange();
  if (offset > getNodeLength$1(node)) {
    DraftJsDebugLogging.logSelectionStateFailure({
      anonymizedDom: getAnonymizedEditorDOM(node),
      extraParams: JSON.stringify({
        offset
      }),
      selectionState: JSON.stringify(selectionState.toJS())
    });
  }
  range.setStart(node, offset);
  if (isIE$1) {
    try {
      selection.addRange(range);
    } catch (e) {
    }
  } else {
    selection.addRange(range);
  }
}
var setDraftEditorSelection_1 = {
  setDraftEditorSelection: setDraftEditorSelection$1,
  addFocusToSelection
};
var _jsx$7 = require$$0$1.jsx;
var _assign = objectAssign;
function _assertThisInitialized$3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _inheritsLoose$7(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _defineProperty$d(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DraftEditorTextNode = DraftEditorTextNode_react;
var React$7 = React$a;
var invariant$d = invariant_1;
var isHTMLBRElement$1 = isHTMLBRElement_1;
var setDraftEditorSelection = setDraftEditorSelection_1.setDraftEditorSelection;
var DraftEditorLeaf$2 = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$7(DraftEditorLeaf2, _React$Component);
  function DraftEditorLeaf2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _defineProperty$d(_assertThisInitialized$3(_this), "leaf", void 0);
    return _this;
  }
  var _proto = DraftEditorLeaf2.prototype;
  _proto._setSelection = function _setSelection() {
    var selection = this.props.selection;
    if (selection == null || !selection.getHasFocus()) {
      return;
    }
    var _this$props = this.props, block = _this$props.block, start = _this$props.start, text = _this$props.text;
    var blockKey = block.getKey();
    var end = start + text.length;
    if (!selection.hasEdgeWithin(blockKey, start, end)) {
      return;
    }
    var node = this.leaf;
    !node ? invariant$d(false) : void 0;
    var child = node.firstChild;
    !child ? invariant$d(false) : void 0;
    var targetNode;
    if (child.nodeType === Node.TEXT_NODE) {
      targetNode = child;
    } else if (isHTMLBRElement$1(child)) {
      targetNode = node;
    } else {
      targetNode = child.firstChild;
      !targetNode ? invariant$d(false) : void 0;
    }
    setDraftEditorSelection(selection, targetNode, blockKey, start, end);
  };
  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
    var leafNode = this.leaf;
    !leafNode ? invariant$d(false) : void 0;
    var shouldUpdate = leafNode.textContent !== nextProps.text || nextProps.styleSet !== this.props.styleSet || nextProps.forceSelection;
    return shouldUpdate;
  };
  _proto.componentDidUpdate = function componentDidUpdate() {
    this._setSelection();
  };
  _proto.componentDidMount = function componentDidMount() {
    this._setSelection();
  };
  _proto.render = function render() {
    var _this2 = this;
    var block = this.props.block;
    var text = this.props.text;
    if (text.endsWith("\n") && this.props.isLast) {
      text += "\n";
    }
    var _this$props2 = this.props, customStyleMap = _this$props2.customStyleMap, customStyleFn = _this$props2.customStyleFn, offsetKey = _this$props2.offsetKey, styleSet = _this$props2.styleSet;
    var styleObj = styleSet.reduce(function(map2, styleName) {
      var mergedStyles = {};
      var style = customStyleMap[styleName];
      if (style !== void 0 && map2.textDecoration !== style.textDecoration) {
        mergedStyles.textDecoration = [map2.textDecoration, style.textDecoration].join(" ").trim();
      }
      return _assign(map2, style, mergedStyles);
    }, {});
    if (customStyleFn) {
      var newStyles = customStyleFn(styleSet, block);
      styleObj = _assign(styleObj, newStyles);
    }
    return /* @__PURE__ */ _jsx$7("span", {
      "data-offset-key": offsetKey,
      ref: function ref(_ref) {
        return _this2.leaf = _ref;
      },
      style: styleObj,
      children: /* @__PURE__ */ _jsx$7(DraftEditorTextNode, {
        children: text
      })
    });
  };
  return DraftEditorLeaf2;
}(React$7.Component);
var DraftEditorLeaf_react = DraftEditorLeaf$2;
var _jsx$6 = require$$0$1.jsx;
function _inheritsLoose$6(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var DraftEditorDecoratedLeaves = DraftEditorDecoratedLeaves_react;
var DraftEditorLeaf$1 = DraftEditorLeaf_react;
var DraftOffsetKey$5 = DraftOffsetKey_1;
var Immutable$4 = immutable$1.exports;
var React$6 = React$a;
var cx$5 = cx_1;
Immutable$4.List;
var DraftEditorNode$1 = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$6(DraftEditorNode2, _React$Component);
  function DraftEditorNode2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = DraftEditorNode2.prototype;
  _proto.render = function render() {
    var _this$props = this.props, block = _this$props.block, contentState = _this$props.contentState, customStyleFn = _this$props.customStyleFn, customStyleMap = _this$props.customStyleMap, decorator2 = _this$props.decorator, direction = _this$props.direction, forceSelection2 = _this$props.forceSelection, hasSelection = _this$props.hasSelection, selection = _this$props.selection, tree = _this$props.tree;
    var blockKey = block.getKey();
    var text = block.getText();
    var lastLeafSet = tree.size - 1;
    var children = this.props.children || tree.map(function(leafSet, ii) {
      var decoratorKey = leafSet.get("decoratorKey");
      var leavesForLeafSet = leafSet.get("leaves");
      var lastLeaf = leavesForLeafSet.size - 1;
      var Leaves = leavesForLeafSet.map(function(leaf, jj) {
        var offsetKey = DraftOffsetKey$5.encode(blockKey, ii, jj);
        var start = leaf.get("start");
        var end = leaf.get("end");
        return /* @__PURE__ */ _jsx$6(DraftEditorLeaf$1, {
          offsetKey,
          block,
          start,
          selection: hasSelection ? selection : null,
          forceSelection: forceSelection2,
          text: text.slice(start, end),
          styleSet: block.getInlineStyleAt(start),
          customStyleMap,
          customStyleFn,
          isLast: decoratorKey === lastLeafSet && jj === lastLeaf
        }, offsetKey);
      }).toArray();
      if (!decoratorKey || !decorator2) {
        return Leaves;
      }
      return /* @__PURE__ */ _jsx$6(DraftEditorDecoratedLeaves, {
        block,
        children: Leaves,
        contentState,
        decorator: decorator2,
        decoratorKey,
        direction,
        leafSet,
        text
      }, ii);
    }).toArray();
    return /* @__PURE__ */ _jsx$6("div", {
      "data-offset-key": DraftOffsetKey$5.encode(blockKey, 0, 0),
      className: cx$5({
        "public/DraftStyleDefault/block": true,
        "public/DraftStyleDefault/ltr": direction === "LTR",
        "public/DraftStyleDefault/rtl": direction === "RTL"
      }),
      children
    });
  };
  return DraftEditorNode2;
}(React$6.Component);
var DraftEditorNode_react = DraftEditorNode$1;
function _isViewportScrollElement(element, doc) {
  return !!doc && (element === doc.documentElement || element === doc.body);
}
var Scroll$3 = {
  getTop: function getTop(element) {
    var doc = element.ownerDocument;
    return _isViewportScrollElement(element, doc) ? doc.body.scrollTop || doc.documentElement.scrollTop : element.scrollTop;
  },
  setTop: function setTop(element, newTop) {
    var doc = element.ownerDocument;
    if (_isViewportScrollElement(element, doc)) {
      doc.body.scrollTop = doc.documentElement.scrollTop = newTop;
    } else {
      element.scrollTop = newTop;
    }
  },
  getLeft: function getLeft(element) {
    var doc = element.ownerDocument;
    return _isViewportScrollElement(element, doc) ? doc.body.scrollLeft || doc.documentElement.scrollLeft : element.scrollLeft;
  },
  setLeft: function setLeft(element, newLeft) {
    var doc = element.ownerDocument;
    if (_isViewportScrollElement(element, doc)) {
      doc.body.scrollLeft = doc.documentElement.scrollLeft = newLeft;
    } else {
      element.scrollLeft = newLeft;
    }
  }
};
var Scroll_1 = Scroll$3;
var _hyphenPattern = /-(.)/g;
function camelize$1(string) {
  return string.replace(_hyphenPattern, function(_, character) {
    return character.toUpperCase();
  });
}
var camelize_1 = camelize$1;
var _uppercasePattern = /([A-Z])/g;
function hyphenate$1(string) {
  return string.replace(_uppercasePattern, "-$1").toLowerCase();
}
var hyphenate_1 = hyphenate$1;
var camelize = camelize_1;
var hyphenate = hyphenate_1;
function asString(value) {
  return value == null ? value : String(value);
}
function getStyleProperty$1(node, name) {
  var computedStyle;
  if (window.getComputedStyle) {
    computedStyle = window.getComputedStyle(node, null);
    if (computedStyle) {
      return asString(computedStyle.getPropertyValue(hyphenate(name)));
    }
  }
  if (document.defaultView && document.defaultView.getComputedStyle) {
    computedStyle = document.defaultView.getComputedStyle(node, null);
    if (computedStyle) {
      return asString(computedStyle.getPropertyValue(hyphenate(name)));
    }
    if (name === "display") {
      return "none";
    }
  }
  if (node.currentStyle) {
    if (name === "float") {
      return asString(node.currentStyle.cssFloat || node.currentStyle.styleFloat);
    }
    return asString(node.currentStyle[camelize(name)]);
  }
  return asString(node.style && node.style[camelize(name)]);
}
var getStyleProperty_1 = getStyleProperty$1;
var getStyleProperty = getStyleProperty_1;
function _isNodeScrollable(element, name) {
  var overflow = Style$4.get(element, name);
  return overflow === "auto" || overflow === "scroll";
}
var Style$4 = {
  get: getStyleProperty,
  getScrollParent: function getScrollParent(node) {
    if (!node) {
      return null;
    }
    var ownerDocument = node.ownerDocument;
    while (node && node !== ownerDocument.body) {
      if (_isNodeScrollable(node, "overflow") || _isNodeScrollable(node, "overflowY") || _isNodeScrollable(node, "overflowX")) {
        return node;
      }
      node = node.parentNode;
    }
    return ownerDocument.defaultView || ownerDocument.parentWindow;
  }
};
var Style_1 = Style$4;
var containsNode$1 = containsNode_1;
function getElementRect$1(elem) {
  var docElem = elem.ownerDocument.documentElement;
  if (!("getBoundingClientRect" in elem) || !containsNode$1(docElem, elem)) {
    return {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
  }
  var rect = elem.getBoundingClientRect();
  return {
    left: Math.round(rect.left) - docElem.clientLeft,
    right: Math.round(rect.right) - docElem.clientLeft,
    top: Math.round(rect.top) - docElem.clientTop,
    bottom: Math.round(rect.bottom) - docElem.clientTop
  };
}
var getElementRect_1 = getElementRect$1;
var getElementRect = getElementRect_1;
function getElementPosition$2(element) {
  var rect = getElementRect(element);
  return {
    x: rect.left,
    y: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };
}
var getElementPosition_1 = getElementPosition$2;
var isWebkit = typeof navigator !== "undefined" && navigator.userAgent.indexOf("AppleWebKit") > -1;
function getDocumentScrollElement$1(doc) {
  doc = doc || document;
  if (doc.scrollingElement) {
    return doc.scrollingElement;
  }
  return !isWebkit && doc.compatMode === "CSS1Compat" ? doc.documentElement : doc.body;
}
var getDocumentScrollElement_1 = getDocumentScrollElement$1;
function getUnboundedScrollPosition$1(scrollable) {
  if (scrollable.Window && scrollable instanceof scrollable.Window) {
    return {
      x: scrollable.pageXOffset || scrollable.document.documentElement.scrollLeft,
      y: scrollable.pageYOffset || scrollable.document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}
var getUnboundedScrollPosition_1 = getUnboundedScrollPosition$1;
var getDocumentScrollElement = getDocumentScrollElement_1;
var getUnboundedScrollPosition = getUnboundedScrollPosition_1;
function getScrollPosition$4(scrollable) {
  var documentScrollElement = getDocumentScrollElement(scrollable.ownerDocument || scrollable.document);
  if (scrollable.Window && scrollable instanceof scrollable.Window) {
    scrollable = documentScrollElement;
  }
  var scrollPosition = getUnboundedScrollPosition(scrollable);
  var viewport = scrollable === documentScrollElement ? scrollable.ownerDocument.documentElement : scrollable;
  var xMax = scrollable.scrollWidth - viewport.clientWidth;
  var yMax = scrollable.scrollHeight - viewport.clientHeight;
  scrollPosition.x = Math.max(0, Math.min(scrollPosition.x, xMax));
  scrollPosition.y = Math.max(0, Math.min(scrollPosition.y, yMax));
  return scrollPosition;
}
var getScrollPosition_1 = getScrollPosition$4;
function getViewportWidth() {
  var width;
  if (document.documentElement) {
    width = document.documentElement.clientWidth;
  }
  if (!width && document.body) {
    width = document.body.clientWidth;
  }
  return width || 0;
}
function getViewportHeight() {
  var height;
  if (document.documentElement) {
    height = document.documentElement.clientHeight;
  }
  if (!height && document.body) {
    height = document.body.clientHeight;
  }
  return height || 0;
}
function getViewportDimensions$2() {
  return {
    width: window.innerWidth || getViewportWidth(),
    height: window.innerHeight || getViewportHeight()
  };
}
getViewportDimensions$2.withoutScrollbars = function() {
  return {
    width: getViewportWidth(),
    height: getViewportHeight()
  };
};
var getViewportDimensions_1 = getViewportDimensions$2;
var _jsx$5 = require$$0$1.jsx;
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _inheritsLoose$5(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _objectSpread$9(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty$c(target, key, source[key]);
    });
  }
  return target;
}
function _defineProperty$c(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DraftEditorNode = DraftEditorNode_react;
var DraftOffsetKey$4 = DraftOffsetKey_1;
var React$5 = React$a;
var Scroll$2 = Scroll_1;
var Style$3 = Style_1;
var getElementPosition$1 = getElementPosition_1;
var getScrollPosition$3 = getScrollPosition_1;
var getViewportDimensions$1 = getViewportDimensions_1;
var Immutable$3 = immutable$1.exports;
var invariant$c = invariant_1;
var isHTMLElement$3 = isHTMLElement_1;
var SCROLL_BUFFER$1 = 10;
Immutable$3.List;
var isBlockOnSelectionEdge$1 = function isBlockOnSelectionEdge(selection, key) {
  return selection.getAnchorKey() === key || selection.getFocusKey() === key;
};
var shouldNotAddWrapperElement = function shouldNotAddWrapperElement2(block, contentState) {
  var nextSiblingKey = block.getNextSiblingKey();
  return nextSiblingKey ? contentState.getBlockForKey(nextSiblingKey).getType() === block.getType() : false;
};
var applyWrapperElementToSiblings = function applyWrapperElementToSiblings2(wrapperTemplate, Element, nodes) {
  var wrappedSiblings = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = void 0;
  try {
    for (var _iterator = nodes.reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var sibling = _step.value;
      if (sibling.type !== Element) {
        break;
      }
      wrappedSiblings.push(sibling);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
  nodes.splice(nodes.indexOf(wrappedSiblings[0]), wrappedSiblings.length + 1);
  var childrenIs = wrappedSiblings.reverse();
  var key = childrenIs[0].key;
  nodes.push(React$5.cloneElement(wrapperTemplate, {
    key: "".concat(key, "-wrap"),
    "data-offset-key": DraftOffsetKey$4.encode(key, 0, 0)
  }, childrenIs));
  return nodes;
};
var getDraftRenderConfig = function getDraftRenderConfig2(block, blockRenderMap2) {
  var configForType = blockRenderMap2.get(block.getType()) || blockRenderMap2.get("unstyled");
  var wrapperTemplate = configForType.wrapper;
  var Element = configForType.element || blockRenderMap2.get("unstyled").element;
  return {
    Element,
    wrapperTemplate
  };
};
var getCustomRenderConfig = function getCustomRenderConfig2(block, blockRendererFn2) {
  var customRenderer = blockRendererFn2(block);
  if (!customRenderer) {
    return {};
  }
  var CustomComponent = customRenderer.component, customProps = customRenderer.props, customEditable = customRenderer.editable;
  return {
    CustomComponent,
    customProps,
    customEditable
  };
};
var getElementPropsConfig = function getElementPropsConfig2(block, editorKey, offsetKey, blockStyleFn2, customConfig, ref) {
  var elementProps = {
    "data-block": true,
    "data-editor": editorKey,
    "data-offset-key": offsetKey,
    key: block.getKey(),
    ref
  };
  var customClass = blockStyleFn2(block);
  if (customClass) {
    elementProps.className = customClass;
  }
  if (customConfig.customEditable !== void 0) {
    elementProps = _objectSpread$9({}, elementProps, {
      contentEditable: customConfig.customEditable,
      suppressContentEditableWarning: true
    });
  }
  return elementProps;
};
var DraftEditorBlockNode$1 = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$5(DraftEditorBlockNode2, _React$Component);
  function DraftEditorBlockNode2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _defineProperty$c(_assertThisInitialized$2(_this), "wrapperRef", React$5.createRef());
    return _this;
  }
  var _proto = DraftEditorBlockNode2.prototype;
  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
    var _this$props = this.props, block = _this$props.block, direction = _this$props.direction, tree = _this$props.tree;
    var isContainerNode = !block.getChildKeys().isEmpty();
    var blockHasChanged = block !== nextProps.block || tree !== nextProps.tree || direction !== nextProps.direction || isBlockOnSelectionEdge$1(nextProps.selection, nextProps.block.getKey()) && nextProps.forceSelection;
    return isContainerNode || blockHasChanged;
  };
  _proto.componentDidMount = function componentDidMount() {
    var selection = this.props.selection;
    var endKey = selection.getEndKey();
    if (!selection.getHasFocus() || endKey !== this.props.block.getKey()) {
      return;
    }
    var blockNode = this.wrapperRef.current;
    if (!blockNode) {
      return;
    }
    var scrollParent = Style$3.getScrollParent(blockNode);
    var scrollPosition = getScrollPosition$3(scrollParent);
    var scrollDelta;
    if (scrollParent === window) {
      var nodePosition = getElementPosition$1(blockNode);
      var nodeBottom = nodePosition.y + nodePosition.height;
      var viewportHeight = getViewportDimensions$1().height;
      scrollDelta = nodeBottom - viewportHeight;
      if (scrollDelta > 0) {
        window.scrollTo(scrollPosition.x, scrollPosition.y + scrollDelta + SCROLL_BUFFER$1);
      }
    } else {
      !isHTMLElement$3(blockNode) ? invariant$c(false) : void 0;
      var htmlBlockNode = blockNode;
      var blockBottom = htmlBlockNode.offsetHeight + htmlBlockNode.offsetTop;
      var scrollBottom = scrollParent.offsetHeight + scrollPosition.y;
      scrollDelta = blockBottom - scrollBottom;
      if (scrollDelta > 0) {
        Scroll$2.setTop(scrollParent, Scroll$2.getTop(scrollParent) + scrollDelta + SCROLL_BUFFER$1);
      }
    }
  };
  _proto.render = function render() {
    var _this2 = this;
    var _this$props2 = this.props, block = _this$props2.block, blockRenderMap2 = _this$props2.blockRenderMap, blockRendererFn2 = _this$props2.blockRendererFn, blockStyleFn2 = _this$props2.blockStyleFn, contentState = _this$props2.contentState, decorator2 = _this$props2.decorator, editorKey = _this$props2.editorKey, editorState = _this$props2.editorState, customStyleFn = _this$props2.customStyleFn, customStyleMap = _this$props2.customStyleMap, direction = _this$props2.direction, forceSelection2 = _this$props2.forceSelection, selection = _this$props2.selection, tree = _this$props2.tree;
    var children = null;
    if (block.children.size) {
      children = block.children.reduce(function(acc, key) {
        var offsetKey2 = DraftOffsetKey$4.encode(key, 0, 0);
        var child = contentState.getBlockForKey(key);
        var customConfig2 = getCustomRenderConfig(child, blockRendererFn2);
        var Component2 = customConfig2.CustomComponent || DraftEditorBlockNode2;
        var _getDraftRenderConfig = getDraftRenderConfig(child, blockRenderMap2), Element2 = _getDraftRenderConfig.Element, wrapperTemplate = _getDraftRenderConfig.wrapperTemplate;
        var elementProps2 = getElementPropsConfig(child, editorKey, offsetKey2, blockStyleFn2, customConfig2, null);
        var childProps = _objectSpread$9({}, _this2.props, {
          tree: editorState.getBlockTree(key),
          blockProps: customConfig2.customProps,
          offsetKey: offsetKey2,
          block: child
        });
        acc.push(/* @__PURE__ */ _jsx$5(Element2, __spreadProps(__spreadValues({}, elementProps2), {
          children: /* @__PURE__ */ _jsx$5(Component2, __spreadValues({}, childProps))
        })));
        if (!wrapperTemplate || shouldNotAddWrapperElement(child, contentState)) {
          return acc;
        }
        applyWrapperElementToSiblings(wrapperTemplate, Element2, acc);
        return acc;
      }, []);
    }
    var blockKey = block.getKey();
    var offsetKey = DraftOffsetKey$4.encode(blockKey, 0, 0);
    var customConfig = getCustomRenderConfig(block, blockRendererFn2);
    var Component = customConfig.CustomComponent;
    var blockNode = Component != null ? /* @__PURE__ */ _jsx$5(Component, __spreadProps(__spreadValues({}, this.props), {
      tree: editorState.getBlockTree(blockKey),
      blockProps: customConfig.customProps,
      offsetKey,
      block
    })) : /* @__PURE__ */ _jsx$5(DraftEditorNode, {
      block,
      children,
      contentState,
      customStyleFn,
      customStyleMap,
      decorator: decorator2,
      direction,
      forceSelection: forceSelection2,
      hasSelection: isBlockOnSelectionEdge$1(selection, blockKey),
      selection,
      tree
    });
    if (block.getParentKey()) {
      return blockNode;
    }
    var _getDraftRenderConfig2 = getDraftRenderConfig(block, blockRenderMap2), Element = _getDraftRenderConfig2.Element;
    var elementProps = getElementPropsConfig(block, editorKey, offsetKey, blockStyleFn2, customConfig, this.wrapperRef);
    return /* @__PURE__ */ _jsx$5(Element, __spreadProps(__spreadValues({}, elementProps), {
      children: blockNode
    }));
  };
  return DraftEditorBlockNode2;
}(React$5.Component);
var DraftEditorBlockNode_react = DraftEditorBlockNode$1;
var _jsx$4 = require$$0$1.jsx;
function _inheritsLoose$4(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var DraftEditorBlockNode = DraftEditorBlockNode_react;
var DraftOffsetKey$3 = DraftOffsetKey_1;
var React$4 = React$a;
var nullthrows$9 = nullthrows_1;
var DraftEditorContentsExperimental = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$4(DraftEditorContentsExperimental2, _React$Component);
  function DraftEditorContentsExperimental2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = DraftEditorContentsExperimental2.prototype;
  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
    var prevEditorState = this.props.editorState;
    var nextEditorState = nextProps.editorState;
    var prevDirectionMap = prevEditorState.getDirectionMap();
    var nextDirectionMap = nextEditorState.getDirectionMap();
    if (prevDirectionMap !== nextDirectionMap) {
      return true;
    }
    var didHaveFocus = prevEditorState.getSelection().getHasFocus();
    var nowHasFocus = nextEditorState.getSelection().getHasFocus();
    if (didHaveFocus !== nowHasFocus) {
      return true;
    }
    var nextNativeContent = nextEditorState.getNativelyRenderedContent();
    var wasComposing = prevEditorState.isInCompositionMode();
    var nowComposing = nextEditorState.isInCompositionMode();
    if (prevEditorState === nextEditorState || nextNativeContent !== null && nextEditorState.getCurrentContent() === nextNativeContent || wasComposing && nowComposing) {
      return false;
    }
    var prevContent = prevEditorState.getCurrentContent();
    var nextContent = nextEditorState.getCurrentContent();
    var prevDecorator = prevEditorState.getDecorator();
    var nextDecorator = nextEditorState.getDecorator();
    return wasComposing !== nowComposing || prevContent !== nextContent || prevDecorator !== nextDecorator || nextEditorState.mustForceSelection();
  };
  _proto.render = function render() {
    var _this$props = this.props, blockRenderMap2 = _this$props.blockRenderMap, blockRendererFn2 = _this$props.blockRendererFn, blockStyleFn2 = _this$props.blockStyleFn, customStyleMap = _this$props.customStyleMap, customStyleFn = _this$props.customStyleFn, editorState = _this$props.editorState, editorKey = _this$props.editorKey, textDirectionality = _this$props.textDirectionality;
    var content = editorState.getCurrentContent();
    var selection = editorState.getSelection();
    var forceSelection2 = editorState.mustForceSelection();
    var decorator2 = editorState.getDecorator();
    var directionMap = nullthrows$9(editorState.getDirectionMap());
    var blocksAsArray = content.getBlocksAsArray();
    var rootBlock = blocksAsArray[0];
    var processedBlocks = [];
    var nodeBlock = rootBlock;
    while (nodeBlock) {
      var blockKey = nodeBlock.getKey();
      var blockProps = {
        blockRenderMap: blockRenderMap2,
        blockRendererFn: blockRendererFn2,
        blockStyleFn: blockStyleFn2,
        contentState: content,
        customStyleFn,
        customStyleMap,
        decorator: decorator2,
        editorKey,
        editorState,
        forceSelection: forceSelection2,
        selection,
        block: nodeBlock,
        direction: textDirectionality ? textDirectionality : directionMap.get(blockKey),
        tree: editorState.getBlockTree(blockKey)
      };
      var configForType = blockRenderMap2.get(nodeBlock.getType()) || blockRenderMap2.get("unstyled");
      var wrapperTemplate = configForType.wrapper;
      processedBlocks.push({
        block: /* @__PURE__ */ _jsx$4(DraftEditorBlockNode, __spreadValues({}, blockProps), blockKey),
        wrapperTemplate,
        key: blockKey,
        offsetKey: DraftOffsetKey$3.encode(blockKey, 0, 0)
      });
      var nextBlockKey = nodeBlock.getNextSiblingKey();
      nodeBlock = nextBlockKey ? content.getBlockForKey(nextBlockKey) : null;
    }
    var outputBlocks = [];
    for (var ii = 0; ii < processedBlocks.length; ) {
      var info = processedBlocks[ii];
      if (info.wrapperTemplate) {
        var blocks = [];
        do {
          blocks.push(processedBlocks[ii].block);
          ii++;
        } while (ii < processedBlocks.length && processedBlocks[ii].wrapperTemplate === info.wrapperTemplate);
        var wrapperElement = React$4.cloneElement(info.wrapperTemplate, {
          key: info.key + "-wrap",
          "data-offset-key": info.offsetKey
        }, blocks);
        outputBlocks.push(wrapperElement);
      } else {
        outputBlocks.push(info.block);
        ii++;
      }
    }
    return /* @__PURE__ */ _jsx$4("div", {
      "data-contents": "true",
      children: outputBlocks
    });
  };
  return DraftEditorContentsExperimental2;
}(React$4.Component);
var DraftEditorContentsExperimental_react = DraftEditorContentsExperimental;
var _jsx$3 = require$$0$1.jsx;
var _createElement$2 = React$a.createElement;
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _inheritsLoose$3(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _defineProperty$b(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DraftEditorLeaf = DraftEditorLeaf_react;
var DraftOffsetKey$2 = DraftOffsetKey_1;
var React$3 = React$a;
var Scroll$1 = Scroll_1;
var Style$2 = Style_1;
var UnicodeBidi = UnicodeBidi_1;
var UnicodeBidiDirection = UnicodeBidiDirection_1;
var cx$4 = cx_1;
var getElementPosition = getElementPosition_1;
var getScrollPosition$2 = getScrollPosition_1;
var getViewportDimensions = getViewportDimensions_1;
var invariant$b = invariant_1;
var isHTMLElement$2 = isHTMLElement_1;
var nullthrows$8 = nullthrows_1;
var SCROLL_BUFFER = 10;
var isBlockOnSelectionEdge2 = function isBlockOnSelectionEdge3(selection, key) {
  return selection.getAnchorKey() === key || selection.getFocusKey() === key;
};
var DraftEditorBlock$2 = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$3(DraftEditorBlock2, _React$Component);
  function DraftEditorBlock2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _defineProperty$b(_assertThisInitialized$1(_this), "_node", void 0);
    return _this;
  }
  var _proto = DraftEditorBlock2.prototype;
  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
    return this.props.block !== nextProps.block || this.props.tree !== nextProps.tree || this.props.direction !== nextProps.direction || isBlockOnSelectionEdge2(nextProps.selection, nextProps.block.getKey()) && nextProps.forceSelection;
  };
  _proto.componentDidMount = function componentDidMount() {
    if (this.props.preventScroll) {
      return;
    }
    var selection = this.props.selection;
    var endKey = selection.getEndKey();
    if (!selection.getHasFocus() || endKey !== this.props.block.getKey()) {
      return;
    }
    var blockNode = this._node;
    if (blockNode == null) {
      return;
    }
    var scrollParent = Style$2.getScrollParent(blockNode);
    var scrollPosition = getScrollPosition$2(scrollParent);
    var scrollDelta;
    if (scrollParent === window) {
      var nodePosition = getElementPosition(blockNode);
      var nodeBottom = nodePosition.y + nodePosition.height;
      var viewportHeight = getViewportDimensions().height;
      scrollDelta = nodeBottom - viewportHeight;
      if (scrollDelta > 0) {
        window.scrollTo(scrollPosition.x, scrollPosition.y + scrollDelta + SCROLL_BUFFER);
      }
    } else {
      !isHTMLElement$2(blockNode) ? invariant$b(false) : void 0;
      var blockBottom = blockNode.offsetHeight + blockNode.offsetTop;
      var pOffset = scrollParent.offsetTop + scrollParent.offsetHeight;
      var scrollBottom = pOffset + scrollPosition.y;
      scrollDelta = blockBottom - scrollBottom;
      if (scrollDelta > 0) {
        Scroll$1.setTop(scrollParent, Scroll$1.getTop(scrollParent) + scrollDelta + SCROLL_BUFFER);
      }
    }
  };
  _proto._renderChildren = function _renderChildren() {
    var _this2 = this;
    var block = this.props.block;
    var blockKey = block.getKey();
    var text = block.getText();
    var lastLeafSet = this.props.tree.size - 1;
    var hasSelection = isBlockOnSelectionEdge2(this.props.selection, blockKey);
    return this.props.tree.map(function(leafSet, ii) {
      var leavesForLeafSet = leafSet.get("leaves");
      if (leavesForLeafSet.size === 0) {
        return null;
      }
      var lastLeaf = leavesForLeafSet.size - 1;
      var leaves = leavesForLeafSet.map(function(leaf, jj) {
        var offsetKey = DraftOffsetKey$2.encode(blockKey, ii, jj);
        var start2 = leaf.get("start");
        var end2 = leaf.get("end");
        return /* @__PURE__ */ _jsx$3(DraftEditorLeaf, {
          offsetKey,
          block,
          start: start2,
          selection: hasSelection ? _this2.props.selection : null,
          forceSelection: _this2.props.forceSelection,
          text: text.slice(start2, end2),
          styleSet: block.getInlineStyleAt(start2),
          customStyleMap: _this2.props.customStyleMap,
          customStyleFn: _this2.props.customStyleFn,
          isLast: ii === lastLeafSet && jj === lastLeaf
        }, offsetKey);
      }).toArray();
      var decoratorKey = leafSet.get("decoratorKey");
      if (decoratorKey == null) {
        return leaves;
      }
      if (!_this2.props.decorator) {
        return leaves;
      }
      var decorator2 = nullthrows$8(_this2.props.decorator);
      var DecoratorComponent = decorator2.getComponentForKey(decoratorKey);
      if (!DecoratorComponent) {
        return leaves;
      }
      var decoratorProps = decorator2.getPropsForKey(decoratorKey);
      var decoratorOffsetKey = DraftOffsetKey$2.encode(blockKey, ii, 0);
      var start = leavesForLeafSet.first().get("start");
      var end = leavesForLeafSet.last().get("end");
      var decoratedText = text.slice(start, end);
      var entityKey = block.getEntityAt(leafSet.get("start"));
      var dir = UnicodeBidiDirection.getHTMLDirIfDifferent(UnicodeBidi.getDirection(decoratedText), _this2.props.direction);
      var commonProps = {
        contentState: _this2.props.contentState,
        decoratedText,
        dir,
        start,
        end,
        blockKey,
        entityKey,
        offsetKey: decoratorOffsetKey
      };
      return /* @__PURE__ */ _createElement$2(DecoratorComponent, __spreadProps(__spreadValues(__spreadValues({}, decoratorProps), commonProps), {
        key: decoratorOffsetKey
      }), leaves);
    }).toArray();
  };
  _proto.render = function render() {
    var _this3 = this;
    var _this$props = this.props, direction = _this$props.direction, offsetKey = _this$props.offsetKey;
    var className = cx$4({
      "public/DraftStyleDefault/block": true,
      "public/DraftStyleDefault/ltr": direction === "LTR",
      "public/DraftStyleDefault/rtl": direction === "RTL"
    });
    return /* @__PURE__ */ _jsx$3("div", {
      "data-offset-key": offsetKey,
      className,
      ref: function ref(_ref) {
        return _this3._node = _ref;
      },
      children: this._renderChildren()
    });
  };
  return DraftEditorBlock2;
}(React$3.Component);
var DraftEditorBlock_react = DraftEditorBlock$2;
function joinClasses$1(className) {
  var newClassName = className || "";
  var argLength = arguments.length;
  if (argLength > 1) {
    for (var index = 1; index < argLength; index++) {
      var nextClass = arguments[index];
      if (nextClass) {
        newClassName = (newClassName ? newClassName + " " : "") + nextClass;
      }
    }
  }
  return newClassName;
}
var joinClasses_1 = joinClasses$1;
var _createElement$1 = React$a.createElement;
var _jsx$2 = require$$0$1.jsx;
function _objectSpread$8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty$a(target, key, source[key]);
    });
  }
  return target;
}
function _defineProperty$a(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inheritsLoose$2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var DraftEditorBlock$1 = DraftEditorBlock_react;
var DraftOffsetKey$1 = DraftOffsetKey_1;
var React$2 = React$a;
var cx$3 = cx_1;
var joinClasses = joinClasses_1;
var nullthrows$7 = nullthrows_1;
var getListItemClasses = function getListItemClasses2(type, depth, shouldResetCount, direction) {
  return cx$3({
    "public/DraftStyleDefault/unorderedListItem": type === "unordered-list-item",
    "public/DraftStyleDefault/orderedListItem": type === "ordered-list-item",
    "public/DraftStyleDefault/reset": shouldResetCount,
    "public/DraftStyleDefault/depth0": depth === 0,
    "public/DraftStyleDefault/depth1": depth === 1,
    "public/DraftStyleDefault/depth2": depth === 2,
    "public/DraftStyleDefault/depth3": depth === 3,
    "public/DraftStyleDefault/depth4": depth >= 4,
    "public/DraftStyleDefault/listLTR": direction === "LTR",
    "public/DraftStyleDefault/listRTL": direction === "RTL"
  });
};
var DraftEditorContents$1 = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$2(DraftEditorContents2, _React$Component);
  function DraftEditorContents2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = DraftEditorContents2.prototype;
  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
    var prevEditorState = this.props.editorState;
    var nextEditorState = nextProps.editorState;
    var prevDirectionMap = prevEditorState.getDirectionMap();
    var nextDirectionMap = nextEditorState.getDirectionMap();
    if (prevDirectionMap !== nextDirectionMap) {
      return true;
    }
    var didHaveFocus = prevEditorState.getSelection().getHasFocus();
    var nowHasFocus = nextEditorState.getSelection().getHasFocus();
    if (didHaveFocus !== nowHasFocus) {
      return true;
    }
    var nextNativeContent = nextEditorState.getNativelyRenderedContent();
    var wasComposing = prevEditorState.isInCompositionMode();
    var nowComposing = nextEditorState.isInCompositionMode();
    if (prevEditorState === nextEditorState || nextNativeContent !== null && nextEditorState.getCurrentContent() === nextNativeContent || wasComposing && nowComposing) {
      return false;
    }
    var prevContent = prevEditorState.getCurrentContent();
    var nextContent = nextEditorState.getCurrentContent();
    var prevDecorator = prevEditorState.getDecorator();
    var nextDecorator = nextEditorState.getDecorator();
    return wasComposing !== nowComposing || prevContent !== nextContent || prevDecorator !== nextDecorator || nextEditorState.mustForceSelection();
  };
  _proto.render = function render() {
    var _this$props = this.props, blockRenderMap2 = _this$props.blockRenderMap, blockRendererFn2 = _this$props.blockRendererFn, blockStyleFn2 = _this$props.blockStyleFn, customStyleMap = _this$props.customStyleMap, customStyleFn = _this$props.customStyleFn, editorState = _this$props.editorState, editorKey = _this$props.editorKey, preventScroll = _this$props.preventScroll, textDirectionality = _this$props.textDirectionality;
    var content = editorState.getCurrentContent();
    var selection = editorState.getSelection();
    var forceSelection2 = editorState.mustForceSelection();
    var decorator2 = editorState.getDecorator();
    var directionMap = nullthrows$7(editorState.getDirectionMap());
    var blocksAsArray = content.getBlocksAsArray();
    var processedBlocks = [];
    var currentDepth = null;
    var lastWrapperTemplate = null;
    for (var ii = 0; ii < blocksAsArray.length; ii++) {
      var _block = blocksAsArray[ii];
      var key = _block.getKey();
      var blockType = _block.getType();
      var customRenderer = blockRendererFn2(_block);
      var CustomComponent = void 0, customProps = void 0, customEditable = void 0;
      if (customRenderer) {
        CustomComponent = customRenderer.component;
        customProps = customRenderer.props;
        customEditable = customRenderer.editable;
      }
      var direction = textDirectionality ? textDirectionality : directionMap.get(key);
      var offsetKey = DraftOffsetKey$1.encode(key, 0, 0);
      var componentProps = {
        contentState: content,
        block: _block,
        blockProps: customProps,
        blockStyleFn: blockStyleFn2,
        customStyleMap,
        customStyleFn,
        decorator: decorator2,
        direction,
        forceSelection: forceSelection2,
        offsetKey,
        preventScroll,
        selection,
        tree: editorState.getBlockTree(key)
      };
      var configForType = blockRenderMap2.get(blockType) || blockRenderMap2.get("unstyled");
      var wrapperTemplate = configForType.wrapper;
      var Element = configForType.element || blockRenderMap2.get("unstyled").element;
      var depth = _block.getDepth();
      var _className = "";
      if (blockStyleFn2) {
        _className = blockStyleFn2(_block);
      }
      if (Element === "li") {
        var shouldResetCount = lastWrapperTemplate !== wrapperTemplate || currentDepth === null || depth > currentDepth;
        _className = joinClasses(_className, getListItemClasses(blockType, depth, shouldResetCount, direction));
      }
      var Component = CustomComponent || DraftEditorBlock$1;
      var childProps = {
        className: _className,
        "data-block": true,
        "data-editor": editorKey,
        "data-offset-key": offsetKey,
        key
      };
      if (customEditable !== void 0) {
        childProps = _objectSpread$8({}, childProps, {
          contentEditable: customEditable,
          suppressContentEditableWarning: true
        });
      }
      var child = /* @__PURE__ */ _jsx$2(Element, __spreadProps(__spreadValues({}, childProps), {
        children: /* @__PURE__ */ _createElement$1(Component, __spreadProps(__spreadValues({}, componentProps), {
          key
        }))
      }));
      processedBlocks.push({
        block: child,
        wrapperTemplate,
        key,
        offsetKey
      });
      if (wrapperTemplate) {
        currentDepth = _block.getDepth();
      } else {
        currentDepth = null;
      }
      lastWrapperTemplate = wrapperTemplate;
    }
    var outputBlocks = [];
    for (var _ii = 0; _ii < processedBlocks.length; ) {
      var info = processedBlocks[_ii];
      if (info.wrapperTemplate) {
        var blocks = [];
        do {
          blocks.push(processedBlocks[_ii].block);
          _ii++;
        } while (_ii < processedBlocks.length && processedBlocks[_ii].wrapperTemplate === info.wrapperTemplate);
        var wrapperElement = React$2.cloneElement(info.wrapperTemplate, {
          key: info.key + "-wrap",
          "data-offset-key": info.offsetKey
        }, blocks);
        outputBlocks.push(wrapperElement);
      } else {
        outputBlocks.push(info.block);
        _ii++;
      }
    }
    return /* @__PURE__ */ _jsx$2("div", {
      "data-contents": "true",
      children: outputBlocks
    });
  };
  return DraftEditorContents2;
}(React$2.Component);
var DraftEditorContentsCore_react = DraftEditorContents$1;
var gkx$5 = gkx$8;
var experimentalTreeDataSupport$4 = gkx$5("draft_tree_data_support");
var DraftEditorContents_react = experimentalTreeDataSupport$4 ? DraftEditorContentsExperimental_react : DraftEditorContentsCore_react;
var PhotosMimeType$1 = {
  isImage: function isImage(mimeString) {
    return getParts(mimeString)[0] === "image";
  },
  isJpeg: function isJpeg(mimeString) {
    var parts = getParts(mimeString);
    return PhotosMimeType$1.isImage(mimeString) && (parts[1] === "jpeg" || parts[1] === "pjpeg");
  }
};
function getParts(mimeString) {
  return mimeString.split("/");
}
var PhotosMimeType_1 = PhotosMimeType$1;
var invariant$a = invariant_1;
function toArray(obj) {
  var length = obj.length;
  !(!Array.isArray(obj) && (typeof obj === "object" || typeof obj === "function")) ? invariant$a(false) : void 0;
  !(typeof length === "number") ? invariant$a(false) : void 0;
  !(length === 0 || length - 1 in obj) ? invariant$a(false) : void 0;
  !(typeof obj.callee !== "function") ? invariant$a(false) : void 0;
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {
    }
  }
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}
function hasArrayNature(obj) {
  return !!obj && (typeof obj == "object" || typeof obj == "function") && "length" in obj && !("setInterval" in obj) && typeof obj.nodeType != "number" && (Array.isArray(obj) || "callee" in obj || "item" in obj);
}
function createArrayFromMixed$1(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray(obj);
  }
}
var createArrayFromMixed_1 = createArrayFromMixed$1;
function makeEmptyFunction(arg) {
  return function() {
    return arg;
  };
}
var emptyFunction$1 = function emptyFunction() {
};
emptyFunction$1.thatReturns = makeEmptyFunction;
emptyFunction$1.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction$1.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction$1.thatReturnsNull = makeEmptyFunction(null);
emptyFunction$1.thatReturnsThis = function() {
  return this;
};
emptyFunction$1.thatReturnsArgument = function(arg) {
  return arg;
};
var emptyFunction_1 = emptyFunction$1;
var PhotosMimeType = PhotosMimeType_1;
var createArrayFromMixed = createArrayFromMixed_1;
var emptyFunction2 = emptyFunction_1;
var CR_LF_REGEX = new RegExp("\r\n", "g");
var LF_ONLY = "\n";
var RICH_TEXT_TYPES = {
  "text/rtf": 1,
  "text/html": 1
};
function getFileFromDataTransfer(item) {
  if (item.kind == "file") {
    return item.getAsFile();
  }
}
var DataTransfer$2 = /* @__PURE__ */ function() {
  function DataTransfer2(data) {
    this.data = data;
    this.types = data.types ? createArrayFromMixed(data.types) : [];
  }
  var _proto = DataTransfer2.prototype;
  _proto.isRichText = function isRichText() {
    if (this.getHTML() && this.getText()) {
      return true;
    }
    if (this.isImage()) {
      return false;
    }
    return this.types.some(function(type) {
      return RICH_TEXT_TYPES[type];
    });
  };
  _proto.getText = function getText() {
    var text;
    if (this.data.getData) {
      if (!this.types.length) {
        text = this.data.getData("Text");
      } else if (this.types.indexOf("text/plain") != -1) {
        text = this.data.getData("text/plain");
      }
    }
    return text ? text.replace(CR_LF_REGEX, LF_ONLY) : null;
  };
  _proto.getHTML = function getHTML() {
    if (this.data.getData) {
      if (!this.types.length) {
        return this.data.getData("Text");
      } else if (this.types.indexOf("text/html") != -1) {
        return this.data.getData("text/html");
      }
    }
  };
  _proto.isLink = function isLink() {
    return this.types.some(function(type) {
      return type.indexOf("Url") != -1 || type.indexOf("text/uri-list") != -1 || type.indexOf("text/x-moz-url");
    });
  };
  _proto.getLink = function getLink() {
    if (this.data.getData) {
      if (this.types.indexOf("text/x-moz-url") != -1) {
        var url = this.data.getData("text/x-moz-url").split("\n");
        return url[0];
      }
      return this.types.indexOf("text/uri-list") != -1 ? this.data.getData("text/uri-list") : this.data.getData("url");
    }
    return null;
  };
  _proto.isImage = function isImage2() {
    var isImage3 = this.types.some(function(type2) {
      return type2.indexOf("application/x-moz-file") != -1;
    });
    if (isImage3) {
      return true;
    }
    var items = this.getFiles();
    for (var i = 0; i < items.length; i++) {
      var type = items[i].type;
      if (!PhotosMimeType.isImage(type)) {
        return false;
      }
    }
    return true;
  };
  _proto.getCount = function getCount() {
    if (this.data.hasOwnProperty("items")) {
      return this.data.items.length;
    } else if (this.data.hasOwnProperty("mozItemCount")) {
      return this.data.mozItemCount;
    } else if (this.data.files) {
      return this.data.files.length;
    }
    return null;
  };
  _proto.getFiles = function getFiles() {
    if (this.data.items) {
      return Array.prototype.slice.call(this.data.items).map(getFileFromDataTransfer).filter(emptyFunction2.thatReturnsArgument);
    } else if (this.data.files) {
      return Array.prototype.slice.call(this.data.files);
    } else {
      return [];
    }
  };
  _proto.hasFiles = function hasFiles() {
    return this.getFiles().length > 0;
  };
  return DataTransfer2;
}();
var DataTransfer_1 = DataTransfer$2;
var invariant$9 = invariant_1;
var TEXT_CLIPPING_REGEX = /\.textClipping$/;
var TEXT_TYPES = {
  "text/plain": true,
  "text/html": true,
  "text/rtf": true
};
var TEXT_SIZE_UPPER_BOUND = 5e3;
function getTextContentFromFiles$2(files, callback) {
  var readCount = 0;
  var results2 = [];
  files.forEach(function(file) {
    readFile(file, function(text) {
      readCount++;
      text && results2.push(text.slice(0, TEXT_SIZE_UPPER_BOUND));
      if (readCount == files.length) {
        callback(results2.join("\r"));
      }
    });
  });
}
function readFile(file, callback) {
  if (!commonjsGlobal.FileReader || file.type && !(file.type in TEXT_TYPES)) {
    callback("");
    return;
  }
  if (file.type === "") {
    var _contents = "";
    if (TEXT_CLIPPING_REGEX.test(file.name)) {
      _contents = file.name.replace(TEXT_CLIPPING_REGEX, "");
    }
    callback(_contents);
    return;
  }
  var reader = new FileReader();
  reader.onload = function() {
    var result = reader.result;
    !(typeof result === "string") ? invariant$9(false) : void 0;
    callback(result);
  };
  reader.onerror = function() {
    callback("");
  };
  reader.readAsText(file);
}
var getTextContentFromFiles_1 = getTextContentFromFiles$2;
function isEventHandled$4(value) {
  return value === "handled" || value === true;
}
var isEventHandled_1 = isEventHandled$4;
var DataTransfer$1 = DataTransfer_1;
var DraftModifier$b = DraftModifier_1;
var EditorState$m = EditorState_1;
var findAncestorOffsetKey$1 = findAncestorOffsetKey_1;
var getCorrectDocumentFromNode$1 = getCorrectDocumentFromNode_1;
var getTextContentFromFiles$1 = getTextContentFromFiles_1;
var getUpdatedSelectionState = getUpdatedSelectionState_1;
var getWindowForNode = getWindowForNode_1;
var isEventHandled$3 = isEventHandled_1;
var nullthrows$6 = nullthrows_1;
function getSelectionForEvent(event, editorState) {
  var node = null;
  var offset = null;
  var eventTargetDocument = getCorrectDocumentFromNode$1(event.currentTarget);
  if (typeof eventTargetDocument.caretRangeFromPoint === "function") {
    var dropRange = eventTargetDocument.caretRangeFromPoint(event.x, event.y);
    node = dropRange.startContainer;
    offset = dropRange.startOffset;
  } else if (event.rangeParent) {
    node = event.rangeParent;
    offset = event.rangeOffset;
  } else {
    return null;
  }
  node = nullthrows$6(node);
  offset = nullthrows$6(offset);
  var offsetKey = nullthrows$6(findAncestorOffsetKey$1(node));
  return getUpdatedSelectionState(editorState, offsetKey, offset, offsetKey, offset);
}
var DraftEditorDragHandler$1 = {
  onDragEnd: function onDragEnd(editor) {
    editor.exitCurrentMode();
    endDrag(editor);
  },
  onDrop: function onDrop(editor, e) {
    var data = new DataTransfer$1(e.nativeEvent.dataTransfer);
    var editorState = editor._latestEditorState;
    var dropSelection = getSelectionForEvent(e.nativeEvent, editorState);
    e.preventDefault();
    editor._dragCount = 0;
    editor.exitCurrentMode();
    if (dropSelection == null) {
      return;
    }
    var files = data.getFiles();
    if (files.length > 0) {
      if (editor.props.handleDroppedFiles && isEventHandled$3(editor.props.handleDroppedFiles(dropSelection, files))) {
        return;
      }
      getTextContentFromFiles$1(files, function(fileText) {
        fileText && editor.update(insertTextAtSelection(editorState, dropSelection, fileText));
      });
      return;
    }
    var dragType = editor._internalDrag ? "internal" : "external";
    if (editor.props.handleDrop && isEventHandled$3(editor.props.handleDrop(dropSelection, data, dragType)))
      ;
    else if (editor._internalDrag) {
      editor.update(moveText2(editorState, dropSelection));
    } else {
      editor.update(insertTextAtSelection(editorState, dropSelection, data.getText()));
    }
    endDrag(editor);
  }
};
function endDrag(editor) {
  editor._internalDrag = false;
  var editorNode = editor.editorContainer;
  if (editorNode) {
    var mouseUpEvent = new MouseEvent("mouseup", {
      view: getWindowForNode(editorNode),
      bubbles: true,
      cancelable: true
    });
    editorNode.dispatchEvent(mouseUpEvent);
  }
}
function moveText2(editorState, targetSelection) {
  var newContentState = DraftModifier$b.moveText(editorState.getCurrentContent(), editorState.getSelection(), targetSelection);
  return EditorState$m.push(editorState, newContentState, "insert-fragment");
}
function insertTextAtSelection(editorState, selection, text) {
  var newContentState = DraftModifier$b.insertText(editorState.getCurrentContent(), selection, text, editorState.getCurrentInlineStyle());
  return EditorState$m.push(editorState, newContentState, "insert-fragment");
}
var DraftEditorDragHandler_1 = DraftEditorDragHandler$1;
function isSelectionAtLeafStart$1(editorState) {
  var selection = editorState.getSelection();
  var anchorKey = selection.getAnchorKey();
  var blockTree = editorState.getBlockTree(anchorKey);
  var offset = selection.getStartOffset();
  var isAtStart = false;
  blockTree.some(function(leafSet) {
    if (offset === leafSet.get("start")) {
      isAtStart = true;
      return true;
    }
    if (offset < leafSet.get("end")) {
      return leafSet.get("leaves").some(function(leaf) {
        var leafStart = leaf.get("start");
        if (offset === leafStart) {
          isAtStart = true;
          return true;
        }
        return false;
      });
    }
    return false;
  });
  return isAtStart;
}
var isSelectionAtLeafStart_1 = isSelectionAtLeafStart$1;
(function(global2, undefined$12) {
  if (global2.setImmediate) {
    return;
  }
  var nextHandle = 1;
  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global2.document;
  var registerImmediate;
  function setImmediate2(callback) {
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    }
    var args = new Array(arguments.length - 1);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    }
    var task = {
      callback,
      args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }
  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }
  function run(task) {
    var callback = task.callback;
    var args = task.args;
    switch (args.length) {
      case 0:
        callback();
        break;
      case 1:
        callback(args[0]);
        break;
      case 2:
        callback(args[0], args[1]);
        break;
      case 3:
        callback(args[0], args[1], args[2]);
        break;
      default:
        callback.apply(undefined$12, args);
        break;
    }
  }
  function runIfPresent(handle) {
    if (currentlyRunningATask) {
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];
      if (task) {
        currentlyRunningATask = true;
        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }
  function installNextTickImplementation() {
    registerImmediate = function(handle) {
      process.nextTick(function() {
        runIfPresent(handle);
      });
    };
  }
  function canUsePostMessage() {
    if (global2.postMessage && !global2.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global2.onmessage;
      global2.onmessage = function() {
        postMessageIsAsynchronous = false;
      };
      global2.postMessage("", "*");
      global2.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }
  function installPostMessageImplementation() {
    var messagePrefix = "setImmediate$" + Math.random() + "$";
    var onGlobalMessage = function(event) {
      if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };
    if (global2.addEventListener) {
      global2.addEventListener("message", onGlobalMessage, false);
    } else {
      global2.attachEvent("onmessage", onGlobalMessage);
    }
    registerImmediate = function(handle) {
      global2.postMessage(messagePrefix + handle, "*");
    };
  }
  function installMessageChannelImplementation() {
    var channel = new MessageChannel();
    channel.port1.onmessage = function(event) {
      var handle = event.data;
      runIfPresent(handle);
    };
    registerImmediate = function(handle) {
      channel.port2.postMessage(handle);
    };
  }
  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;
    registerImmediate = function(handle) {
      var script = doc.createElement("script");
      script.onreadystatechange = function() {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };
      html.appendChild(script);
    };
  }
  function installSetTimeoutImplementation() {
    registerImmediate = function(handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  }
  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
  if ({}.toString.call(global2.process) === "[object process]") {
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    installPostMessageImplementation();
  } else if (global2.MessageChannel) {
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    installReadyStateChangeImplementation();
  } else {
    installSetTimeoutImplementation();
  }
  attachTo.setImmediate = setImmediate2;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof commonjsGlobal === "undefined" ? commonjsGlobal : commonjsGlobal : self);
var setImmediate$1 = commonjsGlobal.setImmediate;
var DraftModifier$a = DraftModifier_1;
var EditorState$l = EditorState_1;
var UserAgent$9 = UserAgent_1;
var getEntityKeyForSelection$1 = getEntityKeyForSelection_1;
var isEventHandled$2 = isEventHandled_1;
var isSelectionAtLeafStart = isSelectionAtLeafStart_1;
var nullthrows$5 = nullthrows_1;
var setImmediate = setImmediate$1;
var FF_QUICKFIND_CHAR = "'";
var FF_QUICKFIND_LINK_CHAR = "/";
var isFirefox$1 = UserAgent$9.isBrowser("Firefox");
function mustPreventDefaultForCharacter(character) {
  return isFirefox$1 && (character == FF_QUICKFIND_CHAR || character == FF_QUICKFIND_LINK_CHAR);
}
function replaceText2(editorState, text, inlineStyle, entityKey, forceSelection2) {
  var contentState = DraftModifier$a.replaceText(editorState.getCurrentContent(), editorState.getSelection(), text, inlineStyle, entityKey);
  return EditorState$l.push(editorState, contentState, "insert-characters", forceSelection2);
}
function editOnBeforeInput(editor, e) {
  if (editor._pendingStateFromBeforeInput !== void 0) {
    editor.update(editor._pendingStateFromBeforeInput);
    editor._pendingStateFromBeforeInput = void 0;
  }
  var editorState = editor._latestEditorState;
  var chars = e.data;
  if (!chars) {
    return;
  }
  if (editor.props.handleBeforeInput && isEventHandled$2(editor.props.handleBeforeInput(chars, editorState, e.timeStamp))) {
    e.preventDefault();
    return;
  }
  var selection = editorState.getSelection();
  var selectionStart = selection.getStartOffset();
  var anchorKey = selection.getAnchorKey();
  if (!selection.isCollapsed()) {
    e.preventDefault();
    editor.update(replaceText2(editorState, chars, editorState.getCurrentInlineStyle(), getEntityKeyForSelection$1(editorState.getCurrentContent(), editorState.getSelection()), true));
    return;
  }
  var newEditorState = replaceText2(editorState, chars, editorState.getCurrentInlineStyle(), getEntityKeyForSelection$1(editorState.getCurrentContent(), editorState.getSelection()), false);
  var mustPreventNative = false;
  if (!mustPreventNative) {
    mustPreventNative = isSelectionAtLeafStart(editor._latestCommittedEditorState);
  }
  if (!mustPreventNative) {
    var oldBlockTree = editorState.getBlockTree(anchorKey);
    var newBlockTree = newEditorState.getBlockTree(anchorKey);
    mustPreventNative = oldBlockTree.size !== newBlockTree.size || oldBlockTree.zip(newBlockTree).some(function(_ref) {
      var oldLeafSet = _ref[0], newLeafSet = _ref[1];
      var oldStart = oldLeafSet.get("start");
      var adjustedStart = oldStart + (oldStart >= selectionStart ? chars.length : 0);
      var oldEnd = oldLeafSet.get("end");
      var adjustedEnd = oldEnd + (oldEnd >= selectionStart ? chars.length : 0);
      var newStart = newLeafSet.get("start");
      var newEnd = newLeafSet.get("end");
      var newDecoratorKey = newLeafSet.get("decoratorKey");
      return oldLeafSet.get("decoratorKey") !== newDecoratorKey || oldLeafSet.get("leaves").size !== newLeafSet.get("leaves").size || adjustedStart !== newStart || adjustedEnd !== newEnd || newDecoratorKey != null && newEnd - newStart !== oldEnd - oldStart;
    });
  }
  if (!mustPreventNative) {
    mustPreventNative = mustPreventDefaultForCharacter(chars);
  }
  if (!mustPreventNative) {
    mustPreventNative = nullthrows$5(newEditorState.getDirectionMap()).get(anchorKey) !== nullthrows$5(editorState.getDirectionMap()).get(anchorKey);
  }
  if (mustPreventNative) {
    e.preventDefault();
    newEditorState = EditorState$l.set(newEditorState, {
      forceSelection: true
    });
    editor.update(newEditorState);
    return;
  }
  newEditorState = EditorState$l.set(newEditorState, {
    nativelyRenderedContent: newEditorState.getCurrentContent()
  });
  editor._pendingStateFromBeforeInput = newEditorState;
  setImmediate(function() {
    if (editor._pendingStateFromBeforeInput !== void 0) {
      editor.update(editor._pendingStateFromBeforeInput);
      editor._pendingStateFromBeforeInput = void 0;
    }
  });
}
var editOnBeforeInput_1 = editOnBeforeInput;
var EditorState$k = EditorState_1;
var containsNode = containsNode_1;
var getActiveElement = getActiveElement_1;
function editOnBlur(editor, e) {
  var ownerDocument = e.currentTarget.ownerDocument;
  if (!Boolean(editor.props.preserveSelectionOnBlur) && getActiveElement(ownerDocument) === ownerDocument.body) {
    var _selection = ownerDocument.defaultView.getSelection();
    var editorNode = editor.editor;
    if (_selection.rangeCount === 1 && containsNode(editorNode, _selection.anchorNode) && containsNode(editorNode, _selection.focusNode)) {
      _selection.removeAllRanges();
    }
  }
  var editorState = editor._latestEditorState;
  var currentSelection = editorState.getSelection();
  if (!currentSelection.getHasFocus()) {
    return;
  }
  var selection = currentSelection.set("hasFocus", false);
  editor.props.onBlur && editor.props.onBlur(e);
  editor.update(EditorState$k.acceptSelection(editorState, selection));
}
var editOnBlur_1 = editOnBlur;
var EditorState$j = EditorState_1;
function editOnCompositionStart(editor, e) {
  editor.setMode("composite");
  editor.update(EditorState$j.set(editor._latestEditorState, {
    inCompositionMode: true
  }));
  editor._onCompositionStart(e);
}
var editOnCompositionStart_1 = editOnCompositionStart;
var getContentStateFragment$2 = getContentStateFragment_1;
function getFragmentFromSelection$2(editorState) {
  var selectionState = editorState.getSelection();
  if (selectionState.isCollapsed()) {
    return null;
  }
  return getContentStateFragment$2(editorState.getCurrentContent(), selectionState);
}
var getFragmentFromSelection_1 = getFragmentFromSelection$2;
var getFragmentFromSelection$1 = getFragmentFromSelection_1;
function editOnCopy(editor, e) {
  var editorState = editor._latestEditorState;
  var selection = editorState.getSelection();
  if (selection.isCollapsed()) {
    e.preventDefault();
    return;
  }
  editor.setClipboard(getFragmentFromSelection$1(editor._latestEditorState));
}
var editOnCopy_1 = editOnCopy;
function isInstanceOfNode(target) {
  if (!target || !("ownerDocument" in target)) {
    return false;
  }
  if ("ownerDocument" in target) {
    var node = target;
    if (!node.ownerDocument.defaultView) {
      return node instanceof Node;
    }
    if (node instanceof node.ownerDocument.defaultView.Node) {
      return true;
    }
  }
  return false;
}
var isInstanceOfNode_1 = isInstanceOfNode;
var DraftModifier$9 = DraftModifier_1;
var EditorState$i = EditorState_1;
var Style$1 = Style_1;
var getFragmentFromSelection = getFragmentFromSelection_1;
var getScrollPosition$1 = getScrollPosition_1;
var isNode = isInstanceOfNode_1;
function editOnCut(editor, e) {
  var editorState = editor._latestEditorState;
  var selection = editorState.getSelection();
  var element = e.target;
  var scrollPosition;
  if (selection.isCollapsed()) {
    e.preventDefault();
    return;
  }
  if (isNode(element)) {
    var node = element;
    scrollPosition = getScrollPosition$1(Style$1.getScrollParent(node));
  }
  var fragment = getFragmentFromSelection(editorState);
  editor.setClipboard(fragment);
  editor.setMode("cut");
  setTimeout(function() {
    editor.restoreEditorDOM(scrollPosition);
    editor.exitCurrentMode();
    editor.update(removeFragment(editorState));
  }, 0);
}
function removeFragment(editorState) {
  var newContent = DraftModifier$9.removeRange(editorState.getCurrentContent(), editorState.getSelection(), "forward");
  return EditorState$i.push(editorState, newContent, "remove-range");
}
var editOnCut_1 = editOnCut;
function editOnDragOver(editor, e) {
  editor.setMode("drag");
  e.preventDefault();
}
var editOnDragOver_1 = editOnDragOver;
function editOnDragStart(editor) {
  editor._internalDrag = true;
  editor.setMode("drag");
}
var editOnDragStart_1 = editOnDragStart;
var EditorState$h = EditorState_1;
var UserAgent$8 = UserAgent_1;
function editOnFocus(editor, e) {
  var editorState = editor._latestEditorState;
  var currentSelection = editorState.getSelection();
  if (currentSelection.getHasFocus()) {
    return;
  }
  var selection = currentSelection.set("hasFocus", true);
  editor.props.onFocus && editor.props.onFocus(e);
  if (UserAgent$8.isBrowser("Chrome < 60.0.3081.0")) {
    editor.update(EditorState$h.forceSelection(editorState, selection));
  } else {
    editor.update(EditorState$h.acceptSelection(editorState, selection));
  }
}
var editOnFocus_1 = editOnFocus;
var invariant$8 = invariant_1;
var SURROGATE_HIGH_START = 55296;
var SURROGATE_HIGH_END = 56319;
var SURROGATE_LOW_START = 56320;
var SURROGATE_LOW_END = 57343;
var SURROGATE_UNITS_REGEX = /[\uD800-\uDFFF]/;
function isCodeUnitInSurrogateRange(codeUnit) {
  return SURROGATE_HIGH_START <= codeUnit && codeUnit <= SURROGATE_LOW_END;
}
function isSurrogatePair(str, index) {
  !(0 <= index && index < str.length) ? invariant$8(false) : void 0;
  if (index + 1 === str.length) {
    return false;
  }
  var first3 = str.charCodeAt(index);
  var second = str.charCodeAt(index + 1);
  return SURROGATE_HIGH_START <= first3 && first3 <= SURROGATE_HIGH_END && SURROGATE_LOW_START <= second && second <= SURROGATE_LOW_END;
}
function hasSurrogateUnit(str) {
  return SURROGATE_UNITS_REGEX.test(str);
}
function getUTF16Length(str, pos) {
  return 1 + isCodeUnitInSurrogateRange(str.charCodeAt(pos));
}
function strlen$1(str) {
  if (!hasSurrogateUnit(str)) {
    return str.length;
  }
  var len = 0;
  for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {
    len++;
  }
  return len;
}
function substr$2(str, start, length) {
  start = start || 0;
  length = length === void 0 ? Infinity : length || 0;
  if (!hasSurrogateUnit(str)) {
    return str.substr(start, length);
  }
  var size = str.length;
  if (size <= 0 || start > size || length <= 0) {
    return "";
  }
  var posA = 0;
  if (start > 0) {
    for (; start > 0 && posA < size; start--) {
      posA += getUTF16Length(str, posA);
    }
    if (posA >= size) {
      return "";
    }
  } else if (start < 0) {
    for (posA = size; start < 0 && 0 < posA; start++) {
      posA -= getUTF16Length(str, posA - 1);
    }
    if (posA < 0) {
      posA = 0;
    }
  }
  var posB = size;
  if (length < size) {
    for (posB = posA; length > 0 && posB < size; length--) {
      posB += getUTF16Length(str, posB);
    }
  }
  return str.substring(posA, posB);
}
function substring(str, start, end) {
  start = start || 0;
  end = end === void 0 ? Infinity : end || 0;
  if (start < 0) {
    start = 0;
  }
  if (end < 0) {
    end = 0;
  }
  var length = Math.abs(end - start);
  start = start < end ? start : end;
  return substr$2(str, start, length);
}
function getCodePoints(str) {
  var codePoints = [];
  for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {
    codePoints.push(str.codePointAt(pos));
  }
  return codePoints;
}
var UnicodeUtils$7 = {
  getCodePoints,
  getUTF16Length,
  hasSurrogateUnit,
  isCodeUnitInSurrogateRange,
  isSurrogatePair,
  strlen: strlen$1,
  substring,
  substr: substr$2
};
var UnicodeUtils_1 = UnicodeUtils$7;
function moveSelectionBackward$3(editorState, maxDistance) {
  var selection = editorState.getSelection();
  var content = editorState.getCurrentContent();
  var key = selection.getStartKey();
  var offset = selection.getStartOffset();
  var focusKey = key;
  var focusOffset = 0;
  if (maxDistance > offset) {
    var keyBefore = content.getKeyBefore(key);
    if (keyBefore == null) {
      focusKey = key;
    } else {
      focusKey = keyBefore;
      var blockBefore = content.getBlockForKey(keyBefore);
      focusOffset = blockBefore.getText().length;
    }
  } else {
    focusOffset = offset - maxDistance;
  }
  return selection.merge({
    focusKey,
    focusOffset,
    isBackward: true
  });
}
var moveSelectionBackward_1 = moveSelectionBackward$3;
var DraftModifier$8 = DraftModifier_1;
var gkx$4 = gkx$8;
var experimentalTreeDataSupport$3 = gkx$4("draft_tree_data_support");
function removeTextWithStrategy$5(editorState, strategy, direction) {
  var selection = editorState.getSelection();
  var content = editorState.getCurrentContent();
  var target = selection;
  var anchorKey = selection.getAnchorKey();
  var focusKey = selection.getFocusKey();
  var anchorBlock = content.getBlockForKey(anchorKey);
  if (experimentalTreeDataSupport$3) {
    if (direction === "forward") {
      if (anchorKey !== focusKey) {
        return content;
      }
    }
  }
  if (selection.isCollapsed()) {
    if (direction === "forward") {
      if (editorState.isSelectionAtEndOfContent()) {
        return content;
      }
      if (experimentalTreeDataSupport$3) {
        var isAtEndOfBlock = selection.getAnchorOffset() === content.getBlockForKey(anchorKey).getLength();
        if (isAtEndOfBlock) {
          var anchorBlockSibling = content.getBlockForKey(anchorBlock.nextSibling);
          if (!anchorBlockSibling || anchorBlockSibling.getLength() === 0) {
            return content;
          }
        }
      }
    } else if (editorState.isSelectionAtStartOfContent()) {
      return content;
    }
    target = strategy(editorState);
    if (target === selection) {
      return content;
    }
  }
  return DraftModifier$8.removeRange(content, target, direction);
}
var removeTextWithStrategy_1 = removeTextWithStrategy$5;
var EditorState$g = EditorState_1;
var UnicodeUtils$6 = UnicodeUtils_1;
var moveSelectionBackward$2 = moveSelectionBackward_1;
var removeTextWithStrategy$4 = removeTextWithStrategy_1;
function keyCommandPlainBackspace$2(editorState) {
  var afterRemoval = removeTextWithStrategy$4(editorState, function(strategyState) {
    var selection2 = strategyState.getSelection();
    var content = strategyState.getCurrentContent();
    var key = selection2.getAnchorKey();
    var offset = selection2.getAnchorOffset();
    var charBehind = content.getBlockForKey(key).getText()[offset - 1];
    return moveSelectionBackward$2(strategyState, charBehind ? UnicodeUtils$6.getUTF16Length(charBehind, 0) : 1);
  }, "backward");
  if (afterRemoval === editorState.getCurrentContent()) {
    return editorState;
  }
  var selection = editorState.getSelection();
  return EditorState$g.push(editorState, afterRemoval.set("selectionBefore", selection), selection.isCollapsed() ? "backspace-character" : "remove-range");
}
var keyCommandPlainBackspace_1 = keyCommandPlainBackspace$2;
var DraftModifier$7 = DraftModifier_1;
var DraftOffsetKey = DraftOffsetKey_1;
var EditorState$f = EditorState_1;
var UserAgent$7 = UserAgent_1;
var _require$2 = draftKeyUtils, notEmptyKey = _require$2.notEmptyKey;
var findAncestorOffsetKey = findAncestorOffsetKey_1;
var keyCommandPlainBackspace$1 = keyCommandPlainBackspace_1;
var nullthrows$4 = nullthrows_1;
var isGecko = UserAgent$7.isEngine("Gecko");
var DOUBLE_NEWLINE = "\n\n";
function onInputType(inputType, editorState) {
  switch (inputType) {
    case "deleteContentBackward":
      return keyCommandPlainBackspace$1(editorState);
  }
  return editorState;
}
function editOnInput(editor, e) {
  if (editor._pendingStateFromBeforeInput !== void 0) {
    editor.update(editor._pendingStateFromBeforeInput);
    editor._pendingStateFromBeforeInput = void 0;
  }
  var castedEditorElement = editor.editor;
  var domSelection = castedEditorElement.ownerDocument.defaultView.getSelection();
  var anchorNode = domSelection.anchorNode, isCollapsed = domSelection.isCollapsed;
  var isNotTextOrElementNode = (anchorNode === null || anchorNode === void 0 ? void 0 : anchorNode.nodeType) !== Node.TEXT_NODE && (anchorNode === null || anchorNode === void 0 ? void 0 : anchorNode.nodeType) !== Node.ELEMENT_NODE;
  if (anchorNode == null || isNotTextOrElementNode) {
    return;
  }
  if (anchorNode.nodeType === Node.TEXT_NODE && (anchorNode.previousSibling !== null || anchorNode.nextSibling !== null)) {
    var span = anchorNode.parentNode;
    if (span == null) {
      return;
    }
    anchorNode.nodeValue = span.textContent;
    for (var child = span.firstChild; child != null; child = child.nextSibling) {
      if (child !== anchorNode) {
        span.removeChild(child);
      }
    }
  }
  var domText = anchorNode.textContent;
  var editorState = editor._latestEditorState;
  var offsetKey = nullthrows$4(findAncestorOffsetKey(anchorNode));
  var _DraftOffsetKey$decod = DraftOffsetKey.decode(offsetKey), blockKey = _DraftOffsetKey$decod.blockKey, decoratorKey = _DraftOffsetKey$decod.decoratorKey, leafKey = _DraftOffsetKey$decod.leafKey;
  var _editorState$getBlock = editorState.getBlockTree(blockKey).getIn([decoratorKey, "leaves", leafKey]), start = _editorState$getBlock.start, end = _editorState$getBlock.end;
  var content = editorState.getCurrentContent();
  var block = content.getBlockForKey(blockKey);
  var modelText = block.getText().slice(start, end);
  if (domText.endsWith(DOUBLE_NEWLINE)) {
    domText = domText.slice(0, -1);
  }
  if (domText === modelText) {
    var inputType = e.nativeEvent.inputType;
    if (inputType) {
      var newEditorState = onInputType(inputType, editorState);
      if (newEditorState !== editorState) {
        editor.restoreEditorDOM();
        editor.update(newEditorState);
        return;
      }
    }
    return;
  }
  var selection = editorState.getSelection();
  var targetRange = selection.merge({
    anchorOffset: start,
    focusOffset: end,
    isBackward: false
  });
  var entityKey = block.getEntityAt(start);
  var entity = notEmptyKey(entityKey) ? content.getEntity(entityKey) : null;
  var entityType = entity != null ? entity.getMutability() : null;
  var preserveEntity = entityType === "MUTABLE";
  var changeType = preserveEntity ? "spellcheck-change" : "apply-entity";
  var newContent = DraftModifier$7.replaceText(content, targetRange, domText, block.getInlineStyleAt(start), preserveEntity ? block.getEntityAt(start) : null);
  var anchorOffset, focusOffset, startOffset, endOffset;
  if (isGecko) {
    anchorOffset = domSelection.anchorOffset;
    focusOffset = domSelection.focusOffset;
    startOffset = start + Math.min(anchorOffset, focusOffset);
    endOffset = startOffset + Math.abs(anchorOffset - focusOffset);
    anchorOffset = startOffset;
    focusOffset = endOffset;
  } else {
    var charDelta = domText.length - modelText.length;
    startOffset = selection.getStartOffset();
    endOffset = selection.getEndOffset();
    anchorOffset = isCollapsed ? endOffset + charDelta : startOffset;
    focusOffset = endOffset + charDelta;
  }
  var contentWithAdjustedDOMSelection = newContent.merge({
    selectionBefore: content.getSelectionAfter(),
    selectionAfter: selection.merge({
      anchorOffset,
      focusOffset
    })
  });
  editor.update(EditorState$f.push(editorState, contentWithAdjustedDOMSelection, changeType));
}
var editOnInput_1 = editOnInput;
var Keys$2 = Keys$4;
function isSoftNewlineEvent$1(e) {
  return e.which === Keys$2.RETURN && (e.getModifierState("Shift") || e.getModifierState("Alt") || e.getModifierState("Control"));
}
var isSoftNewlineEvent_1 = isSoftNewlineEvent$1;
var UserAgent$6 = UserAgent_1;
var isSoftNewlineEvent = isSoftNewlineEvent_1;
var isOSX$1 = UserAgent$6.isPlatform("Mac OS X");
var KeyBindingUtil$3 = {
  isCtrlKeyCommand: function isCtrlKeyCommand(e) {
    return !!e.ctrlKey && !e.altKey;
  },
  isOptionKeyCommand: function isOptionKeyCommand(e) {
    return isOSX$1 && e.altKey;
  },
  usesMacOSHeuristics: function usesMacOSHeuristics() {
    return isOSX$1;
  },
  hasCommandModifier: function hasCommandModifier(e) {
    return isOSX$1 ? !!e.metaKey && !e.altKey : KeyBindingUtil$3.isCtrlKeyCommand(e);
  },
  isSoftNewlineEvent
};
var KeyBindingUtil_1 = KeyBindingUtil$3;
var DraftModifier$6 = DraftModifier_1;
var EditorState$e = EditorState_1;
var getContentStateFragment$1 = getContentStateFragment_1;
var nullthrows$3 = nullthrows_1;
var clipboard = null;
var SecondaryClipboard$1 = {
  cut: function cut(editorState) {
    var content = editorState.getCurrentContent();
    var selection = editorState.getSelection();
    var targetRange = null;
    if (selection.isCollapsed()) {
      var anchorKey = selection.getAnchorKey();
      var blockEnd = content.getBlockForKey(anchorKey).getLength();
      if (blockEnd === selection.getAnchorOffset()) {
        var keyAfter = content.getKeyAfter(anchorKey);
        if (keyAfter == null) {
          return editorState;
        }
        targetRange = selection.set("focusKey", keyAfter).set("focusOffset", 0);
      } else {
        targetRange = selection.set("focusOffset", blockEnd);
      }
    } else {
      targetRange = selection;
    }
    targetRange = nullthrows$3(targetRange);
    clipboard = getContentStateFragment$1(content, targetRange);
    var afterRemoval = DraftModifier$6.removeRange(content, targetRange, "forward");
    if (afterRemoval === content) {
      return editorState;
    }
    return EditorState$e.push(editorState, afterRemoval, "remove-range");
  },
  paste: function paste(editorState) {
    if (!clipboard) {
      return editorState;
    }
    var newContent = DraftModifier$6.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), clipboard);
    return EditorState$e.push(editorState, newContent, "insert-fragment");
  }
};
var SecondaryClipboard_1 = SecondaryClipboard$1;
var UserAgent$5 = UserAgent_1;
var invariant$7 = invariant_1;
var isChrome$2 = UserAgent$5.isBrowser("Chrome");
function getRangeClientRectsChrome(range) {
  var tempRange = range.cloneRange();
  var clientRects = [];
  for (var ancestor = range.endContainer; ancestor != null; ancestor = ancestor.parentNode) {
    var atCommonAncestor = ancestor === range.commonAncestorContainer;
    if (atCommonAncestor) {
      tempRange.setStart(range.startContainer, range.startOffset);
    } else {
      tempRange.setStart(tempRange.endContainer, 0);
    }
    var rects = Array.from(tempRange.getClientRects());
    clientRects.push(rects);
    if (atCommonAncestor) {
      var _ref;
      clientRects.reverse();
      return (_ref = []).concat.apply(_ref, clientRects);
    }
    tempRange.setEndBefore(ancestor);
  }
  invariant$7(false);
}
var getRangeClientRects$2 = isChrome$2 ? getRangeClientRectsChrome : function(range) {
  return Array.from(range.getClientRects());
};
var getRangeClientRects_1 = getRangeClientRects$2;
var UnicodeUtils$5 = UnicodeUtils_1;
var getCorrectDocumentFromNode = getCorrectDocumentFromNode_1;
var getRangeClientRects$1 = getRangeClientRects_1;
var invariant$6 = invariant_1;
function getLineHeightPx(element) {
  var computed = getComputedStyle(element);
  var correctDocument = getCorrectDocumentFromNode(element);
  var div = correctDocument.createElement("div");
  div.style.fontFamily = computed.fontFamily;
  div.style.fontSize = computed.fontSize;
  div.style.fontStyle = computed.fontStyle;
  div.style.fontWeight = computed.fontWeight;
  div.style.lineHeight = computed.lineHeight;
  div.style.position = "absolute";
  div.textContent = "M";
  var documentBody = correctDocument.body;
  !documentBody ? invariant$6(false) : void 0;
  documentBody.appendChild(div);
  var rect = div.getBoundingClientRect();
  documentBody.removeChild(div);
  return rect.height;
}
function areRectsOnOneLine(rects, lineHeight) {
  var minTop = Infinity;
  var minBottom = Infinity;
  var maxTop = -Infinity;
  var maxBottom = -Infinity;
  for (var ii = 0; ii < rects.length; ii++) {
    var rect = rects[ii];
    if (rect.width === 0 || rect.width === 1) {
      continue;
    }
    minTop = Math.min(minTop, rect.top);
    minBottom = Math.min(minBottom, rect.bottom);
    maxTop = Math.max(maxTop, rect.top);
    maxBottom = Math.max(maxBottom, rect.bottom);
  }
  return maxTop <= minBottom && maxTop - minTop < lineHeight && maxBottom - minBottom < lineHeight;
}
function getNodeLength(node) {
  switch (node.nodeType) {
    case Node.DOCUMENT_TYPE_NODE:
      return 0;
    case Node.TEXT_NODE:
    case Node.PROCESSING_INSTRUCTION_NODE:
    case Node.COMMENT_NODE:
      return node.length;
    default:
      return node.childNodes.length;
  }
}
function expandRangeToStartOfLine$1(range) {
  !range.collapsed ? invariant$6(false) : void 0;
  range = range.cloneRange();
  var containingElement = range.startContainer;
  if (containingElement.nodeType !== 1) {
    containingElement = containingElement.parentNode;
  }
  var lineHeight = getLineHeightPx(containingElement);
  var bestContainer = range.endContainer;
  var bestOffset = range.endOffset;
  range.setStart(range.startContainer, 0);
  while (areRectsOnOneLine(getRangeClientRects$1(range), lineHeight)) {
    bestContainer = range.startContainer;
    bestOffset = range.startOffset;
    !bestContainer.parentNode ? invariant$6(false) : void 0;
    range.setStartBefore(bestContainer);
    if (bestContainer.nodeType === 1 && getComputedStyle(bestContainer).display !== "inline") {
      break;
    }
  }
  var currentContainer = bestContainer;
  var maxIndexToConsider = bestOffset - 1;
  do {
    var nodeValue = currentContainer.nodeValue;
    var ii = maxIndexToConsider;
    for (; ii >= 0; ii--) {
      if (nodeValue != null && ii > 0 && UnicodeUtils$5.isSurrogatePair(nodeValue, ii - 1)) {
        continue;
      }
      range.setStart(currentContainer, ii);
      if (areRectsOnOneLine(getRangeClientRects$1(range), lineHeight)) {
        bestContainer = currentContainer;
        bestOffset = ii;
      } else {
        break;
      }
    }
    if (ii === -1 || currentContainer.childNodes.length === 0) {
      break;
    }
    currentContainer = currentContainer.childNodes[ii];
    maxIndexToConsider = getNodeLength(currentContainer);
  } while (true);
  range.setStart(bestContainer, bestOffset);
  return range;
}
var expandRangeToStartOfLine_1 = expandRangeToStartOfLine$1;
var EditorState$d = EditorState_1;
var expandRangeToStartOfLine = expandRangeToStartOfLine_1;
var getDraftEditorSelectionWithNodes = getDraftEditorSelectionWithNodes_1;
var moveSelectionBackward$1 = moveSelectionBackward_1;
var removeTextWithStrategy$3 = removeTextWithStrategy_1;
function keyCommandBackspaceToStartOfLine$1(editorState, e) {
  var afterRemoval = removeTextWithStrategy$3(editorState, function(strategyState) {
    var selection = strategyState.getSelection();
    if (selection.isCollapsed() && selection.getAnchorOffset() === 0) {
      return moveSelectionBackward$1(strategyState, 1);
    }
    var ownerDocument = e.currentTarget.ownerDocument;
    var domSelection = ownerDocument.defaultView.getSelection();
    var range = domSelection.getRangeAt(0);
    range = expandRangeToStartOfLine(range);
    return getDraftEditorSelectionWithNodes(strategyState, null, range.endContainer, range.endOffset, range.startContainer, range.startOffset).selectionState;
  }, "backward");
  if (afterRemoval === editorState.getCurrentContent()) {
    return editorState;
  }
  return EditorState$d.push(editorState, afterRemoval, "remove-range");
}
var keyCommandBackspaceToStartOfLine_1 = keyCommandBackspaceToStartOfLine$1;
var PUNCTUATION = `[.,+*?$|#{}()'\\^\\-\\[\\]\\\\\\/!@%"~=<>_:;\u30FB\u3001\u3002\u3008-\u3011\u3014-\u301F\uFF1A-\uFF1F\uFF01-\uFF0F\uFF3B-\uFF40\uFF5B-\uFF65\u2E2E\u061F\u066A-\u066C\u061B\u060C\u060D\uFD3E\uFD3F\u1801\u0964\u104A\u104B\u2010-\u2027\u2030-\u205E\xA1-\xB1\xB4-\xB8\xBA\xBB\xBF]`;
var TokenizeUtil$1 = {
  getPunctuation: function getPunctuation() {
    return PUNCTUATION;
  }
};
var TokenizeUtil = TokenizeUtil$1;
var punctuation = TokenizeUtil.getPunctuation();
var CHAMELEON_CHARS = "['\u2018\u2019]";
var WHITESPACE_AND_PUNCTUATION = "\\s|(?![_])" + punctuation;
var DELETE_STRING = "^(?:" + WHITESPACE_AND_PUNCTUATION + ")*(?:" + CHAMELEON_CHARS + "|(?!" + WHITESPACE_AND_PUNCTUATION + ").)*(?:(?!" + WHITESPACE_AND_PUNCTUATION + ").)";
var DELETE_REGEX = new RegExp(DELETE_STRING);
var BACKSPACE_STRING = "(?:(?!" + WHITESPACE_AND_PUNCTUATION + ").)(?:" + CHAMELEON_CHARS + "|(?!" + WHITESPACE_AND_PUNCTUATION + ").)*(?:" + WHITESPACE_AND_PUNCTUATION + ")*$";
var BACKSPACE_REGEX = new RegExp(BACKSPACE_STRING);
function getRemovableWord(text, isBackward) {
  var matches = isBackward ? BACKSPACE_REGEX.exec(text) : DELETE_REGEX.exec(text);
  return matches ? matches[0] : text;
}
var DraftRemovableWord$2 = {
  getBackward: function getBackward(text) {
    return getRemovableWord(text, true);
  },
  getForward: function getForward(text) {
    return getRemovableWord(text, false);
  }
};
var DraftRemovableWord_1 = DraftRemovableWord$2;
var DraftRemovableWord$1 = DraftRemovableWord_1;
var EditorState$c = EditorState_1;
var moveSelectionBackward = moveSelectionBackward_1;
var removeTextWithStrategy$2 = removeTextWithStrategy_1;
function keyCommandBackspaceWord$1(editorState) {
  var afterRemoval = removeTextWithStrategy$2(editorState, function(strategyState) {
    var selection = strategyState.getSelection();
    var offset = selection.getStartOffset();
    if (offset === 0) {
      return moveSelectionBackward(strategyState, 1);
    }
    var key = selection.getStartKey();
    var content = strategyState.getCurrentContent();
    var text = content.getBlockForKey(key).getText().slice(0, offset);
    var toRemove = DraftRemovableWord$1.getBackward(text);
    return moveSelectionBackward(strategyState, toRemove.length || 1);
  }, "backward");
  if (afterRemoval === editorState.getCurrentContent()) {
    return editorState;
  }
  return EditorState$c.push(editorState, afterRemoval, "remove-range");
}
var keyCommandBackspaceWord_1 = keyCommandBackspaceWord$1;
function moveSelectionForward$2(editorState, maxDistance) {
  var selection = editorState.getSelection();
  var key = selection.getStartKey();
  var offset = selection.getStartOffset();
  var content = editorState.getCurrentContent();
  var focusKey = key;
  var focusOffset;
  var block = content.getBlockForKey(key);
  if (maxDistance > block.getText().length - offset) {
    focusKey = content.getKeyAfter(key);
    focusOffset = 0;
  } else {
    focusOffset = offset + maxDistance;
  }
  return selection.merge({
    focusKey,
    focusOffset
  });
}
var moveSelectionForward_1 = moveSelectionForward$2;
var DraftRemovableWord = DraftRemovableWord_1;
var EditorState$b = EditorState_1;
var moveSelectionForward$1 = moveSelectionForward_1;
var removeTextWithStrategy$1 = removeTextWithStrategy_1;
function keyCommandDeleteWord$1(editorState) {
  var afterRemoval = removeTextWithStrategy$1(editorState, function(strategyState) {
    var selection = strategyState.getSelection();
    var offset = selection.getStartOffset();
    var key = selection.getStartKey();
    var content = strategyState.getCurrentContent();
    var text = content.getBlockForKey(key).getText().slice(offset);
    var toRemove = DraftRemovableWord.getForward(text);
    return moveSelectionForward$1(strategyState, toRemove.length || 1);
  }, "forward");
  if (afterRemoval === editorState.getCurrentContent()) {
    return editorState;
  }
  return EditorState$b.push(editorState, afterRemoval, "remove-range");
}
var keyCommandDeleteWord_1 = keyCommandDeleteWord$1;
var DraftModifier$5 = DraftModifier_1;
var EditorState$a = EditorState_1;
function keyCommandInsertNewline$1(editorState) {
  var contentState = DraftModifier$5.splitBlock(editorState.getCurrentContent(), editorState.getSelection());
  return EditorState$a.push(editorState, contentState, "split-block");
}
var keyCommandInsertNewline_1 = keyCommandInsertNewline$1;
var EditorState$9 = EditorState_1;
function keyCommandMoveSelectionToEndOfBlock$1(editorState) {
  var selection = editorState.getSelection();
  var endKey = selection.getEndKey();
  var content = editorState.getCurrentContent();
  var textLength = content.getBlockForKey(endKey).getLength();
  return EditorState$9.set(editorState, {
    selection: selection.merge({
      anchorKey: endKey,
      anchorOffset: textLength,
      focusKey: endKey,
      focusOffset: textLength,
      isBackward: false
    }),
    forceSelection: true
  });
}
var keyCommandMoveSelectionToEndOfBlock_1 = keyCommandMoveSelectionToEndOfBlock$1;
var EditorState$8 = EditorState_1;
function keyCommandMoveSelectionToStartOfBlock$1(editorState) {
  var selection = editorState.getSelection();
  var startKey = selection.getStartKey();
  return EditorState$8.set(editorState, {
    selection: selection.merge({
      anchorKey: startKey,
      anchorOffset: 0,
      focusKey: startKey,
      focusOffset: 0,
      isBackward: false
    }),
    forceSelection: true
  });
}
var keyCommandMoveSelectionToStartOfBlock_1 = keyCommandMoveSelectionToStartOfBlock$1;
var EditorState$7 = EditorState_1;
var UnicodeUtils$4 = UnicodeUtils_1;
var moveSelectionForward = moveSelectionForward_1;
var removeTextWithStrategy = removeTextWithStrategy_1;
function keyCommandPlainDelete$1(editorState) {
  var afterRemoval = removeTextWithStrategy(editorState, function(strategyState) {
    var selection2 = strategyState.getSelection();
    var content = strategyState.getCurrentContent();
    var key = selection2.getAnchorKey();
    var offset = selection2.getAnchorOffset();
    var charAhead = content.getBlockForKey(key).getText()[offset];
    return moveSelectionForward(strategyState, charAhead ? UnicodeUtils$4.getUTF16Length(charAhead, 0) : 1);
  }, "forward");
  if (afterRemoval === editorState.getCurrentContent()) {
    return editorState;
  }
  var selection = editorState.getSelection();
  return EditorState$7.push(editorState, afterRemoval.set("selectionBefore", selection), selection.isCollapsed() ? "delete-character" : "remove-range");
}
var keyCommandPlainDelete_1 = keyCommandPlainDelete$1;
var DraftModifier$4 = DraftModifier_1;
var EditorState$6 = EditorState_1;
var getContentStateFragment2 = getContentStateFragment_1;
function keyCommandTransposeCharacters$1(editorState) {
  var selection = editorState.getSelection();
  if (!selection.isCollapsed()) {
    return editorState;
  }
  var offset = selection.getAnchorOffset();
  if (offset === 0) {
    return editorState;
  }
  var blockKey = selection.getAnchorKey();
  var content = editorState.getCurrentContent();
  var block = content.getBlockForKey(blockKey);
  var length = block.getLength();
  if (length <= 1) {
    return editorState;
  }
  var removalRange;
  var finalSelection;
  if (offset === length) {
    removalRange = selection.set("anchorOffset", offset - 1);
    finalSelection = selection;
  } else {
    removalRange = selection.set("focusOffset", offset + 1);
    finalSelection = removalRange.set("anchorOffset", offset + 1);
  }
  var movedFragment = getContentStateFragment2(content, removalRange);
  var afterRemoval = DraftModifier$4.removeRange(content, removalRange, "backward");
  var selectionAfter = afterRemoval.getSelectionAfter();
  var targetOffset = selectionAfter.getAnchorOffset() - 1;
  var targetRange = selectionAfter.merge({
    anchorOffset: targetOffset,
    focusOffset: targetOffset
  });
  var afterInsert = DraftModifier$4.replaceWithFragment(afterRemoval, targetRange, movedFragment);
  var newEditorState = EditorState$6.push(editorState, afterInsert, "insert-fragment");
  return EditorState$6.acceptSelection(newEditorState, finalSelection);
}
var keyCommandTransposeCharacters_1 = keyCommandTransposeCharacters$1;
var EditorState$5 = EditorState_1;
function keyCommandUndo$1(e, editorState, updateFn) {
  var undoneState = EditorState$5.undo(editorState);
  if (editorState.getLastChangeType() === "spellcheck-change") {
    var nativelyRenderedContent = undoneState.getCurrentContent();
    updateFn(EditorState$5.set(undoneState, {
      nativelyRenderedContent
    }));
    return;
  }
  e.preventDefault();
  if (!editorState.getNativelyRenderedContent()) {
    updateFn(undoneState);
    return;
  }
  updateFn(EditorState$5.set(editorState, {
    nativelyRenderedContent: null
  }));
  setTimeout(function() {
    updateFn(undoneState);
  }, 0);
}
var keyCommandUndo_1 = keyCommandUndo$1;
var DraftModifier$3 = DraftModifier_1;
var EditorState$4 = EditorState_1;
var KeyBindingUtil$2 = KeyBindingUtil_1;
var Keys$1 = Keys$4;
var SecondaryClipboard = SecondaryClipboard_1;
var UserAgent$4 = UserAgent_1;
var isEventHandled$1 = isEventHandled_1;
var keyCommandBackspaceToStartOfLine = keyCommandBackspaceToStartOfLine_1;
var keyCommandBackspaceWord = keyCommandBackspaceWord_1;
var keyCommandDeleteWord = keyCommandDeleteWord_1;
var keyCommandInsertNewline = keyCommandInsertNewline_1;
var keyCommandMoveSelectionToEndOfBlock = keyCommandMoveSelectionToEndOfBlock_1;
var keyCommandMoveSelectionToStartOfBlock = keyCommandMoveSelectionToStartOfBlock_1;
var keyCommandPlainBackspace = keyCommandPlainBackspace_1;
var keyCommandPlainDelete = keyCommandPlainDelete_1;
var keyCommandTransposeCharacters = keyCommandTransposeCharacters_1;
var keyCommandUndo = keyCommandUndo_1;
var isOptionKeyCommand2 = KeyBindingUtil$2.isOptionKeyCommand;
var isChrome$1 = UserAgent$4.isBrowser("Chrome");
function onKeyCommand(command, editorState, e) {
  switch (command) {
    case "redo":
      return EditorState$4.redo(editorState);
    case "delete":
      return keyCommandPlainDelete(editorState);
    case "delete-word":
      return keyCommandDeleteWord(editorState);
    case "backspace":
      return keyCommandPlainBackspace(editorState);
    case "backspace-word":
      return keyCommandBackspaceWord(editorState);
    case "backspace-to-start-of-line":
      return keyCommandBackspaceToStartOfLine(editorState, e);
    case "split-block":
      return keyCommandInsertNewline(editorState);
    case "transpose-characters":
      return keyCommandTransposeCharacters(editorState);
    case "move-selection-to-start-of-block":
      return keyCommandMoveSelectionToStartOfBlock(editorState);
    case "move-selection-to-end-of-block":
      return keyCommandMoveSelectionToEndOfBlock(editorState);
    case "secondary-cut":
      return SecondaryClipboard.cut(editorState);
    case "secondary-paste":
      return SecondaryClipboard.paste(editorState);
    default:
      return editorState;
  }
}
function editOnKeyDown(editor, e) {
  var keyCode = e.which;
  var editorState = editor._latestEditorState;
  function callDeprecatedHandler(handlerName) {
    var deprecatedHandler = editor.props[handlerName];
    if (deprecatedHandler) {
      deprecatedHandler(e);
      return true;
    } else {
      return false;
    }
  }
  switch (keyCode) {
    case Keys$1.RETURN:
      e.preventDefault();
      if (editor.props.handleReturn && isEventHandled$1(editor.props.handleReturn(e, editorState))) {
        return;
      }
      break;
    case Keys$1.ESC:
      e.preventDefault();
      if (callDeprecatedHandler("onEscape")) {
        return;
      }
      break;
    case Keys$1.TAB:
      if (callDeprecatedHandler("onTab")) {
        return;
      }
      break;
    case Keys$1.UP:
      if (callDeprecatedHandler("onUpArrow")) {
        return;
      }
      break;
    case Keys$1.RIGHT:
      if (callDeprecatedHandler("onRightArrow")) {
        return;
      }
      break;
    case Keys$1.DOWN:
      if (callDeprecatedHandler("onDownArrow")) {
        return;
      }
      break;
    case Keys$1.LEFT:
      if (callDeprecatedHandler("onLeftArrow")) {
        return;
      }
      break;
    case Keys$1.SPACE:
      if (isChrome$1 && isOptionKeyCommand2(e)) {
        e.preventDefault();
      }
  }
  var command = editor.props.keyBindingFn(e);
  if (command == null || command === "") {
    if (keyCode === Keys$1.SPACE && isChrome$1 && isOptionKeyCommand2(e)) {
      var contentState = DraftModifier$3.replaceText(editorState.getCurrentContent(), editorState.getSelection(), "\xA0");
      editor.update(EditorState$4.push(editorState, contentState, "insert-characters"));
    }
    return;
  }
  if (command === "undo") {
    keyCommandUndo(e, editorState, editor.update);
    return;
  }
  e.preventDefault();
  if (editor.props.handleKeyCommand && isEventHandled$1(editor.props.handleKeyCommand(command, editorState, e.timeStamp))) {
    return;
  }
  var newState = onKeyCommand(command, editorState, e);
  if (newState !== editorState) {
    editor.update(newState);
  }
}
var editOnKeyDown_1 = editOnKeyDown;
function _defineProperty$9(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var URI$1 = /* @__PURE__ */ function() {
  function URI2(uri) {
    _defineProperty$9(this, "_uri", void 0);
    this._uri = uri;
  }
  var _proto = URI2.prototype;
  _proto.toString = function toString4() {
    return this._uri;
  };
  return URI2;
}();
var URI_1 = URI$1;
var UserAgent$3 = UserAgent_1;
var invariant$5 = invariant_1;
var isOldIE = UserAgent$3.isBrowser("IE <= 9");
function getSafeBodyFromHTML$2(html) {
  var doc;
  var root2 = null;
  if (!isOldIE && document.implementation && document.implementation.createHTMLDocument) {
    doc = document.implementation.createHTMLDocument("foo");
    !doc.documentElement ? invariant$5(false) : void 0;
    doc.documentElement.innerHTML = html;
    root2 = doc.getElementsByTagName("body")[0];
  }
  return root2;
}
var getSafeBodyFromHTML_1 = getSafeBodyFromHTML$2;
var isElement$2 = isElement_1;
function isHTMLAnchorElement$1(node) {
  if (!node || !node.ownerDocument) {
    return false;
  }
  return isElement$2(node) && node.nodeName === "A";
}
var isHTMLAnchorElement_1 = isHTMLAnchorElement$1;
var isElement$1 = isElement_1;
function isHTMLImageElement$1(node) {
  if (!node || !node.ownerDocument) {
    return false;
  }
  return isElement$1(node) && node.nodeName === "IMG";
}
var isHTMLImageElement_1 = isHTMLImageElement$1;
var _knownListItemDepthCl;
function _objectSpread$7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty$8(target, key, source[key]);
    });
  }
  return target;
}
function _defineProperty$8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var CharacterMetadata$3 = CharacterMetadata_1;
var ContentBlock$4 = ContentBlock_1;
var ContentBlockNode$3 = ContentBlockNode_1;
var DefaultDraftBlockRenderMap$2 = DefaultDraftBlockRenderMap_1;
var DraftEntity$2 = DraftEntity_1;
var URI = URI_1;
var cx$2 = cx_1;
var generateRandomKey$5 = generateRandomKey_1;
var getSafeBodyFromHTML$1 = getSafeBodyFromHTML_1;
var gkx$3 = gkx$8;
var _require$1 = immutable$1.exports, List$5 = _require$1.List, Map$7 = _require$1.Map, OrderedSet$2 = _require$1.OrderedSet;
var isHTMLAnchorElement = isHTMLAnchorElement_1;
var isHTMLBRElement = isHTMLBRElement_1;
var isHTMLElement$1 = isHTMLElement_1;
var isHTMLImageElement = isHTMLImageElement_1;
var experimentalTreeDataSupport$2 = gkx$3("draft_tree_data_support");
var NBSP$1 = "&nbsp;";
var SPACE$1 = " ";
var REGEX_CR$1 = new RegExp("\r", "g");
var REGEX_LF$1 = new RegExp("\n", "g");
var REGEX_LEADING_LF = new RegExp("^\n", "g");
var REGEX_NBSP$1 = new RegExp(NBSP$1, "g");
var REGEX_CARRIAGE = new RegExp("&#13;?", "g");
var REGEX_ZWS = new RegExp("&#8203;?", "g");
var boldValues = ["bold", "bolder", "500", "600", "700", "800", "900"];
var notBoldValues = ["light", "lighter", "normal", "100", "200", "300", "400"];
var anchorAttr = ["className", "href", "rel", "target", "title"];
var imgAttr = ["alt", "className", "height", "src", "width"];
var knownListItemDepthClasses = (_knownListItemDepthCl = {}, _defineProperty$8(_knownListItemDepthCl, cx$2("public/DraftStyleDefault/depth0"), 0), _defineProperty$8(_knownListItemDepthCl, cx$2("public/DraftStyleDefault/depth1"), 1), _defineProperty$8(_knownListItemDepthCl, cx$2("public/DraftStyleDefault/depth2"), 2), _defineProperty$8(_knownListItemDepthCl, cx$2("public/DraftStyleDefault/depth3"), 3), _defineProperty$8(_knownListItemDepthCl, cx$2("public/DraftStyleDefault/depth4"), 4), _knownListItemDepthCl);
var HTMLTagToRawInlineStyleMap = Map$7({
  b: "BOLD",
  code: "CODE",
  del: "STRIKETHROUGH",
  em: "ITALIC",
  i: "ITALIC",
  s: "STRIKETHROUGH",
  strike: "STRIKETHROUGH",
  strong: "BOLD",
  u: "UNDERLINE",
  mark: "HIGHLIGHT"
});
var buildBlockTypeMap = function buildBlockTypeMap2(blockRenderMap2) {
  var blockTypeMap = {};
  blockRenderMap2.mapKeys(function(blockType, desc) {
    var elements = [desc.element];
    if (desc.aliasedElements !== void 0) {
      elements.push.apply(elements, desc.aliasedElements);
    }
    elements.forEach(function(element) {
      if (blockTypeMap[element] === void 0) {
        blockTypeMap[element] = blockType;
      } else if (typeof blockTypeMap[element] === "string") {
        blockTypeMap[element] = [blockTypeMap[element], blockType];
      } else {
        blockTypeMap[element].push(blockType);
      }
    });
  });
  return Map$7(blockTypeMap);
};
var detectInlineStyle = function detectInlineStyle2(node) {
  if (isHTMLElement$1(node)) {
    var element = node;
    if (element.style.fontFamily.includes("monospace")) {
      return "CODE";
    }
  }
  return null;
};
var getListItemDepth = function getListItemDepth2(node) {
  var depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  Object.keys(knownListItemDepthClasses).some(function(depthClass) {
    if (node.classList.contains(depthClass)) {
      depth = knownListItemDepthClasses[depthClass];
    }
  });
  return depth;
};
var isValidAnchor = function isValidAnchor2(node) {
  if (!isHTMLAnchorElement(node)) {
    return false;
  }
  var anchorNode = node;
  if (!anchorNode.href || anchorNode.protocol !== "http:" && anchorNode.protocol !== "https:" && anchorNode.protocol !== "mailto:" && anchorNode.protocol !== "tel:") {
    return false;
  }
  try {
    var _ = new URI(anchorNode.href);
    return true;
  } catch (_2) {
    return false;
  }
};
var isValidImage = function isValidImage2(node) {
  if (!isHTMLImageElement(node)) {
    return false;
  }
  var imageNode = node;
  return !!(imageNode.attributes.getNamedItem("src") && imageNode.attributes.getNamedItem("src").value);
};
var styleFromNodeAttributes = function styleFromNodeAttributes2(node, style) {
  if (!isHTMLElement$1(node)) {
    return style;
  }
  var htmlElement = node;
  var fontWeight = htmlElement.style.fontWeight;
  var fontStyle = htmlElement.style.fontStyle;
  var textDecoration = htmlElement.style.textDecoration;
  return style.withMutations(function(style2) {
    if (boldValues.indexOf(fontWeight) >= 0) {
      style2.add("BOLD");
    } else if (notBoldValues.indexOf(fontWeight) >= 0) {
      style2.remove("BOLD");
    }
    if (fontStyle === "italic") {
      style2.add("ITALIC");
    } else if (fontStyle === "normal") {
      style2.remove("ITALIC");
    }
    if (textDecoration === "underline") {
      style2.add("UNDERLINE");
    }
    if (textDecoration === "line-through") {
      style2.add("STRIKETHROUGH");
    }
    if (textDecoration === "none") {
      style2.remove("UNDERLINE");
      style2.remove("STRIKETHROUGH");
    }
  });
};
var isListNode = function isListNode2(nodeName) {
  return nodeName === "ul" || nodeName === "ol";
};
var ContentBlocksBuilder = /* @__PURE__ */ function() {
  function ContentBlocksBuilder2(blockTypeMap, disambiguate) {
    _defineProperty$8(this, "characterList", List$5());
    _defineProperty$8(this, "currentBlockType", "unstyled");
    _defineProperty$8(this, "currentDepth", 0);
    _defineProperty$8(this, "currentEntity", null);
    _defineProperty$8(this, "currentText", "");
    _defineProperty$8(this, "wrapper", null);
    _defineProperty$8(this, "blockConfigs", []);
    _defineProperty$8(this, "contentBlocks", []);
    _defineProperty$8(this, "entityMap", DraftEntity$2);
    _defineProperty$8(this, "blockTypeMap", void 0);
    _defineProperty$8(this, "disambiguate", void 0);
    this.clear();
    this.blockTypeMap = blockTypeMap;
    this.disambiguate = disambiguate;
  }
  var _proto = ContentBlocksBuilder2.prototype;
  _proto.clear = function clear() {
    this.characterList = List$5();
    this.blockConfigs = [];
    this.currentBlockType = "unstyled";
    this.currentDepth = 0;
    this.currentEntity = null;
    this.currentText = "";
    this.entityMap = DraftEntity$2;
    this.wrapper = null;
    this.contentBlocks = [];
  };
  _proto.addDOMNode = function addDOMNode(node) {
    var _this$blockConfigs;
    this.contentBlocks = [];
    this.currentDepth = 0;
    (_this$blockConfigs = this.blockConfigs).push.apply(_this$blockConfigs, this._toBlockConfigs([node], OrderedSet$2()));
    this._trimCurrentText();
    if (this.currentText !== "") {
      this.blockConfigs.push(this._makeBlockConfig());
    }
    return this;
  };
  _proto.getContentBlocks = function getContentBlocks() {
    if (this.contentBlocks.length === 0) {
      if (experimentalTreeDataSupport$2) {
        this._toContentBlocks(this.blockConfigs);
      } else {
        this._toFlatContentBlocks(this.blockConfigs);
      }
    }
    return {
      contentBlocks: this.contentBlocks,
      entityMap: this.entityMap
    };
  };
  _proto._makeBlockConfig = function _makeBlockConfig() {
    var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var key = config.key || generateRandomKey$5();
    var block = _objectSpread$7({
      key,
      type: this.currentBlockType,
      text: this.currentText,
      characterList: this.characterList,
      depth: this.currentDepth,
      parent: null,
      children: List$5(),
      prevSibling: null,
      nextSibling: null,
      childConfigs: []
    }, config);
    this.characterList = List$5();
    this.currentBlockType = "unstyled";
    this.currentText = "";
    return block;
  };
  _proto._toBlockConfigs = function _toBlockConfigs(nodes, style) {
    var blockConfigs = [];
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      var nodeName = node.nodeName.toLowerCase();
      if (nodeName === "body" || isListNode(nodeName)) {
        this._trimCurrentText();
        if (this.currentText !== "") {
          blockConfigs.push(this._makeBlockConfig());
        }
        var wasCurrentDepth = this.currentDepth;
        var wasWrapper = this.wrapper;
        if (isListNode(nodeName)) {
          this.wrapper = nodeName;
          if (isListNode(wasWrapper)) {
            this.currentDepth++;
          }
        }
        blockConfigs.push.apply(blockConfigs, this._toBlockConfigs(Array.from(node.childNodes), style));
        this.currentDepth = wasCurrentDepth;
        this.wrapper = wasWrapper;
        continue;
      }
      var blockType = this.blockTypeMap.get(nodeName);
      if (blockType !== void 0) {
        this._trimCurrentText();
        if (this.currentText !== "") {
          blockConfigs.push(this._makeBlockConfig());
        }
        var _wasCurrentDepth = this.currentDepth;
        var _wasWrapper = this.wrapper;
        this.wrapper = nodeName === "pre" ? "pre" : this.wrapper;
        if (typeof blockType !== "string") {
          blockType = this.disambiguate(nodeName, this.wrapper) || blockType[0] || "unstyled";
        }
        if (!experimentalTreeDataSupport$2 && isHTMLElement$1(node) && (blockType === "unordered-list-item" || blockType === "ordered-list-item")) {
          var htmlElement = node;
          this.currentDepth = getListItemDepth(htmlElement, this.currentDepth);
        }
        var key = generateRandomKey$5();
        var childConfigs = this._toBlockConfigs(Array.from(node.childNodes), style);
        this._trimCurrentText();
        blockConfigs.push(this._makeBlockConfig({
          key,
          childConfigs,
          type: blockType
        }));
        this.currentDepth = _wasCurrentDepth;
        this.wrapper = _wasWrapper;
        continue;
      }
      if (nodeName === "#text") {
        this._addTextNode(node, style);
        continue;
      }
      if (nodeName === "br") {
        this._addBreakNode(node, style);
        continue;
      }
      if (isValidImage(node)) {
        this._addImgNode(node, style);
        continue;
      }
      if (isValidAnchor(node)) {
        this._addAnchorNode(node, blockConfigs, style);
        continue;
      }
      var newStyle = style;
      if (HTMLTagToRawInlineStyleMap.has(nodeName)) {
        newStyle = newStyle.add(HTMLTagToRawInlineStyleMap.get(nodeName));
      }
      newStyle = styleFromNodeAttributes(node, newStyle);
      var inlineStyle = detectInlineStyle(node);
      if (inlineStyle != null) {
        newStyle = newStyle.add(inlineStyle);
      }
      blockConfigs.push.apply(blockConfigs, this._toBlockConfigs(Array.from(node.childNodes), newStyle));
    }
    return blockConfigs;
  };
  _proto._appendText = function _appendText(text, style) {
    var _this$characterList;
    this.currentText += text;
    var characterMetadata = CharacterMetadata$3.create({
      style,
      entity: this.currentEntity
    });
    this.characterList = (_this$characterList = this.characterList).push.apply(_this$characterList, Array(text.length).fill(characterMetadata));
  };
  _proto._trimCurrentText = function _trimCurrentText() {
    var l2 = this.currentText.length;
    var begin = l2 - this.currentText.trimLeft().length;
    var end = this.currentText.trimRight().length;
    var entity = this.characterList.findEntry(function(characterMetadata) {
      return characterMetadata.getEntity() !== null;
    });
    begin = entity !== void 0 ? Math.min(begin, entity[0]) : begin;
    entity = this.characterList.reverse().findEntry(function(characterMetadata) {
      return characterMetadata.getEntity() !== null;
    });
    end = entity !== void 0 ? Math.max(end, l2 - entity[0]) : end;
    if (begin > end) {
      this.currentText = "";
      this.characterList = List$5();
    } else {
      this.currentText = this.currentText.slice(begin, end);
      this.characterList = this.characterList.slice(begin, end);
    }
  };
  _proto._addTextNode = function _addTextNode(node, style) {
    var text = node.textContent;
    var trimmedText = text.trim();
    if (trimmedText === "" && this.wrapper !== "pre") {
      text = " ";
    }
    if (this.wrapper !== "pre") {
      text = text.replace(REGEX_LEADING_LF, "");
      text = text.replace(REGEX_LF$1, SPACE$1);
    }
    this._appendText(text, style);
  };
  _proto._addBreakNode = function _addBreakNode(node, style) {
    if (!isHTMLBRElement(node)) {
      return;
    }
    this._appendText("\n", style);
  };
  _proto._addImgNode = function _addImgNode(node, style) {
    if (!isHTMLImageElement(node)) {
      return;
    }
    var image = node;
    var entityConfig = {};
    imgAttr.forEach(function(attr) {
      var imageAttribute = image.getAttribute(attr);
      if (imageAttribute) {
        entityConfig[attr] = imageAttribute;
      }
    });
    this.currentEntity = this.entityMap.__create("IMAGE", "IMMUTABLE", entityConfig);
    if (gkx$3("draftjs_fix_paste_for_img")) {
      if (image.getAttribute("role") !== "presentation") {
        this._appendText("\u{1F4F7}", style);
      }
    } else {
      this._appendText("\u{1F4F7}", style);
    }
    this.currentEntity = null;
  };
  _proto._addAnchorNode = function _addAnchorNode(node, blockConfigs, style) {
    if (!isHTMLAnchorElement(node)) {
      return;
    }
    var anchor = node;
    var entityConfig = {};
    anchorAttr.forEach(function(attr) {
      var anchorAttribute = anchor.getAttribute(attr);
      if (anchorAttribute) {
        entityConfig[attr] = anchorAttribute;
      }
    });
    entityConfig.url = new URI(anchor.href).toString();
    this.currentEntity = this.entityMap.__create("LINK", "MUTABLE", entityConfig || {});
    blockConfigs.push.apply(blockConfigs, this._toBlockConfigs(Array.from(node.childNodes), style));
    this.currentEntity = null;
  };
  _proto._toContentBlocks = function _toContentBlocks(blockConfigs) {
    var parent2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    var l2 = blockConfigs.length - 1;
    for (var i = 0; i <= l2; i++) {
      var config = blockConfigs[i];
      config.parent = parent2;
      config.prevSibling = i > 0 ? blockConfigs[i - 1].key : null;
      config.nextSibling = i < l2 ? blockConfigs[i + 1].key : null;
      config.children = List$5(config.childConfigs.map(function(child) {
        return child.key;
      }));
      this.contentBlocks.push(new ContentBlockNode$3(_objectSpread$7({}, config)));
      this._toContentBlocks(config.childConfigs, config.key);
    }
  };
  _proto._hoistContainersInBlockConfigs = function _hoistContainersInBlockConfigs(blockConfigs) {
    var _this = this;
    var hoisted = List$5(blockConfigs).flatMap(function(blockConfig) {
      if (blockConfig.type !== "unstyled" || blockConfig.text !== "") {
        return [blockConfig];
      }
      return _this._hoistContainersInBlockConfigs(blockConfig.childConfigs);
    });
    return hoisted;
  };
  _proto._toFlatContentBlocks = function _toFlatContentBlocks(blockConfigs) {
    var _this2 = this;
    var cleanConfigs = this._hoistContainersInBlockConfigs(blockConfigs);
    cleanConfigs.forEach(function(config) {
      var _this2$_extractTextFr = _this2._extractTextFromBlockConfigs(config.childConfigs), text = _this2$_extractTextFr.text, characterList = _this2$_extractTextFr.characterList;
      _this2.contentBlocks.push(new ContentBlock$4(_objectSpread$7({}, config, {
        text: config.text + text,
        characterList: config.characterList.concat(characterList)
      })));
    });
  };
  _proto._extractTextFromBlockConfigs = function _extractTextFromBlockConfigs(blockConfigs) {
    var l2 = blockConfigs.length - 1;
    var text = "";
    var characterList = List$5();
    for (var i = 0; i <= l2; i++) {
      var config = blockConfigs[i];
      text += config.text;
      characterList = characterList.concat(config.characterList);
      if (text !== "" && config.type !== "unstyled") {
        text += "\n";
        characterList = characterList.push(characterList.last());
      }
      var children = this._extractTextFromBlockConfigs(config.childConfigs);
      text += children.text;
      characterList = characterList.concat(children.characterList);
    }
    return {
      text,
      characterList
    };
  };
  return ContentBlocksBuilder2;
}();
var convertFromHTMLToContentBlocks$1 = function convertFromHTMLToContentBlocks(html) {
  var DOMBuilder = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getSafeBodyFromHTML$1;
  var blockRenderMap2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DefaultDraftBlockRenderMap$2;
  html = html.trim().replace(REGEX_CR$1, "").replace(REGEX_NBSP$1, SPACE$1).replace(REGEX_CARRIAGE, "").replace(REGEX_ZWS, "");
  var safeBody = DOMBuilder(html);
  if (!safeBody) {
    return null;
  }
  var blockTypeMap = buildBlockTypeMap(blockRenderMap2);
  var disambiguate = function disambiguate2(tag, wrapper) {
    if (tag === "li") {
      return wrapper === "ol" ? "ordered-list-item" : "unordered-list-item";
    }
    return null;
  };
  return new ContentBlocksBuilder(blockTypeMap, disambiguate).addDOMNode(safeBody).getContentBlocks();
};
var convertFromHTMLToContentBlocks_1 = convertFromHTMLToContentBlocks$1;
function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty$7(target, key, source[key]);
    });
  }
  return target;
}
function _defineProperty$7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ContentBlock$3 = ContentBlock_1;
var ContentBlockNode$2 = ContentBlockNode_1;
var convertFromHTMLToContentBlocks2 = convertFromHTMLToContentBlocks_1;
var generateRandomKey$4 = generateRandomKey_1;
var getSafeBodyFromHTML = getSafeBodyFromHTML_1;
var gkx$2 = gkx$8;
var Immutable$2 = immutable$1.exports;
var sanitizeDraftText$1 = sanitizeDraftText_1;
var List$4 = Immutable$2.List, Repeat = Immutable$2.Repeat;
var experimentalTreeDataSupport$1 = gkx$2("draft_tree_data_support");
var ContentBlockRecord = experimentalTreeDataSupport$1 ? ContentBlockNode$2 : ContentBlock$3;
var DraftPasteProcessor$1 = {
  processHTML: function processHTML(html, blockRenderMap2) {
    return convertFromHTMLToContentBlocks2(html, getSafeBodyFromHTML, blockRenderMap2);
  },
  processText: function processText(textBlocks, character, type) {
    return textBlocks.reduce(function(acc, textLine, index) {
      textLine = sanitizeDraftText$1(textLine);
      var key = generateRandomKey$4();
      var blockNodeConfig = {
        key,
        type,
        text: textLine,
        characterList: List$4(Repeat(character, textLine.length))
      };
      if (experimentalTreeDataSupport$1 && index !== 0) {
        var prevSiblingIndex = index - 1;
        var previousBlock = acc[prevSiblingIndex] = acc[prevSiblingIndex].merge({
          nextSibling: key
        });
        blockNodeConfig = _objectSpread$6({}, blockNodeConfig, {
          prevSibling: previousBlock.getKey()
        });
      }
      acc.push(new ContentBlockRecord(blockNodeConfig));
      return acc;
    }, []);
  }
};
var DraftPasteProcessor_1 = DraftPasteProcessor$1;
function adjustBlockDepthForContentState$1(contentState, selectionState, adjustment, maxDepth) {
  var startKey = selectionState.getStartKey();
  var endKey = selectionState.getEndKey();
  var blockMap = contentState.getBlockMap();
  var blocks = blockMap.toSeq().skipUntil(function(_, k) {
    return k === startKey;
  }).takeUntil(function(_, k) {
    return k === endKey;
  }).concat([[endKey, blockMap.get(endKey)]]).map(function(block) {
    var depth = block.getDepth() + adjustment;
    depth = Math.max(0, Math.min(depth, maxDepth));
    return block.set("depth", depth);
  });
  blockMap = blockMap.merge(blocks);
  return contentState.merge({
    blockMap,
    selectionBefore: selectionState,
    selectionAfter: selectionState
  });
}
var adjustBlockDepthForContentState_1 = adjustBlockDepthForContentState$1;
var DraftModifier$2 = DraftModifier_1;
var EditorState$3 = EditorState_1;
var adjustBlockDepthForContentState = adjustBlockDepthForContentState_1;
var nullthrows$2 = nullthrows_1;
var RichTextEditorUtil$2 = {
  currentBlockContainsLink: function currentBlockContainsLink(editorState) {
    var selection = editorState.getSelection();
    var contentState = editorState.getCurrentContent();
    var entityMap = contentState.getEntityMap();
    return contentState.getBlockForKey(selection.getAnchorKey()).getCharacterList().slice(selection.getStartOffset(), selection.getEndOffset()).some(function(v) {
      var entity = v.getEntity();
      return !!entity && entityMap.__get(entity).getType() === "LINK";
    });
  },
  getCurrentBlockType: function getCurrentBlockType(editorState) {
    var selection = editorState.getSelection();
    return editorState.getCurrentContent().getBlockForKey(selection.getStartKey()).getType();
  },
  getDataObjectForLinkURL: function getDataObjectForLinkURL(uri) {
    return {
      url: uri.toString()
    };
  },
  handleKeyCommand: function handleKeyCommand(editorState, command, eventTimeStamp) {
    switch (command) {
      case "bold":
        return RichTextEditorUtil$2.toggleInlineStyle(editorState, "BOLD");
      case "italic":
        return RichTextEditorUtil$2.toggleInlineStyle(editorState, "ITALIC");
      case "underline":
        return RichTextEditorUtil$2.toggleInlineStyle(editorState, "UNDERLINE");
      case "code":
        return RichTextEditorUtil$2.toggleCode(editorState);
      case "backspace":
      case "backspace-word":
      case "backspace-to-start-of-line":
        return RichTextEditorUtil$2.onBackspace(editorState);
      case "delete":
      case "delete-word":
      case "delete-to-end-of-block":
        return RichTextEditorUtil$2.onDelete(editorState);
      default:
        return null;
    }
  },
  insertSoftNewline: function insertSoftNewline(editorState) {
    var contentState = DraftModifier$2.insertText(editorState.getCurrentContent(), editorState.getSelection(), "\n", editorState.getCurrentInlineStyle(), null);
    var newEditorState = EditorState$3.push(editorState, contentState, "insert-characters");
    return EditorState$3.forceSelection(newEditorState, contentState.getSelectionAfter());
  },
  onBackspace: function onBackspace(editorState) {
    var selection = editorState.getSelection();
    if (!selection.isCollapsed() || selection.getAnchorOffset() || selection.getFocusOffset()) {
      return null;
    }
    var content = editorState.getCurrentContent();
    var startKey = selection.getStartKey();
    var blockBefore = content.getBlockBefore(startKey);
    if (blockBefore && blockBefore.getType() === "atomic") {
      var blockMap = content.getBlockMap()["delete"](blockBefore.getKey());
      var withoutAtomicBlock = content.merge({
        blockMap,
        selectionAfter: selection
      });
      if (withoutAtomicBlock !== content) {
        return EditorState$3.push(editorState, withoutAtomicBlock, "remove-range");
      }
    }
    var withoutBlockStyle = RichTextEditorUtil$2.tryToRemoveBlockStyle(editorState);
    if (withoutBlockStyle) {
      return EditorState$3.push(editorState, withoutBlockStyle, "change-block-type");
    }
    return null;
  },
  onDelete: function onDelete(editorState) {
    var selection = editorState.getSelection();
    if (!selection.isCollapsed()) {
      return null;
    }
    var content = editorState.getCurrentContent();
    var startKey = selection.getStartKey();
    var block = content.getBlockForKey(startKey);
    var length = block.getLength();
    if (selection.getStartOffset() < length) {
      return null;
    }
    var blockAfter = content.getBlockAfter(startKey);
    if (!blockAfter || blockAfter.getType() !== "atomic") {
      return null;
    }
    var atomicBlockTarget = selection.merge({
      focusKey: blockAfter.getKey(),
      focusOffset: blockAfter.getLength()
    });
    var withoutAtomicBlock = DraftModifier$2.removeRange(content, atomicBlockTarget, "forward");
    if (withoutAtomicBlock !== content) {
      return EditorState$3.push(editorState, withoutAtomicBlock, "remove-range");
    }
    return null;
  },
  onTab: function onTab(event, editorState, maxDepth) {
    var selection = editorState.getSelection();
    var key = selection.getAnchorKey();
    if (key !== selection.getFocusKey()) {
      return editorState;
    }
    var content = editorState.getCurrentContent();
    var block = content.getBlockForKey(key);
    var type = block.getType();
    if (type !== "unordered-list-item" && type !== "ordered-list-item") {
      return editorState;
    }
    event.preventDefault();
    var depth = block.getDepth();
    if (!event.shiftKey && depth === maxDepth) {
      return editorState;
    }
    var withAdjustment = adjustBlockDepthForContentState(content, selection, event.shiftKey ? -1 : 1, maxDepth);
    return EditorState$3.push(editorState, withAdjustment, "adjust-depth");
  },
  toggleBlockType: function toggleBlockType(editorState, blockType) {
    var selection = editorState.getSelection();
    var startKey = selection.getStartKey();
    var endKey = selection.getEndKey();
    var content = editorState.getCurrentContent();
    var target = selection;
    if (startKey !== endKey && selection.getEndOffset() === 0) {
      var blockBefore = nullthrows$2(content.getBlockBefore(endKey));
      endKey = blockBefore.getKey();
      target = target.merge({
        anchorKey: startKey,
        anchorOffset: selection.getStartOffset(),
        focusKey: endKey,
        focusOffset: blockBefore.getLength(),
        isBackward: false
      });
    }
    var hasAtomicBlock = content.getBlockMap().skipWhile(function(_, k) {
      return k !== startKey;
    }).reverse().skipWhile(function(_, k) {
      return k !== endKey;
    }).some(function(v) {
      return v.getType() === "atomic";
    });
    if (hasAtomicBlock) {
      return editorState;
    }
    var typeToSet = content.getBlockForKey(startKey).getType() === blockType ? "unstyled" : blockType;
    return EditorState$3.push(editorState, DraftModifier$2.setBlockType(content, target, typeToSet), "change-block-type");
  },
  toggleCode: function toggleCode(editorState) {
    var selection = editorState.getSelection();
    var anchorKey = selection.getAnchorKey();
    var focusKey = selection.getFocusKey();
    if (selection.isCollapsed() || anchorKey !== focusKey) {
      return RichTextEditorUtil$2.toggleBlockType(editorState, "code-block");
    }
    return RichTextEditorUtil$2.toggleInlineStyle(editorState, "CODE");
  },
  toggleInlineStyle: function toggleInlineStyle(editorState, inlineStyle) {
    var selection = editorState.getSelection();
    var currentStyle = editorState.getCurrentInlineStyle();
    if (selection.isCollapsed()) {
      return EditorState$3.setInlineStyleOverride(editorState, currentStyle.has(inlineStyle) ? currentStyle.remove(inlineStyle) : currentStyle.add(inlineStyle));
    }
    var content = editorState.getCurrentContent();
    var newContent;
    if (currentStyle.has(inlineStyle)) {
      newContent = DraftModifier$2.removeInlineStyle(content, selection, inlineStyle);
    } else {
      newContent = DraftModifier$2.applyInlineStyle(content, selection, inlineStyle);
    }
    return EditorState$3.push(editorState, newContent, "change-inline-style");
  },
  toggleLink: function toggleLink(editorState, targetSelection, entityKey) {
    var withoutLink = DraftModifier$2.applyEntity(editorState.getCurrentContent(), targetSelection, entityKey);
    return EditorState$3.push(editorState, withoutLink, "apply-entity");
  },
  tryToRemoveBlockStyle: function tryToRemoveBlockStyle(editorState) {
    var selection = editorState.getSelection();
    var offset = selection.getAnchorOffset();
    if (selection.isCollapsed() && offset === 0) {
      var key = selection.getAnchorKey();
      var content = editorState.getCurrentContent();
      var block = content.getBlockForKey(key);
      var type = block.getType();
      var blockBefore = content.getBlockBefore(key);
      if (type === "code-block" && blockBefore && blockBefore.getType() === "code-block" && blockBefore.getLength() !== 0) {
        return null;
      }
      if (type !== "unstyled") {
        return DraftModifier$2.setBlockType(content, selection, "unstyled");
      }
    }
    return null;
  }
};
var RichTextEditorUtil_1 = RichTextEditorUtil$2;
var NEWLINE_REGEX = /\r\n?|\n/g;
function splitTextIntoTextBlocks$1(text) {
  return text.split(NEWLINE_REGEX);
}
var splitTextIntoTextBlocks_1 = splitTextIntoTextBlocks$1;
var BlockMapBuilder$1 = BlockMapBuilder_1;
var CharacterMetadata$2 = CharacterMetadata_1;
var DataTransfer = DataTransfer_1;
var DraftModifier$1 = DraftModifier_1;
var DraftPasteProcessor = DraftPasteProcessor_1;
var EditorState$2 = EditorState_1;
var RichTextEditorUtil$1 = RichTextEditorUtil_1;
var getEntityKeyForSelection = getEntityKeyForSelection_1;
var getTextContentFromFiles = getTextContentFromFiles_1;
var isEventHandled = isEventHandled_1;
var splitTextIntoTextBlocks = splitTextIntoTextBlocks_1;
function editOnPaste(editor, e) {
  e.preventDefault();
  var data = new DataTransfer(e.clipboardData);
  if (!data.isRichText()) {
    var files = data.getFiles();
    var defaultFileText = data.getText();
    if (files.length > 0) {
      if (editor.props.handlePastedFiles && isEventHandled(editor.props.handlePastedFiles(files))) {
        return;
      }
      getTextContentFromFiles(files, function(fileText) {
        fileText = fileText || defaultFileText;
        if (!fileText) {
          return;
        }
        var editorState2 = editor._latestEditorState;
        var blocks = splitTextIntoTextBlocks(fileText);
        var character2 = CharacterMetadata$2.create({
          style: editorState2.getCurrentInlineStyle(),
          entity: getEntityKeyForSelection(editorState2.getCurrentContent(), editorState2.getSelection())
        });
        var currentBlockType2 = RichTextEditorUtil$1.getCurrentBlockType(editorState2);
        var text2 = DraftPasteProcessor.processText(blocks, character2, currentBlockType2);
        var fragment = BlockMapBuilder$1.createFromArray(text2);
        var withInsertedText = DraftModifier$1.replaceWithFragment(editorState2.getCurrentContent(), editorState2.getSelection(), fragment);
        editor.update(EditorState$2.push(editorState2, withInsertedText, "insert-fragment"));
      });
      return;
    }
  }
  var textBlocks = [];
  var text = data.getText();
  var html = data.getHTML();
  var editorState = editor._latestEditorState;
  if (editor.props.formatPastedText) {
    var _editor$props$formatP = editor.props.formatPastedText(text, html), formattedText = _editor$props$formatP.text, formattedHtml = _editor$props$formatP.html;
    text = formattedText;
    html = formattedHtml;
  }
  if (editor.props.handlePastedText && isEventHandled(editor.props.handlePastedText(text, html, editorState))) {
    return;
  }
  if (text) {
    textBlocks = splitTextIntoTextBlocks(text);
  }
  if (!editor.props.stripPastedStyles) {
    var internalClipboard = editor.getClipboard();
    if (!editor.props.formatPastedText && data.isRichText() && internalClipboard) {
      var _html;
      if (((_html = html) === null || _html === void 0 ? void 0 : _html.indexOf(editor.getEditorKey())) !== -1 || textBlocks.length === 1 && internalClipboard.size === 1 && internalClipboard.first().getText() === text) {
        editor.update(insertFragment2(editor._latestEditorState, internalClipboard));
        return;
      }
    } else if (internalClipboard && data.types.includes("com.apple.webarchive") && !data.types.includes("text/html") && areTextBlocksAndClipboardEqual(textBlocks, internalClipboard)) {
      editor.update(insertFragment2(editor._latestEditorState, internalClipboard));
      return;
    }
    if (html) {
      var htmlFragment = DraftPasteProcessor.processHTML(html, editor.props.blockRenderMap);
      if (htmlFragment) {
        var contentBlocks = htmlFragment.contentBlocks, entityMap = htmlFragment.entityMap;
        if (contentBlocks) {
          var htmlMap = BlockMapBuilder$1.createFromArray(contentBlocks);
          editor.update(insertFragment2(editor._latestEditorState, htmlMap, entityMap));
          return;
        }
      }
    }
    editor.setClipboard(null);
  }
  if (textBlocks.length) {
    var character = CharacterMetadata$2.create({
      style: editorState.getCurrentInlineStyle(),
      entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())
    });
    var currentBlockType = RichTextEditorUtil$1.getCurrentBlockType(editorState);
    var textFragment = DraftPasteProcessor.processText(textBlocks, character, currentBlockType);
    var textMap = BlockMapBuilder$1.createFromArray(textFragment);
    editor.update(insertFragment2(editor._latestEditorState, textMap));
  }
}
function insertFragment2(editorState, fragment, entityMap) {
  var newContent = DraftModifier$1.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);
  return EditorState$2.push(editorState, newContent.set("entityMap", entityMap), "insert-fragment");
}
function areTextBlocksAndClipboardEqual(textBlocks, blockMap) {
  return textBlocks.length === blockMap.size && blockMap.valueSeq().every(function(block, ii) {
    return block.getText() === textBlocks[ii];
  });
}
var editOnPaste_1 = editOnPaste;
var UserAgent$2 = UserAgent_1;
var onBeforeInput = editOnBeforeInput_1;
var onBlur = editOnBlur_1;
var onCompositionStart2 = editOnCompositionStart_1;
var onCopy = editOnCopy_1;
var onCut = editOnCut_1;
var onDragOver = editOnDragOver_1;
var onDragStart = editOnDragStart_1;
var onFocus = editOnFocus_1;
var onInput = editOnInput_1;
var onKeyDown2 = editOnKeyDown_1;
var onPaste = editOnPaste_1;
var onSelect = editOnSelect_1;
var isChrome = UserAgent$2.isBrowser("Chrome");
var isFirefox = UserAgent$2.isBrowser("Firefox");
var selectionHandler = isChrome || isFirefox ? onSelect : function(e) {
};
var DraftEditorEditHandler$1 = {
  onBeforeInput,
  onBlur,
  onCompositionStart: onCompositionStart2,
  onCopy,
  onCut,
  onDragOver,
  onDragStart,
  onFocus,
  onInput,
  onKeyDown: onKeyDown2,
  onPaste,
  onSelect,
  onMouseUp: selectionHandler,
  onKeyUp: selectionHandler
};
var DraftEditorEditHandler_1 = DraftEditorEditHandler$1;
var ReactDOMComet = require$$0$2;
var flushControlled$1 = ReactDOMComet.unstable_flushControlled;
var DraftEditorFlushControlled = flushControlled$1;
var _jsx$1 = require$$0$1.jsx;
function _inheritsLoose$1(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var React$1 = React$a;
var cx$1 = cx_1;
var DraftEditorPlaceholder$1 = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(DraftEditorPlaceholder2, _React$Component);
  function DraftEditorPlaceholder2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = DraftEditorPlaceholder2.prototype;
  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
    return this.props.text !== nextProps.text || this.props.editorState.getSelection().getHasFocus() !== nextProps.editorState.getSelection().getHasFocus();
  };
  _proto.render = function render() {
    var hasFocus = this.props.editorState.getSelection().getHasFocus();
    var className = cx$1({
      "public/DraftEditorPlaceholder/root": true,
      "public/DraftEditorPlaceholder/hasFocus": hasFocus
    });
    var contentStyle = {
      whiteSpace: "pre-wrap"
    };
    return /* @__PURE__ */ _jsx$1("div", {
      className,
      children: /* @__PURE__ */ _jsx$1("div", {
        className: cx$1("public/DraftEditorPlaceholder/inner"),
        id: this.props.accessibilityID,
        style: contentStyle,
        children: this.props.text
      })
    });
  };
  return DraftEditorPlaceholder2;
}(React$1.Component);
var DraftEditorPlaceholder_react = DraftEditorPlaceholder$1;
var KeyBindingUtil$1 = KeyBindingUtil_1;
var Keys = Keys$4;
var UserAgent$1 = UserAgent_1;
var isOSX = UserAgent$1.isPlatform("Mac OS X");
var shouldFixFirefoxMovement = isOSX && UserAgent$1.isBrowser("Firefox < 29");
var hasCommandModifier2 = KeyBindingUtil$1.hasCommandModifier, isCtrlKeyCommand2 = KeyBindingUtil$1.isCtrlKeyCommand;
function shouldRemoveWord(e) {
  return isOSX && e.altKey || isCtrlKeyCommand2(e);
}
function getZCommand(e) {
  if (!hasCommandModifier2(e)) {
    return null;
  }
  return e.shiftKey ? "redo" : "undo";
}
function getDeleteCommand(e) {
  if (!isOSX && e.shiftKey) {
    return null;
  }
  return shouldRemoveWord(e) ? "delete-word" : "delete";
}
function getBackspaceCommand(e) {
  if (hasCommandModifier2(e) && isOSX) {
    return "backspace-to-start-of-line";
  }
  return shouldRemoveWord(e) ? "backspace-word" : "backspace";
}
function getDefaultKeyBinding$2(e) {
  switch (e.keyCode) {
    case 66:
      return hasCommandModifier2(e) ? "bold" : null;
    case 68:
      return isCtrlKeyCommand2(e) ? "delete" : null;
    case 72:
      return isCtrlKeyCommand2(e) ? "backspace" : null;
    case 73:
      return hasCommandModifier2(e) ? "italic" : null;
    case 74:
      return hasCommandModifier2(e) ? "code" : null;
    case 75:
      return isOSX && isCtrlKeyCommand2(e) ? "secondary-cut" : null;
    case 77:
      return isCtrlKeyCommand2(e) ? "split-block" : null;
    case 79:
      return isCtrlKeyCommand2(e) ? "split-block" : null;
    case 84:
      return isOSX && isCtrlKeyCommand2(e) ? "transpose-characters" : null;
    case 85:
      return hasCommandModifier2(e) ? "underline" : null;
    case 87:
      return isOSX && isCtrlKeyCommand2(e) ? "backspace-word" : null;
    case 89:
      if (isCtrlKeyCommand2(e)) {
        return isOSX ? "secondary-paste" : "redo";
      }
      return null;
    case 90:
      return getZCommand(e) || null;
    case Keys.RETURN:
      return "split-block";
    case Keys.DELETE:
      return getDeleteCommand(e);
    case Keys.BACKSPACE:
      return getBackspaceCommand(e);
    case Keys.LEFT:
      return shouldFixFirefoxMovement && hasCommandModifier2(e) ? "move-selection-to-start-of-block" : null;
    case Keys.RIGHT:
      return shouldFixFirefoxMovement && hasCommandModifier2(e) ? "move-selection-to-end-of-block" : null;
    default:
      return null;
  }
}
var getDefaultKeyBinding_1 = getDefaultKeyBinding$2;
var _jsx = require$$0$1.jsx;
var _createElement = React$a.createElement;
var _jsxs = require$$0$1.jsxs;
function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty$6(target, key, source[key]);
    });
  }
  return target;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _defineProperty$6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var DefaultDraftBlockRenderMap$1 = DefaultDraftBlockRenderMap_1;
var DefaultDraftInlineStyle$1 = DefaultDraftInlineStyle$2;
var DraftEditorCompositionHandler = DraftEditorCompositionHandler_1;
var DraftEditorContents = DraftEditorContents_react;
var DraftEditorDragHandler = DraftEditorDragHandler_1;
var DraftEditorEditHandler = DraftEditorEditHandler_1;
var flushControlled = DraftEditorFlushControlled;
var DraftEditorPlaceholder = DraftEditorPlaceholder_react;
var EditorState$1 = EditorState_1;
var React = React$a;
var Scroll = Scroll_1;
var Style = Style_1;
var UserAgent = UserAgent_1;
var cx = cx_1;
var generateRandomKey$3 = generateRandomKey_1;
var getDefaultKeyBinding$1 = getDefaultKeyBinding_1;
var getScrollPosition = getScrollPosition_1;
var gkx$1 = gkx$8;
var invariant$4 = invariant_1;
var isHTMLElement = isHTMLElement_1;
var nullthrows$1 = nullthrows_1;
var isIE = UserAgent.isBrowser("IE");
var allowSpellCheck = !isIE;
var handlerMap = {
  edit: DraftEditorEditHandler,
  composite: DraftEditorCompositionHandler,
  drag: DraftEditorDragHandler,
  cut: null,
  render: null
};
var didInitODS = false;
var UpdateDraftEditorFlags = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(UpdateDraftEditorFlags2, _React$Component);
  function UpdateDraftEditorFlags2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = UpdateDraftEditorFlags2.prototype;
  _proto.render = function render() {
    return null;
  };
  _proto.componentDidMount = function componentDidMount() {
    this._update();
  };
  _proto.componentDidUpdate = function componentDidUpdate() {
    this._update();
  };
  _proto._update = function _update() {
    var editor = this.props.editor;
    editor._latestEditorState = this.props.editorState;
    editor._blockSelectEvents = true;
  };
  return UpdateDraftEditorFlags2;
}(React.Component);
var DraftEditor$1 = /* @__PURE__ */ function(_React$Component2) {
  _inheritsLoose(DraftEditor2, _React$Component2);
  function DraftEditor2(props) {
    var _this;
    _this = _React$Component2.call(this, props) || this;
    _defineProperty$6(_assertThisInitialized(_this), "_blockSelectEvents", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_clipboard", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_handler", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_dragCount", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_internalDrag", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_editorKey", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_placeholderAccessibilityID", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_latestEditorState", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_latestCommittedEditorState", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_pendingStateFromBeforeInput", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_onBeforeInput", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_onBlur", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_onCharacterData", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_onCompositionEnd", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_onCompositionStart", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_onCopy", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_onCut", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_onDragEnd", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_onDragOver", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_onDragStart", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_onDrop", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_onInput", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_onFocus", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_onKeyDown", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_onKeyPress", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_onKeyUp", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_onMouseDown", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_onMouseUp", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_onPaste", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_onSelect", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "editor", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "editorContainer", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "focus", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "blur", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "setMode", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "exitCurrentMode", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "restoreEditorDOM", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "setClipboard", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "getClipboard", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "getEditorKey", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "update", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "onDragEnter", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "onDragLeave", void 0);
    _defineProperty$6(_assertThisInitialized(_this), "_handleEditorContainerRef", function(node) {
      _this.editorContainer = node;
      _this.editor = node !== null ? node.firstChild : null;
    });
    _defineProperty$6(_assertThisInitialized(_this), "focus", function(scrollPosition) {
      var editorState = _this.props.editorState;
      var alreadyHasFocus = editorState.getSelection().getHasFocus();
      var editorNode = _this.editor;
      if (!editorNode) {
        return;
      }
      var scrollParent = Style.getScrollParent(editorNode);
      var _ref = scrollPosition || getScrollPosition(scrollParent), x = _ref.x, y = _ref.y;
      !isHTMLElement(editorNode) ? invariant$4(false) : void 0;
      editorNode.focus();
      if (scrollParent === window) {
        window.scrollTo(x, y);
      } else {
        Scroll.setTop(scrollParent, y);
      }
      if (!alreadyHasFocus) {
        _this.update(EditorState$1.forceSelection(editorState, editorState.getSelection()));
      }
    });
    _defineProperty$6(_assertThisInitialized(_this), "blur", function() {
      var editorNode = _this.editor;
      if (!editorNode) {
        return;
      }
      !isHTMLElement(editorNode) ? invariant$4(false) : void 0;
      editorNode.blur();
    });
    _defineProperty$6(_assertThisInitialized(_this), "setMode", function(mode) {
      var _this$props = _this.props, onPaste2 = _this$props.onPaste, onCut2 = _this$props.onCut, onCopy2 = _this$props.onCopy;
      var editHandler = _objectSpread$5({}, handlerMap.edit);
      if (onPaste2) {
        editHandler.onPaste = onPaste2;
      }
      if (onCut2) {
        editHandler.onCut = onCut2;
      }
      if (onCopy2) {
        editHandler.onCopy = onCopy2;
      }
      var handler = _objectSpread$5({}, handlerMap, {
        edit: editHandler
      });
      _this._handler = handler[mode];
    });
    _defineProperty$6(_assertThisInitialized(_this), "exitCurrentMode", function() {
      _this.setMode("edit");
    });
    _defineProperty$6(_assertThisInitialized(_this), "restoreEditorDOM", function(scrollPosition) {
      _this.setState({
        contentsKey: _this.state.contentsKey + 1
      }, function() {
        _this.focus(scrollPosition);
      });
    });
    _defineProperty$6(_assertThisInitialized(_this), "setClipboard", function(clipboard2) {
      _this._clipboard = clipboard2;
    });
    _defineProperty$6(_assertThisInitialized(_this), "getClipboard", function() {
      return _this._clipboard;
    });
    _defineProperty$6(_assertThisInitialized(_this), "update", function(editorState) {
      _this._latestEditorState = editorState;
      _this.props.onChange(editorState);
    });
    _defineProperty$6(_assertThisInitialized(_this), "onDragEnter", function() {
      _this._dragCount++;
    });
    _defineProperty$6(_assertThisInitialized(_this), "onDragLeave", function() {
      _this._dragCount--;
      if (_this._dragCount === 0) {
        _this.exitCurrentMode();
      }
    });
    _this._blockSelectEvents = false;
    _this._clipboard = null;
    _this._handler = null;
    _this._dragCount = 0;
    _this._editorKey = props.editorKey || generateRandomKey$3();
    _this._placeholderAccessibilityID = "placeholder-" + _this._editorKey;
    _this._latestEditorState = props.editorState;
    _this._latestCommittedEditorState = props.editorState;
    _this._onBeforeInput = _this._buildHandler("onBeforeInput");
    _this._onBlur = _this._buildHandler("onBlur");
    _this._onCharacterData = _this._buildHandler("onCharacterData");
    _this._onCompositionEnd = _this._buildHandler("onCompositionEnd");
    _this._onCompositionStart = _this._buildHandler("onCompositionStart");
    _this._onCopy = _this._buildHandler("onCopy");
    _this._onCut = _this._buildHandler("onCut");
    _this._onDragEnd = _this._buildHandler("onDragEnd");
    _this._onDragOver = _this._buildHandler("onDragOver");
    _this._onDragStart = _this._buildHandler("onDragStart");
    _this._onDrop = _this._buildHandler("onDrop");
    _this._onInput = _this._buildHandler("onInput");
    _this._onFocus = _this._buildHandler("onFocus");
    _this._onKeyDown = _this._buildHandler("onKeyDown");
    _this._onKeyPress = _this._buildHandler("onKeyPress");
    _this._onKeyUp = _this._buildHandler("onKeyUp");
    _this._onMouseDown = _this._buildHandler("onMouseDown");
    _this._onMouseUp = _this._buildHandler("onMouseUp");
    _this._onPaste = _this._buildHandler("onPaste");
    _this._onSelect = _this._buildHandler("onSelect");
    _this.getEditorKey = function() {
      return _this._editorKey;
    };
    _this.state = {
      contentsKey: 0
    };
    return _this;
  }
  var _proto2 = DraftEditor2.prototype;
  _proto2._buildHandler = function _buildHandler(eventName) {
    var _this2 = this;
    return function(e) {
      if (!_this2.props.readOnly) {
        var method = _this2._handler && _this2._handler[eventName];
        if (method) {
          if (flushControlled) {
            flushControlled(function() {
              return method(_this2, e);
            });
          } else {
            method(_this2, e);
          }
        }
      }
    };
  };
  _proto2._showPlaceholder = function _showPlaceholder() {
    return !!this.props.placeholder && !this.props.editorState.isInCompositionMode() && !this.props.editorState.getCurrentContent().hasText();
  };
  _proto2._renderPlaceholder = function _renderPlaceholder() {
    if (this._showPlaceholder()) {
      var placeHolderProps = {
        text: nullthrows$1(this.props.placeholder),
        editorState: this.props.editorState,
        textAlignment: this.props.textAlignment,
        accessibilityID: this._placeholderAccessibilityID
      };
      return /* @__PURE__ */ _jsx(DraftEditorPlaceholder, __spreadValues({}, placeHolderProps));
    }
    return null;
  };
  _proto2._renderARIADescribedBy = function _renderARIADescribedBy() {
    var describedBy = this.props.ariaDescribedBy || "";
    var placeholderID = this._showPlaceholder() ? this._placeholderAccessibilityID : "";
    return describedBy.replace("{{editor_id_placeholder}}", placeholderID) || void 0;
  };
  _proto2.render = function render() {
    var _this$props2 = this.props, blockRenderMap2 = _this$props2.blockRenderMap, blockRendererFn2 = _this$props2.blockRendererFn, blockStyleFn2 = _this$props2.blockStyleFn, customStyleFn = _this$props2.customStyleFn, customStyleMap = _this$props2.customStyleMap, editorState = _this$props2.editorState, preventScroll = _this$props2.preventScroll, readOnly = _this$props2.readOnly, textAlignment = _this$props2.textAlignment, textDirectionality = _this$props2.textDirectionality;
    var rootClass = cx({
      "DraftEditor/root": true,
      "DraftEditor/alignLeft": textAlignment === "left",
      "DraftEditor/alignRight": textAlignment === "right",
      "DraftEditor/alignCenter": textAlignment === "center"
    });
    var contentStyle = {
      outline: "none",
      userSelect: "text",
      WebkitUserSelect: "text",
      whiteSpace: "pre-wrap",
      wordWrap: "break-word"
    };
    var ariaRole = this.props.role || "textbox";
    var ariaExpanded = ariaRole === "combobox" ? !!this.props.ariaExpanded : null;
    var editorContentsProps = {
      blockRenderMap: blockRenderMap2,
      blockRendererFn: blockRendererFn2,
      blockStyleFn: blockStyleFn2,
      customStyleMap: _objectSpread$5({}, DefaultDraftInlineStyle$1, customStyleMap),
      customStyleFn,
      editorKey: this._editorKey,
      editorState,
      preventScroll,
      textDirectionality
    };
    return /* @__PURE__ */ _jsxs("div", {
      className: rootClass,
      children: [this._renderPlaceholder(), /* @__PURE__ */ _jsx("div", {
        className: cx("DraftEditor/editorContainer"),
        ref: this._handleEditorContainerRef,
        children: /* @__PURE__ */ _jsxs("div", {
          "aria-activedescendant": readOnly ? null : this.props.ariaActiveDescendantID,
          "aria-autocomplete": readOnly ? null : this.props.ariaAutoComplete,
          "aria-controls": readOnly ? null : this.props.ariaControls,
          "aria-describedby": this._renderARIADescribedBy(),
          "aria-expanded": readOnly ? null : ariaExpanded,
          "aria-label": this.props.ariaLabel,
          "aria-labelledby": this.props.ariaLabelledBy,
          "aria-multiline": this.props.ariaMultiline,
          "aria-owns": readOnly ? null : this.props.ariaOwneeID,
          autoCapitalize: this.props.autoCapitalize,
          autoComplete: this.props.autoComplete,
          autoCorrect: this.props.autoCorrect,
          className: cx({
            notranslate: !readOnly,
            "public/DraftEditor/content": true
          }),
          contentEditable: !readOnly,
          "data-testid": this.props.webDriverTestID,
          onBeforeInput: this._onBeforeInput,
          onBlur: this._onBlur,
          onCompositionEnd: this._onCompositionEnd,
          onCompositionStart: this._onCompositionStart,
          onCopy: this._onCopy,
          onCut: this._onCut,
          onDragEnd: this._onDragEnd,
          onDragEnter: this.onDragEnter,
          onDragLeave: this.onDragLeave,
          onDragOver: this._onDragOver,
          onDragStart: this._onDragStart,
          onDrop: this._onDrop,
          onFocus: this._onFocus,
          onInput: this._onInput,
          onKeyDown: this._onKeyDown,
          onKeyPress: this._onKeyPress,
          onKeyUp: this._onKeyUp,
          onMouseUp: this._onMouseUp,
          onPaste: this._onPaste,
          onSelect: this._onSelect,
          ref: this.props.editorRef,
          role: readOnly ? null : ariaRole,
          spellCheck: allowSpellCheck && this.props.spellCheck,
          style: contentStyle,
          suppressContentEditableWarning: true,
          tabIndex: this.props.tabIndex,
          children: [/* @__PURE__ */ _jsx(UpdateDraftEditorFlags, {
            editor: this,
            editorState
          }), /* @__PURE__ */ _createElement(DraftEditorContents, __spreadProps(__spreadValues({}, editorContentsProps), {
            key: "contents" + this.state.contentsKey
          }))]
        })
      })]
    });
  };
  _proto2.componentDidMount = function componentDidMount() {
    this._blockSelectEvents = false;
    if (!didInitODS && gkx$1("draft_ods_enabled")) {
      didInitODS = true;
    }
    this.setMode("edit");
    if (isIE) {
      if (!this.editor) {
        commonjsGlobal.execCommand("AutoUrlDetect", false, false);
      } else {
        this.editor.ownerDocument.execCommand("AutoUrlDetect", false, false);
      }
    }
  };
  _proto2.componentDidUpdate = function componentDidUpdate() {
    this._blockSelectEvents = false;
    this._latestEditorState = this.props.editorState;
    this._latestCommittedEditorState = this.props.editorState;
  };
  return DraftEditor2;
}(React.Component);
_defineProperty$6(DraftEditor$1, "defaultProps", {
  ariaDescribedBy: "{{editor_id_placeholder}}",
  blockRenderMap: DefaultDraftBlockRenderMap$1,
  blockRendererFn: function blockRendererFn() {
    return null;
  },
  blockStyleFn: function blockStyleFn() {
    return "";
  },
  keyBindingFn: getDefaultKeyBinding$1,
  readOnly: false,
  spellCheck: false,
  stripPastedStyles: false
});
var DraftEditor_react = DraftEditor$1;
var RawDraftContentState$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module"
});
var require$$15 = /* @__PURE__ */ getAugmentedNamespace(RawDraftContentState$1);
var DraftStringKey$2 = {
  stringify: function stringify(key) {
    return "_" + String(key);
  },
  unstringify: function unstringify(key) {
    return key.slice(1);
  }
};
var DraftStringKey_1 = DraftStringKey$2;
var DraftStringKey$1 = DraftStringKey_1;
var UnicodeUtils$3 = UnicodeUtils_1;
var strlen = UnicodeUtils$3.strlen;
function encodeEntityRanges$1(block, storageMap) {
  var encoded = [];
  block.findEntityRanges(function(character) {
    return !!character.getEntity();
  }, function(start, end) {
    var text = block.getText();
    var key = block.getEntityAt(start);
    encoded.push({
      offset: strlen(text.slice(0, start)),
      length: strlen(text.slice(start, end)),
      key: Number(storageMap[DraftStringKey$1.stringify(key)])
    });
  });
  return encoded;
}
var encodeEntityRanges_1 = encodeEntityRanges$1;
var UnicodeUtils$2 = UnicodeUtils_1;
var findRangesImmutable = findRangesImmutable_1;
var areEqual = function areEqual2(a, b) {
  return a === b;
};
var isTruthy = function isTruthy2(a) {
  return !!a;
};
var EMPTY_ARRAY = [];
function getEncodedInlinesForType(block, styleList, styleToEncode) {
  var ranges = [];
  var filteredInlines = styleList.map(function(style) {
    return style.has(styleToEncode);
  }).toList();
  findRangesImmutable(filteredInlines, areEqual, isTruthy, function(start, end) {
    var text = block.getText();
    ranges.push({
      offset: UnicodeUtils$2.strlen(text.slice(0, start)),
      length: UnicodeUtils$2.strlen(text.slice(start, end)),
      style: styleToEncode
    });
  });
  return ranges;
}
function encodeInlineStyleRanges$1(block) {
  var styleList = block.getCharacterList().map(function(c) {
    return c.getStyle();
  }).toList();
  var ranges = styleList.flatten().toSet().map(function(style) {
    return getEncodedInlinesForType(block, styleList, style);
  });
  return Array.prototype.concat.apply(EMPTY_ARRAY, ranges.toJS());
}
var encodeInlineStyleRanges_1 = encodeInlineStyleRanges$1;
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty$5(target, key, source[key]);
    });
  }
  return target;
}
function _defineProperty$5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ContentBlock$2 = ContentBlock_1;
var ContentBlockNode$1 = ContentBlockNode_1;
var DraftStringKey = DraftStringKey_1;
var encodeEntityRanges = encodeEntityRanges_1;
var encodeInlineStyleRanges = encodeInlineStyleRanges_1;
var invariant$3 = invariant_1;
var createRawBlock = function createRawBlock2(block, entityStorageMap) {
  return {
    key: block.getKey(),
    text: block.getText(),
    type: block.getType(),
    depth: block.getDepth(),
    inlineStyleRanges: encodeInlineStyleRanges(block),
    entityRanges: encodeEntityRanges(block, entityStorageMap),
    data: block.getData().toObject()
  };
};
var insertRawBlock = function insertRawBlock2(block, entityMap, rawBlocks, blockCacheRef) {
  if (block instanceof ContentBlock$2) {
    rawBlocks.push(createRawBlock(block, entityMap));
    return;
  }
  !(block instanceof ContentBlockNode$1) ? invariant$3(false) : void 0;
  var parentKey = block.getParentKey();
  var rawBlock = blockCacheRef[block.getKey()] = _objectSpread$4({}, createRawBlock(block, entityMap), {
    children: []
  });
  if (parentKey) {
    blockCacheRef[parentKey].children.push(rawBlock);
    return;
  }
  rawBlocks.push(rawBlock);
};
var encodeRawBlocks = function encodeRawBlocks2(contentState, rawState) {
  var entityMap = rawState.entityMap;
  var rawBlocks = [];
  var blockCacheRef = {};
  var entityCacheRef = {};
  var entityStorageKey = 0;
  contentState.getBlockMap().forEach(function(block) {
    block.findEntityRanges(function(character) {
      return character.getEntity() !== null;
    }, function(start) {
      var entityKey = block.getEntityAt(start);
      var stringifiedEntityKey = DraftStringKey.stringify(entityKey);
      if (entityCacheRef[stringifiedEntityKey]) {
        return;
      }
      entityCacheRef[stringifiedEntityKey] = entityKey;
      entityMap[stringifiedEntityKey] = "".concat(entityStorageKey);
      entityStorageKey++;
    });
    insertRawBlock(block, entityMap, rawBlocks, blockCacheRef);
  });
  return {
    blocks: rawBlocks,
    entityMap
  };
};
var encodeRawEntityMap = function encodeRawEntityMap2(contentState, rawState) {
  var blocks = rawState.blocks, entityMap = rawState.entityMap;
  var rawEntityMap = {};
  Object.keys(entityMap).forEach(function(key, index) {
    var entity = contentState.getEntity(DraftStringKey.unstringify(key));
    rawEntityMap[index] = {
      type: entity.getType(),
      mutability: entity.getMutability(),
      data: entity.getData()
    };
  });
  return {
    blocks,
    entityMap: rawEntityMap
  };
};
var convertFromDraftStateToRaw$1 = function convertFromDraftStateToRaw(contentState) {
  var rawDraftContentState = {
    entityMap: {},
    blocks: []
  };
  rawDraftContentState = encodeRawBlocks(contentState, rawDraftContentState);
  rawDraftContentState = encodeRawEntityMap(contentState, rawDraftContentState);
  return rawDraftContentState;
};
var convertFromDraftStateToRaw_1 = convertFromDraftStateToRaw$1;
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    });
  }
  return target;
}
function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var generateRandomKey$2 = generateRandomKey_1;
var invariant$2 = invariant_1;
var traverseInDepthOrder = function traverseInDepthOrder2(blocks, fn) {
  var stack = [].concat(blocks).reverse();
  while (stack.length) {
    var _block = stack.pop();
    fn(_block);
    var children = _block.children;
    !Array.isArray(children) ? invariant$2(false) : void 0;
    stack = stack.concat([].concat(children.reverse()));
  }
};
var isListBlock = function isListBlock2(block) {
  if (!(block && block.type)) {
    return false;
  }
  var type = block.type;
  return type === "unordered-list-item" || type === "ordered-list-item";
};
var addDepthToChildren = function addDepthToChildren2(block) {
  if (Array.isArray(block.children)) {
    block.children = block.children.map(function(child) {
      return child.type === block.type ? _objectSpread$3({}, child, {
        depth: (block.depth || 0) + 1
      }) : child;
    });
  }
};
var DraftTreeAdapter$1 = {
  fromRawTreeStateToRawState: function fromRawTreeStateToRawState(draftTreeState) {
    var blocks = draftTreeState.blocks;
    var transformedBlocks = [];
    !Array.isArray(blocks) ? invariant$2(false) : void 0;
    if (!Array.isArray(blocks) || !blocks.length) {
      return draftTreeState;
    }
    traverseInDepthOrder(blocks, function(block) {
      var newBlock = _objectSpread$3({}, block);
      if (isListBlock(block)) {
        newBlock.depth = newBlock.depth || 0;
        addDepthToChildren(block);
        if (block.children != null && block.children.length > 0) {
          return;
        }
      }
      delete newBlock.children;
      transformedBlocks.push(newBlock);
    });
    draftTreeState.blocks = transformedBlocks;
    return _objectSpread$3({}, draftTreeState, {
      blocks: transformedBlocks
    });
  },
  fromRawStateToRawTreeState: function fromRawStateToRawTreeState(draftState) {
    var transformedBlocks = [];
    var parentStack = [];
    draftState.blocks.forEach(function(block) {
      var isList2 = isListBlock(block);
      var depth = block.depth || 0;
      var treeBlock = _objectSpread$3({}, block, {
        children: []
      });
      if (!isList2) {
        transformedBlocks.push(treeBlock);
        return;
      }
      var lastParent = parentStack[0];
      if (lastParent == null && depth === 0) {
        transformedBlocks.push(treeBlock);
      } else if (lastParent == null || lastParent.depth < depth - 1) {
        var newParent = {
          key: generateRandomKey$2(),
          text: "",
          depth: depth - 1,
          type: block.type,
          children: [],
          entityRanges: [],
          inlineStyleRanges: []
        };
        parentStack.unshift(newParent);
        if (depth === 1) {
          transformedBlocks.push(newParent);
        } else if (lastParent != null) {
          lastParent.children.push(newParent);
        }
        newParent.children.push(treeBlock);
      } else if (lastParent.depth === depth - 1) {
        lastParent.children.push(treeBlock);
      } else {
        while (lastParent != null && lastParent.depth >= depth) {
          parentStack.shift();
          lastParent = parentStack[0];
        }
        if (depth > 0) {
          lastParent.children.push(treeBlock);
        } else {
          transformedBlocks.push(treeBlock);
        }
      }
    });
    return _objectSpread$3({}, draftState, {
      blocks: transformedBlocks
    });
  }
};
var DraftTreeAdapter_1 = DraftTreeAdapter$1;
var CharacterMetadata$1 = CharacterMetadata_1;
var Immutable$1 = immutable$1.exports;
var List$3 = Immutable$1.List;
function createCharacterList$1(inlineStyles, entities) {
  var characterArray = inlineStyles.map(function(style, ii) {
    var entity = entities[ii];
    return CharacterMetadata$1.create({
      style,
      entity
    });
  });
  return List$3(characterArray);
}
var createCharacterList_1 = createCharacterList$1;
var UnicodeUtils$1 = UnicodeUtils_1;
var substr$1 = UnicodeUtils$1.substr;
function decodeEntityRanges$1(text, ranges) {
  var entities = Array(text.length).fill(null);
  if (ranges) {
    ranges.forEach(function(range) {
      var start = substr$1(text, 0, range.offset).length;
      var end = start + substr$1(text, range.offset, range.length).length;
      for (var ii = start; ii < end; ii++) {
        entities[ii] = range.key;
      }
    });
  }
  return entities;
}
var decodeEntityRanges_1 = decodeEntityRanges$1;
var UnicodeUtils = UnicodeUtils_1;
var _require = immutable$1.exports, OrderedSet$1 = _require.OrderedSet;
var substr = UnicodeUtils.substr;
var EMPTY_SET$2 = OrderedSet$1();
function decodeInlineStyleRanges$1(text, ranges) {
  var styles = Array(text.length).fill(EMPTY_SET$2);
  if (ranges) {
    ranges.forEach(function(range) {
      var cursor = substr(text, 0, range.offset).length;
      var end = cursor + substr(text, range.offset, range.length).length;
      while (cursor < end) {
        styles[cursor] = styles[cursor].add(range.style);
        cursor++;
      }
    });
  }
  return styles;
}
var decodeInlineStyleRanges_1 = decodeInlineStyleRanges$1;
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty$3(target, key, source[key]);
    });
  }
  return target;
}
function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ContentBlock$1 = ContentBlock_1;
var ContentBlockNode = ContentBlockNode_1;
var ContentState$1 = ContentState_1;
var DraftEntity$1 = DraftEntity_1;
var DraftTreeAdapter = DraftTreeAdapter_1;
var SelectionState$1 = SelectionState_1;
var createCharacterList = createCharacterList_1;
var decodeEntityRanges = decodeEntityRanges_1;
var decodeInlineStyleRanges = decodeInlineStyleRanges_1;
var generateRandomKey$1 = generateRandomKey_1;
var gkx = gkx$8;
var Immutable = immutable$1.exports;
var invariant$1 = invariant_1;
var experimentalTreeDataSupport = gkx("draft_tree_data_support");
var List$2 = Immutable.List, Map$6 = Immutable.Map, OrderedMap$1 = Immutable.OrderedMap;
var decodeBlockNodeConfig = function decodeBlockNodeConfig2(block, entityMap) {
  var key = block.key, type = block.type, data = block.data, text = block.text, depth = block.depth;
  var blockNodeConfig = {
    text,
    depth: depth || 0,
    type: type || "unstyled",
    key: key || generateRandomKey$1(),
    data: Map$6(data),
    characterList: decodeCharacterList(block, entityMap)
  };
  return blockNodeConfig;
};
var decodeCharacterList = function decodeCharacterList2(block, entityMap) {
  var text = block.text, rawEntityRanges = block.entityRanges, rawInlineStyleRanges = block.inlineStyleRanges;
  var entityRanges = rawEntityRanges || [];
  var inlineStyleRanges = rawInlineStyleRanges || [];
  return createCharacterList(decodeInlineStyleRanges(text, inlineStyleRanges), decodeEntityRanges(text, entityRanges.filter(function(range) {
    return entityMap.hasOwnProperty(range.key);
  }).map(function(range) {
    return _objectSpread$2({}, range, {
      key: entityMap[range.key]
    });
  })));
};
var addKeyIfMissing = function addKeyIfMissing2(block) {
  return _objectSpread$2({}, block, {
    key: block.key || generateRandomKey$1()
  });
};
var updateNodeStack = function updateNodeStack2(stack, nodes, parentRef) {
  var nodesWithParentRef = nodes.map(function(block) {
    return _objectSpread$2({}, block, {
      parentRef
    });
  });
  return stack.concat(nodesWithParentRef.reverse());
};
var decodeContentBlockNodes = function decodeContentBlockNodes2(blocks, entityMap) {
  return blocks.map(addKeyIfMissing).reduce(function(blockMap, block, index) {
    !Array.isArray(block.children) ? invariant$1(false) : void 0;
    var children = block.children.map(addKeyIfMissing);
    var contentBlockNode = new ContentBlockNode(_objectSpread$2({}, decodeBlockNodeConfig(block, entityMap), {
      prevSibling: index === 0 ? null : blocks[index - 1].key,
      nextSibling: index === blocks.length - 1 ? null : blocks[index + 1].key,
      children: List$2(children.map(function(child) {
        return child.key;
      }))
    }));
    blockMap = blockMap.set(contentBlockNode.getKey(), contentBlockNode);
    var stack = updateNodeStack([], children, contentBlockNode);
    while (stack.length > 0) {
      var node = stack.pop();
      var parentRef = node.parentRef;
      var siblings = parentRef.getChildKeys();
      var _index = siblings.indexOf(node.key);
      var isValidBlock = Array.isArray(node.children);
      if (!isValidBlock) {
        !isValidBlock ? invariant$1(false) : void 0;
        break;
      }
      var _children = node.children.map(addKeyIfMissing);
      var _contentBlockNode = new ContentBlockNode(_objectSpread$2({}, decodeBlockNodeConfig(node, entityMap), {
        parent: parentRef.getKey(),
        children: List$2(_children.map(function(child) {
          return child.key;
        })),
        prevSibling: _index === 0 ? null : siblings.get(_index - 1),
        nextSibling: _index === siblings.size - 1 ? null : siblings.get(_index + 1)
      }));
      blockMap = blockMap.set(_contentBlockNode.getKey(), _contentBlockNode);
      stack = updateNodeStack(stack, _children, _contentBlockNode);
    }
    return blockMap;
  }, OrderedMap$1());
};
var decodeContentBlocks = function decodeContentBlocks2(blocks, entityMap) {
  return OrderedMap$1(blocks.map(function(block) {
    var contentBlock = new ContentBlock$1(decodeBlockNodeConfig(block, entityMap));
    return [contentBlock.getKey(), contentBlock];
  }));
};
var decodeRawBlocks = function decodeRawBlocks2(rawState, entityMap) {
  var isTreeRawBlock = rawState.blocks.find(function(block) {
    return Array.isArray(block.children) && block.children.length > 0;
  });
  var rawBlocks = experimentalTreeDataSupport && !isTreeRawBlock ? DraftTreeAdapter.fromRawStateToRawTreeState(rawState).blocks : rawState.blocks;
  if (!experimentalTreeDataSupport) {
    return decodeContentBlocks(isTreeRawBlock ? DraftTreeAdapter.fromRawTreeStateToRawState(rawState).blocks : rawBlocks, entityMap);
  }
  var blockMap = decodeContentBlockNodes(rawBlocks, entityMap);
  return blockMap;
};
var decodeRawEntityMap = function decodeRawEntityMap2(rawState) {
  var rawEntityMap = rawState.entityMap;
  var entityMap = {};
  Object.keys(rawEntityMap).forEach(function(rawEntityKey) {
    var _rawEntityMap$rawEnti = rawEntityMap[rawEntityKey], type = _rawEntityMap$rawEnti.type, mutability = _rawEntityMap$rawEnti.mutability, data = _rawEntityMap$rawEnti.data;
    entityMap[rawEntityKey] = DraftEntity$1.__create(type, mutability, data || {});
  });
  return entityMap;
};
var convertFromRawToDraftState$1 = function convertFromRawToDraftState(rawState) {
  !Array.isArray(rawState.blocks) ? invariant$1(false) : void 0;
  var entityMap = decodeRawEntityMap(rawState);
  var blockMap = decodeRawBlocks(rawState, entityMap);
  var selectionState = blockMap.isEmpty() ? new SelectionState$1() : SelectionState$1.createEmpty(blockMap.first().getKey());
  return new ContentState$1({
    blockMap,
    entityMap,
    selectionBefore: selectionState,
    selectionAfter: selectionState
  });
};
var convertFromRawToDraftState_1 = convertFromRawToDraftState$1;
var getRangeClientRects = getRangeClientRects_1;
function getRangeBoundingClientRect$1(range) {
  var rects = getRangeClientRects(range);
  var top = 0;
  var right = 0;
  var bottom = 0;
  var left = 0;
  if (rects.length) {
    if (rects.length > 1 && rects[0].width === 0) {
      var _rects$ = rects[1];
      top = _rects$.top;
      right = _rects$.right;
      bottom = _rects$.bottom;
      left = _rects$.left;
    } else {
      var _rects$2 = rects[0];
      top = _rects$2.top;
      right = _rects$2.right;
      bottom = _rects$2.bottom;
      left = _rects$2.left;
    }
    for (var ii = 1; ii < rects.length; ii++) {
      var rect = rects[ii];
      if (rect.height !== 0 && rect.width !== 0) {
        top = Math.min(top, rect.top);
        right = Math.max(right, rect.right);
        bottom = Math.max(bottom, rect.bottom);
        left = Math.min(left, rect.left);
      }
    }
  }
  return {
    top,
    right,
    bottom,
    left,
    width: right - left,
    height: bottom - top
  };
}
var getRangeBoundingClientRect_1 = getRangeBoundingClientRect$1;
var getRangeBoundingClientRect = getRangeBoundingClientRect_1;
function getVisibleSelectionRect$1(global2) {
  var selection = global2.getSelection();
  if (!selection.rangeCount) {
    return null;
  }
  var range = selection.getRangeAt(0);
  var boundingRect = getRangeBoundingClientRect(range);
  var top = boundingRect.top, right = boundingRect.right, bottom = boundingRect.bottom, left = boundingRect.left;
  if (top === 0 && right === 0 && bottom === 0 && left === 0) {
    return null;
  }
  return boundingRect;
}
var getVisibleSelectionRect_1 = getVisibleSelectionRect$1;
var AtomicBlockUtils = AtomicBlockUtils_1;
var BlockMapBuilder = BlockMapBuilder_1;
var CharacterMetadata = CharacterMetadata_1;
var CompositeDraftDecorator = CompositeDraftDecorator_1;
var ContentBlock = ContentBlock_1;
var ContentState = ContentState_1;
var DefaultDraftBlockRenderMap = DefaultDraftBlockRenderMap_1;
var DefaultDraftInlineStyle = DefaultDraftInlineStyle$2;
var DraftEditor = DraftEditor_react;
var DraftEditorBlock = DraftEditorBlock_react;
var DraftEntity = DraftEntity_1;
var DraftModifier = DraftModifier_1;
var DraftEntityInstance = DraftEntityInstance_1;
var EditorState = EditorState_1;
var KeyBindingUtil = KeyBindingUtil_1;
var RawDraftContentState = require$$15;
var RichTextEditorUtil = RichTextEditorUtil_1;
var SelectionState = SelectionState_1;
var convertFromDraftStateToRaw2 = convertFromDraftStateToRaw_1;
var convertFromRawToDraftState2 = convertFromRawToDraftState_1;
var generateRandomKey = generateRandomKey_1;
var getDefaultKeyBinding = getDefaultKeyBinding_1;
var getVisibleSelectionRect = getVisibleSelectionRect_1;
var convertFromHTML$2 = convertFromHTMLToContentBlocks_1;
var DraftPublic = {
  Editor: DraftEditor,
  EditorBlock: DraftEditorBlock,
  EditorState,
  CompositeDecorator: CompositeDraftDecorator,
  Entity: DraftEntity,
  EntityInstance: DraftEntityInstance,
  BlockMapBuilder,
  CharacterMetadata,
  ContentBlock,
  ContentState,
  RawDraftContentState,
  SelectionState,
  AtomicBlockUtils,
  KeyBindingUtil,
  Modifier: DraftModifier,
  RichUtils: RichTextEditorUtil,
  DefaultDraftBlockRenderMap,
  DefaultDraftInlineStyle,
  convertFromHTML: convertFromHTML$2,
  convertFromRaw: convertFromRawToDraftState2,
  convertToRaw: convertFromDraftStateToRaw2,
  genKey: generateRandomKey,
  getDefaultKeyBinding,
  getVisibleSelectionRect
};
var Draft = DraftPublic;
const initialState = {
  editorState: Draft.EditorState.createEmpty(),
  focus: false,
  editorRef: null,
  disabled: false
};
const EditorContext = createContext(initialState);
const reducer = (state, action) => {
  switch (action.type) {
    case "update":
    case "focus":
      return __spreadValues(__spreadValues({}, state), action);
    case "updateState":
      return __spreadValues(__spreadValues({}, state), action.state);
  }
};
const EditorProvider = ({
  translations,
  configResponsiveImageHandler,
  children
}) => {
  return /* @__PURE__ */ jsx(EditorContext.Provider, {
    value: useReducer(reducer, __spreadProps(__spreadValues({}, initialState), {
      translations,
      configResponsiveImageHandler
    })),
    children
  });
};
const updateState = (state) => ({
  type: "updateState",
  state
});
const updateEditor = (editorState) => ({
  type: "update",
  editorState
});
const updateEditorRef = (editorRef) => ({
  type: "update",
  editorRef
});
const setFocus = (focus) => ({
  type: "focus",
  focus
});
var _mapping = {};
(function(exports) {
  exports.aliasToReal = {
    "each": "forEach",
    "eachRight": "forEachRight",
    "entries": "toPairs",
    "entriesIn": "toPairsIn",
    "extend": "assignIn",
    "extendAll": "assignInAll",
    "extendAllWith": "assignInAllWith",
    "extendWith": "assignInWith",
    "first": "head",
    "conforms": "conformsTo",
    "matches": "isMatch",
    "property": "get",
    "__": "placeholder",
    "F": "stubFalse",
    "T": "stubTrue",
    "all": "every",
    "allPass": "overEvery",
    "always": "constant",
    "any": "some",
    "anyPass": "overSome",
    "apply": "spread",
    "assoc": "set",
    "assocPath": "set",
    "complement": "negate",
    "compose": "flowRight",
    "contains": "includes",
    "dissoc": "unset",
    "dissocPath": "unset",
    "dropLast": "dropRight",
    "dropLastWhile": "dropRightWhile",
    "equals": "isEqual",
    "identical": "eq",
    "indexBy": "keyBy",
    "init": "initial",
    "invertObj": "invert",
    "juxt": "over",
    "omitAll": "omit",
    "nAry": "ary",
    "path": "get",
    "pathEq": "matchesProperty",
    "pathOr": "getOr",
    "paths": "at",
    "pickAll": "pick",
    "pipe": "flow",
    "pluck": "map",
    "prop": "get",
    "propEq": "matchesProperty",
    "propOr": "getOr",
    "props": "at",
    "symmetricDifference": "xor",
    "symmetricDifferenceBy": "xorBy",
    "symmetricDifferenceWith": "xorWith",
    "takeLast": "takeRight",
    "takeLastWhile": "takeRightWhile",
    "unapply": "rest",
    "unnest": "flatten",
    "useWith": "overArgs",
    "where": "conformsTo",
    "whereEq": "isMatch",
    "zipObj": "zipObject"
  };
  exports.aryMethod = {
    "1": ["assignAll", "assignInAll", "attempt", "castArray", "ceil", "create", "curry", "curryRight", "defaultsAll", "defaultsDeepAll", "floor", "flow", "flowRight", "fromPairs", "invert", "iteratee", "memoize", "method", "mergeAll", "methodOf", "mixin", "nthArg", "over", "overEvery", "overSome", "rest", "reverse", "round", "runInContext", "spread", "template", "trim", "trimEnd", "trimStart", "uniqueId", "words", "zipAll"],
    "2": ["add", "after", "ary", "assign", "assignAllWith", "assignIn", "assignInAllWith", "at", "before", "bind", "bindAll", "bindKey", "chunk", "cloneDeepWith", "cloneWith", "concat", "conformsTo", "countBy", "curryN", "curryRightN", "debounce", "defaults", "defaultsDeep", "defaultTo", "delay", "difference", "divide", "drop", "dropRight", "dropRightWhile", "dropWhile", "endsWith", "eq", "every", "filter", "find", "findIndex", "findKey", "findLast", "findLastIndex", "findLastKey", "flatMap", "flatMapDeep", "flattenDepth", "forEach", "forEachRight", "forIn", "forInRight", "forOwn", "forOwnRight", "get", "groupBy", "gt", "gte", "has", "hasIn", "includes", "indexOf", "intersection", "invertBy", "invoke", "invokeMap", "isEqual", "isMatch", "join", "keyBy", "lastIndexOf", "lt", "lte", "map", "mapKeys", "mapValues", "matchesProperty", "maxBy", "meanBy", "merge", "mergeAllWith", "minBy", "multiply", "nth", "omit", "omitBy", "overArgs", "pad", "padEnd", "padStart", "parseInt", "partial", "partialRight", "partition", "pick", "pickBy", "propertyOf", "pull", "pullAll", "pullAt", "random", "range", "rangeRight", "rearg", "reject", "remove", "repeat", "restFrom", "result", "sampleSize", "some", "sortBy", "sortedIndex", "sortedIndexOf", "sortedLastIndex", "sortedLastIndexOf", "sortedUniqBy", "split", "spreadFrom", "startsWith", "subtract", "sumBy", "take", "takeRight", "takeRightWhile", "takeWhile", "tap", "throttle", "thru", "times", "trimChars", "trimCharsEnd", "trimCharsStart", "truncate", "union", "uniqBy", "uniqWith", "unset", "unzipWith", "without", "wrap", "xor", "zip", "zipObject", "zipObjectDeep"],
    "3": ["assignInWith", "assignWith", "clamp", "differenceBy", "differenceWith", "findFrom", "findIndexFrom", "findLastFrom", "findLastIndexFrom", "getOr", "includesFrom", "indexOfFrom", "inRange", "intersectionBy", "intersectionWith", "invokeArgs", "invokeArgsMap", "isEqualWith", "isMatchWith", "flatMapDepth", "lastIndexOfFrom", "mergeWith", "orderBy", "padChars", "padCharsEnd", "padCharsStart", "pullAllBy", "pullAllWith", "rangeStep", "rangeStepRight", "reduce", "reduceRight", "replace", "set", "slice", "sortedIndexBy", "sortedLastIndexBy", "transform", "unionBy", "unionWith", "update", "xorBy", "xorWith", "zipWith"],
    "4": ["fill", "setWith", "updateWith"]
  };
  exports.aryRearg = {
    "2": [1, 0],
    "3": [2, 0, 1],
    "4": [3, 2, 0, 1]
  };
  exports.iterateeAry = {
    "dropRightWhile": 1,
    "dropWhile": 1,
    "every": 1,
    "filter": 1,
    "find": 1,
    "findFrom": 1,
    "findIndex": 1,
    "findIndexFrom": 1,
    "findKey": 1,
    "findLast": 1,
    "findLastFrom": 1,
    "findLastIndex": 1,
    "findLastIndexFrom": 1,
    "findLastKey": 1,
    "flatMap": 1,
    "flatMapDeep": 1,
    "flatMapDepth": 1,
    "forEach": 1,
    "forEachRight": 1,
    "forIn": 1,
    "forInRight": 1,
    "forOwn": 1,
    "forOwnRight": 1,
    "map": 1,
    "mapKeys": 1,
    "mapValues": 1,
    "partition": 1,
    "reduce": 2,
    "reduceRight": 2,
    "reject": 1,
    "remove": 1,
    "some": 1,
    "takeRightWhile": 1,
    "takeWhile": 1,
    "times": 1,
    "transform": 2
  };
  exports.iterateeRearg = {
    "mapKeys": [1],
    "reduceRight": [1, 0]
  };
  exports.methodRearg = {
    "assignInAllWith": [1, 0],
    "assignInWith": [1, 2, 0],
    "assignAllWith": [1, 0],
    "assignWith": [1, 2, 0],
    "differenceBy": [1, 2, 0],
    "differenceWith": [1, 2, 0],
    "getOr": [2, 1, 0],
    "intersectionBy": [1, 2, 0],
    "intersectionWith": [1, 2, 0],
    "isEqualWith": [1, 2, 0],
    "isMatchWith": [2, 1, 0],
    "mergeAllWith": [1, 0],
    "mergeWith": [1, 2, 0],
    "padChars": [2, 1, 0],
    "padCharsEnd": [2, 1, 0],
    "padCharsStart": [2, 1, 0],
    "pullAllBy": [2, 1, 0],
    "pullAllWith": [2, 1, 0],
    "rangeStep": [1, 2, 0],
    "rangeStepRight": [1, 2, 0],
    "setWith": [3, 1, 2, 0],
    "sortedIndexBy": [2, 1, 0],
    "sortedLastIndexBy": [2, 1, 0],
    "unionBy": [1, 2, 0],
    "unionWith": [1, 2, 0],
    "updateWith": [3, 1, 2, 0],
    "xorBy": [1, 2, 0],
    "xorWith": [1, 2, 0],
    "zipWith": [1, 2, 0]
  };
  exports.methodSpread = {
    "assignAll": {
      "start": 0
    },
    "assignAllWith": {
      "start": 0
    },
    "assignInAll": {
      "start": 0
    },
    "assignInAllWith": {
      "start": 0
    },
    "defaultsAll": {
      "start": 0
    },
    "defaultsDeepAll": {
      "start": 0
    },
    "invokeArgs": {
      "start": 2
    },
    "invokeArgsMap": {
      "start": 2
    },
    "mergeAll": {
      "start": 0
    },
    "mergeAllWith": {
      "start": 0
    },
    "partial": {
      "start": 1
    },
    "partialRight": {
      "start": 1
    },
    "without": {
      "start": 1
    },
    "zipAll": {
      "start": 0
    }
  };
  exports.mutate = {
    "array": {
      "fill": true,
      "pull": true,
      "pullAll": true,
      "pullAllBy": true,
      "pullAllWith": true,
      "pullAt": true,
      "remove": true,
      "reverse": true
    },
    "object": {
      "assign": true,
      "assignAll": true,
      "assignAllWith": true,
      "assignIn": true,
      "assignInAll": true,
      "assignInAllWith": true,
      "assignInWith": true,
      "assignWith": true,
      "defaults": true,
      "defaultsAll": true,
      "defaultsDeep": true,
      "defaultsDeepAll": true,
      "merge": true,
      "mergeAll": true,
      "mergeAllWith": true,
      "mergeWith": true
    },
    "set": {
      "set": true,
      "setWith": true,
      "unset": true,
      "update": true,
      "updateWith": true
    }
  };
  exports.realToAlias = function() {
    var hasOwnProperty2 = Object.prototype.hasOwnProperty, object = exports.aliasToReal, result = {};
    for (var key in object) {
      var value = object[key];
      if (hasOwnProperty2.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }
    return result;
  }();
  exports.remap = {
    "assignAll": "assign",
    "assignAllWith": "assignWith",
    "assignInAll": "assignIn",
    "assignInAllWith": "assignInWith",
    "curryN": "curry",
    "curryRightN": "curryRight",
    "defaultsAll": "defaults",
    "defaultsDeepAll": "defaultsDeep",
    "findFrom": "find",
    "findIndexFrom": "findIndex",
    "findLastFrom": "findLast",
    "findLastIndexFrom": "findLastIndex",
    "getOr": "get",
    "includesFrom": "includes",
    "indexOfFrom": "indexOf",
    "invokeArgs": "invoke",
    "invokeArgsMap": "invokeMap",
    "lastIndexOfFrom": "lastIndexOf",
    "mergeAll": "merge",
    "mergeAllWith": "mergeWith",
    "padChars": "pad",
    "padCharsEnd": "padEnd",
    "padCharsStart": "padStart",
    "propertyOf": "get",
    "rangeStep": "range",
    "rangeStepRight": "rangeRight",
    "restFrom": "rest",
    "spreadFrom": "spread",
    "trimChars": "trim",
    "trimCharsEnd": "trimEnd",
    "trimCharsStart": "trimStart",
    "zipAll": "zip"
  };
  exports.skipFixed = {
    "castArray": true,
    "flow": true,
    "flowRight": true,
    "iteratee": true,
    "mixin": true,
    "rearg": true,
    "runInContext": true
  };
  exports.skipRearg = {
    "add": true,
    "assign": true,
    "assignIn": true,
    "bind": true,
    "bindKey": true,
    "concat": true,
    "difference": true,
    "divide": true,
    "eq": true,
    "gt": true,
    "gte": true,
    "isEqual": true,
    "lt": true,
    "lte": true,
    "matchesProperty": true,
    "merge": true,
    "multiply": true,
    "overArgs": true,
    "partial": true,
    "partialRight": true,
    "propertyOf": true,
    "random": true,
    "range": true,
    "rangeRight": true,
    "subtract": true,
    "zip": true,
    "zipObject": true,
    "zipObjectDeep": true
  };
})(_mapping);
var placeholder = {};
var mapping = _mapping, fallbackHolder = placeholder;
var push$1 = Array.prototype.push;
function baseArity(func2, n2) {
  return n2 == 2 ? function(a, b) {
    return func2.apply(void 0, arguments);
  } : function(a) {
    return func2.apply(void 0, arguments);
  };
}
function baseAry(func2, n2) {
  return n2 == 2 ? function(a, b) {
    return func2(a, b);
  } : function(a) {
    return func2(a);
  };
}
function cloneArray(array) {
  var length = array ? array.length : 0, result = Array(length);
  while (length--) {
    result[length] = array[length];
  }
  return result;
}
function createCloner(func2) {
  return function(object) {
    return func2({}, object);
  };
}
function flatSpread(func2, start) {
  return function() {
    var length = arguments.length, lastIndex = length - 1, args = Array(length);
    while (length--) {
      args[length] = arguments[length];
    }
    var array = args[start], otherArgs = args.slice(0, start);
    if (array) {
      push$1.apply(otherArgs, array);
    }
    if (start != lastIndex) {
      push$1.apply(otherArgs, args.slice(start + 1));
    }
    return func2.apply(this, otherArgs);
  };
}
function wrapImmutable(func2, cloner) {
  return function() {
    var length = arguments.length;
    if (!length) {
      return;
    }
    var args = Array(length);
    while (length--) {
      args[length] = arguments[length];
    }
    var result = args[0] = cloner.apply(void 0, args);
    func2.apply(void 0, args);
    return result;
  };
}
function baseConvert$1(util2, name, func2, options) {
  var isLib = typeof name == "function", isObj = name === Object(name);
  if (isObj) {
    options = func2;
    func2 = name;
    name = void 0;
  }
  if (func2 == null) {
    throw new TypeError();
  }
  options || (options = {});
  var config = {
    "cap": "cap" in options ? options.cap : true,
    "curry": "curry" in options ? options.curry : true,
    "fixed": "fixed" in options ? options.fixed : true,
    "immutable": "immutable" in options ? options.immutable : true,
    "rearg": "rearg" in options ? options.rearg : true
  };
  var defaultHolder = isLib ? func2 : fallbackHolder, forceCurry = "curry" in options && options.curry, forceFixed = "fixed" in options && options.fixed, forceRearg = "rearg" in options && options.rearg, pristine = isLib ? func2.runInContext() : void 0;
  var helpers = isLib ? func2 : {
    "ary": util2.ary,
    "assign": util2.assign,
    "clone": util2.clone,
    "curry": util2.curry,
    "forEach": util2.forEach,
    "isArray": util2.isArray,
    "isError": util2.isError,
    "isFunction": util2.isFunction,
    "isWeakMap": util2.isWeakMap,
    "iteratee": util2.iteratee,
    "keys": util2.keys,
    "rearg": util2.rearg,
    "toInteger": util2.toInteger,
    "toPath": util2.toPath
  };
  var ary2 = helpers.ary, assign2 = helpers.assign, clone2 = helpers.clone, curry2 = helpers.curry, each = helpers.forEach, isArray2 = helpers.isArray, isError2 = helpers.isError, isFunction2 = helpers.isFunction, isWeakMap2 = helpers.isWeakMap, keys3 = helpers.keys, rearg2 = helpers.rearg, toInteger2 = helpers.toInteger, toPath2 = helpers.toPath;
  var aryMethodKeys = keys3(mapping.aryMethod);
  var wrappers = {
    "castArray": function(castArray) {
      return function() {
        var value = arguments[0];
        return isArray2(value) ? castArray(cloneArray(value)) : castArray.apply(void 0, arguments);
      };
    },
    "iteratee": function(iteratee2) {
      return function() {
        var func3 = arguments[0], arity = arguments[1], result = iteratee2(func3, arity), length = result.length;
        if (config.cap && typeof arity == "number") {
          arity = arity > 2 ? arity - 2 : 1;
          return length && length <= arity ? result : baseAry(result, arity);
        }
        return result;
      };
    },
    "mixin": function(mixin2) {
      return function(source) {
        var func3 = this;
        if (!isFunction2(func3)) {
          return mixin2(func3, Object(source));
        }
        var pairs2 = [];
        each(keys3(source), function(key) {
          if (isFunction2(source[key])) {
            pairs2.push([key, func3.prototype[key]]);
          }
        });
        mixin2(func3, Object(source));
        each(pairs2, function(pair) {
          var value = pair[1];
          if (isFunction2(value)) {
            func3.prototype[pair[0]] = value;
          } else {
            delete func3.prototype[pair[0]];
          }
        });
        return func3;
      };
    },
    "nthArg": function(nthArg) {
      return function(n2) {
        var arity = n2 < 0 ? 1 : toInteger2(n2) + 1;
        return curry2(nthArg(n2), arity);
      };
    },
    "rearg": function(rearg3) {
      return function(func3, indexes) {
        var arity = indexes ? indexes.length : 0;
        return curry2(rearg3(func3, indexes), arity);
      };
    },
    "runInContext": function(runInContext) {
      return function(context) {
        return baseConvert$1(util2, runInContext(context), options);
      };
    }
  };
  function castCap(name2, func3) {
    if (config.cap) {
      var indexes = mapping.iterateeRearg[name2];
      if (indexes) {
        return iterateeRearg(func3, indexes);
      }
      var n2 = !isLib && mapping.iterateeAry[name2];
      if (n2) {
        return iterateeAry(func3, n2);
      }
    }
    return func3;
  }
  function castCurry(name2, func3, n2) {
    return forceCurry || config.curry && n2 > 1 ? curry2(func3, n2) : func3;
  }
  function castFixed(name2, func3, n2) {
    if (config.fixed && (forceFixed || !mapping.skipFixed[name2])) {
      var data = mapping.methodSpread[name2], start = data && data.start;
      return start === void 0 ? ary2(func3, n2) : flatSpread(func3, start);
    }
    return func3;
  }
  function castRearg(name2, func3, n2) {
    return config.rearg && n2 > 1 && (forceRearg || !mapping.skipRearg[name2]) ? rearg2(func3, mapping.methodRearg[name2] || mapping.aryRearg[n2]) : func3;
  }
  function cloneByPath(object, path) {
    path = toPath2(path);
    var index = -1, length = path.length, lastIndex = length - 1, result = clone2(Object(object)), nested = result;
    while (nested != null && ++index < length) {
      var key = path[index], value = nested[key];
      if (value != null && !(isFunction2(value) || isError2(value) || isWeakMap2(value))) {
        nested[key] = clone2(index == lastIndex ? value : Object(value));
      }
      nested = nested[key];
    }
    return result;
  }
  function convertLib(options2) {
    return _.runInContext.convert(options2)(void 0);
  }
  function createConverter(name2, func3) {
    var realName = mapping.aliasToReal[name2] || name2, methodName = mapping.remap[realName] || realName, oldOptions = options;
    return function(options2) {
      var newUtil = isLib ? pristine : helpers, newFunc = isLib ? pristine[methodName] : func3, newOptions = assign2(assign2({}, oldOptions), options2);
      return baseConvert$1(newUtil, realName, newFunc, newOptions);
    };
  }
  function iterateeAry(func3, n2) {
    return overArg2(func3, function(func4) {
      return typeof func4 == "function" ? baseAry(func4, n2) : func4;
    });
  }
  function iterateeRearg(func3, indexes) {
    return overArg2(func3, function(func4) {
      var n2 = indexes.length;
      return baseArity(rearg2(baseAry(func4, n2), indexes), n2);
    });
  }
  function overArg2(func3, transform) {
    return function() {
      var length = arguments.length;
      if (!length) {
        return func3();
      }
      var args = Array(length);
      while (length--) {
        args[length] = arguments[length];
      }
      var index = config.rearg ? 0 : length - 1;
      args[index] = transform(args[index]);
      return func3.apply(void 0, args);
    };
  }
  function wrap(name2, func3, placeholder2) {
    var result, realName = mapping.aliasToReal[name2] || name2, wrapped = func3, wrapper = wrappers[realName];
    if (wrapper) {
      wrapped = wrapper(func3);
    } else if (config.immutable) {
      if (mapping.mutate.array[realName]) {
        wrapped = wrapImmutable(func3, cloneArray);
      } else if (mapping.mutate.object[realName]) {
        wrapped = wrapImmutable(func3, createCloner(func3));
      } else if (mapping.mutate.set[realName]) {
        wrapped = wrapImmutable(func3, cloneByPath);
      }
    }
    each(aryMethodKeys, function(aryKey) {
      each(mapping.aryMethod[aryKey], function(otherName) {
        if (realName == otherName) {
          var data = mapping.methodSpread[realName], afterRearg = data && data.afterRearg;
          result = afterRearg ? castFixed(realName, castRearg(realName, wrapped, aryKey), aryKey) : castRearg(realName, castFixed(realName, wrapped, aryKey), aryKey);
          result = castCap(realName, result);
          result = castCurry(realName, result, aryKey);
          return false;
        }
      });
      return !result;
    });
    result || (result = wrapped);
    if (result == func3) {
      result = forceCurry ? curry2(result, 1) : function() {
        return func3.apply(this, arguments);
      };
    }
    result.convert = createConverter(realName, func3);
    result.placeholder = func3.placeholder = placeholder2;
    return result;
  }
  if (!isObj) {
    return wrap(name, func2, defaultHolder);
  }
  var _ = func2;
  var pairs = [];
  each(aryMethodKeys, function(aryKey) {
    each(mapping.aryMethod[aryKey], function(key) {
      var func3 = _[mapping.remap[key] || key];
      if (func3) {
        pairs.push([key, wrap(key, func3, _)]);
      }
    });
  });
  each(keys3(_), function(key) {
    var func3 = _[key];
    if (typeof func3 == "function") {
      var length = pairs.length;
      while (length--) {
        if (pairs[length][0] == key) {
          return;
        }
      }
      func3.convert = createConverter(key, func3);
      pairs.push([key, func3]);
    }
  });
  each(pairs, function(pair) {
    _[pair[0]] = pair[1];
  });
  _.convert = convertLib;
  _.placeholder = _;
  each(keys3(_), function(key) {
    each(mapping.realToAlias[key] || [], function(alias) {
      _[alias] = _[key];
    });
  });
  return _;
}
var _baseConvert = baseConvert$1;
function identity$3(value) {
  return value;
}
var identity_1 = identity$3;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$c = freeGlobal || freeSelf || Function("return this")();
var _root = root$c;
var root$b = _root;
var Symbol$7 = root$b.Symbol;
var _Symbol = Symbol$7;
var Symbol$6 = _Symbol;
var objectProto$i = Object.prototype;
var hasOwnProperty$g = objectProto$i.hasOwnProperty;
var nativeObjectToString$1 = objectProto$i.toString;
var symToStringTag$1 = Symbol$6 ? Symbol$6.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$g.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$h = Object.prototype;
var nativeObjectToString = objectProto$h.toString;
function objectToString$2(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$2;
var Symbol$5 = _Symbol, getRawTag = _getRawTag, objectToString$1 = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$5 ? Symbol$5.toStringTag : void 0;
function baseGetTag$7(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString$1(value);
}
var _baseGetTag = baseGetTag$7;
function isObject$a(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$a;
var baseGetTag$6 = _baseGetTag, isObject$9 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$3(value) {
  if (!isObject$9(value)) {
    return false;
  }
  var tag = baseGetTag$6(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$3;
var root$a = _root;
var coreJsData$1 = root$a["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func2) {
  return !!maskSrcKey && maskSrcKey in func2;
}
var _isMasked = isMasked$1;
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource$2(func2) {
  if (func2 != null) {
    try {
      return funcToString$2.call(func2);
    } catch (e) {
    }
    try {
      return func2 + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$2 = isFunction_1, isMasked = _isMasked, isObject$8 = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$g = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$f = objectProto$g.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$f).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(value) {
  if (!isObject$8(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$7(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative, root$9 = _root;
var WeakMap$3 = getNative$6(root$9, "WeakMap");
var _WeakMap = WeakMap$3;
var WeakMap$2 = _WeakMap;
var metaMap$2 = WeakMap$2 && new WeakMap$2();
var _metaMap = metaMap$2;
var identity$2 = identity_1, metaMap$1 = _metaMap;
var baseSetData$2 = !metaMap$1 ? identity$2 : function(func2, data) {
  metaMap$1.set(func2, data);
  return func2;
};
var _baseSetData = baseSetData$2;
var isObject$7 = isObject_1;
var objectCreate = Object.create;
var baseCreate$4 = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$7(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$4;
var baseCreate$3 = _baseCreate, isObject$6 = isObject_1;
function createCtor$4(Ctor) {
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return new Ctor();
      case 1:
        return new Ctor(args[0]);
      case 2:
        return new Ctor(args[0], args[1]);
      case 3:
        return new Ctor(args[0], args[1], args[2]);
      case 4:
        return new Ctor(args[0], args[1], args[2], args[3]);
      case 5:
        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate$3(Ctor.prototype), result = Ctor.apply(thisBinding, args);
    return isObject$6(result) ? result : thisBinding;
  };
}
var _createCtor = createCtor$4;
var createCtor$3 = _createCtor, root$8 = _root;
var WRAP_BIND_FLAG$6 = 1;
function createBind$1(func2, bitmask, thisArg) {
  var isBind = bitmask & WRAP_BIND_FLAG$6, Ctor = createCtor$3(func2);
  function wrapper() {
    var fn = this && this !== root$8 && this instanceof wrapper ? Ctor : func2;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}
var _createBind = createBind$1;
function apply$3(func2, thisArg, args) {
  switch (args.length) {
    case 0:
      return func2.call(thisArg);
    case 1:
      return func2.call(thisArg, args[0]);
    case 2:
      return func2.call(thisArg, args[0], args[1]);
    case 3:
      return func2.call(thisArg, args[0], args[1], args[2]);
  }
  return func2.apply(thisArg, args);
}
var _apply = apply$3;
var nativeMax$3 = Math.max;
function composeArgs$2(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax$3(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
  while (++leftIndex < leftLength) {
    result[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result[leftIndex++] = args[argsIndex++];
  }
  return result;
}
var _composeArgs = composeArgs$2;
var nativeMax$2 = Math.max;
function composeArgsRight$2(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax$2(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
  while (++argsIndex < rangeLength) {
    result[argsIndex] = args[argsIndex];
  }
  var offset = argsIndex;
  while (++rightIndex < rightLength) {
    result[offset + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[offset + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result;
}
var _composeArgsRight = composeArgsRight$2;
function countHolders$1(array, placeholder2) {
  var length = array.length, result = 0;
  while (length--) {
    if (array[length] === placeholder2) {
      ++result;
    }
  }
  return result;
}
var _countHolders = countHolders$1;
function baseLodash$3() {
}
var _baseLodash = baseLodash$3;
var baseCreate$2 = _baseCreate, baseLodash$2 = _baseLodash;
var MAX_ARRAY_LENGTH = 4294967295;
function LazyWrapper$3(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}
LazyWrapper$3.prototype = baseCreate$2(baseLodash$2.prototype);
LazyWrapper$3.prototype.constructor = LazyWrapper$3;
var _LazyWrapper = LazyWrapper$3;
function noop$2() {
}
var noop_1 = noop$2;
var metaMap = _metaMap, noop$1 = noop_1;
var getData$3 = !metaMap ? noop$1 : function(func2) {
  return metaMap.get(func2);
};
var _getData = getData$3;
var realNames$1 = {};
var _realNames = realNames$1;
var realNames = _realNames;
var objectProto$f = Object.prototype;
var hasOwnProperty$e = objectProto$f.hasOwnProperty;
function getFuncName$2(func2) {
  var result = func2.name + "", array = realNames[result], length = hasOwnProperty$e.call(realNames, result) ? array.length : 0;
  while (length--) {
    var data = array[length], otherFunc = data.func;
    if (otherFunc == null || otherFunc == func2) {
      return data.name;
    }
  }
  return result;
}
var _getFuncName = getFuncName$2;
var baseCreate$1 = _baseCreate, baseLodash$1 = _baseLodash;
function LodashWrapper$3(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = void 0;
}
LodashWrapper$3.prototype = baseCreate$1(baseLodash$1.prototype);
LodashWrapper$3.prototype.constructor = LodashWrapper$3;
var _LodashWrapper = LodashWrapper$3;
var isArray$j = Array.isArray;
var isArray_1 = isArray$j;
function isObjectLike$b(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$b;
function copyArray$4(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var _copyArray = copyArray$4;
var LazyWrapper$2 = _LazyWrapper, LodashWrapper$2 = _LodashWrapper, copyArray$3 = _copyArray;
function wrapperClone$1(wrapper) {
  if (wrapper instanceof LazyWrapper$2) {
    return wrapper.clone();
  }
  var result = new LodashWrapper$2(wrapper.__wrapped__, wrapper.__chain__);
  result.__actions__ = copyArray$3(wrapper.__actions__);
  result.__index__ = wrapper.__index__;
  result.__values__ = wrapper.__values__;
  return result;
}
var _wrapperClone = wrapperClone$1;
var LazyWrapper$1 = _LazyWrapper, LodashWrapper$1 = _LodashWrapper, baseLodash = _baseLodash, isArray$i = isArray_1, isObjectLike$a = isObjectLike_1, wrapperClone = _wrapperClone;
var objectProto$e = Object.prototype;
var hasOwnProperty$d = objectProto$e.hasOwnProperty;
function lodash$1(value) {
  if (isObjectLike$a(value) && !isArray$i(value) && !(value instanceof LazyWrapper$1)) {
    if (value instanceof LodashWrapper$1) {
      return value;
    }
    if (hasOwnProperty$d.call(value, "__wrapped__")) {
      return wrapperClone(value);
    }
  }
  return new LodashWrapper$1(value);
}
lodash$1.prototype = baseLodash.prototype;
lodash$1.prototype.constructor = lodash$1;
var wrapperLodash = lodash$1;
var LazyWrapper = _LazyWrapper, getData$2 = _getData, getFuncName$1 = _getFuncName, lodash = wrapperLodash;
function isLaziable$2(func2) {
  var funcName = getFuncName$1(func2), other = lodash[funcName];
  if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
    return false;
  }
  if (func2 === other) {
    return true;
  }
  var data = getData$2(other);
  return !!data && func2 === data[0];
}
var _isLaziable = isLaziable$2;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$2(func2) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func2.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$2;
var baseSetData$1 = _baseSetData, shortOut$1 = _shortOut;
var setData$2 = shortOut$1(baseSetData$1);
var _setData = setData$2;
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
function getWrapDetails$1(source) {
  var match3 = source.match(reWrapDetails);
  return match3 ? match3[1].split(reSplitDetails) : [];
}
var _getWrapDetails = getWrapDetails$1;
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
function insertWrapDetails$1(source, details) {
  var length = details.length;
  if (!length) {
    return source;
  }
  var lastIndex = length - 1;
  details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
  details = details.join(length > 2 ? ", " : " ");
  return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
}
var _insertWrapDetails = insertWrapDetails$1;
function constant$1(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$1;
var getNative$5 = _getNative;
var defineProperty$2 = function() {
  try {
    var func2 = getNative$5(Object, "defineProperty");
    func2({}, "", {});
    return func2;
  } catch (e) {
  }
}();
var _defineProperty$2 = defineProperty$2;
var constant = constant_1, defineProperty$1 = _defineProperty$2, identity$1 = identity_1;
var baseSetToString$1 = !defineProperty$1 ? identity$1 : function(func2, string) {
  return defineProperty$1(func2, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var baseSetToString = _baseSetToString, shortOut = _shortOut;
var setToString$2 = shortOut(baseSetToString);
var _setToString = setToString$2;
function arrayEach$2(array, iteratee2) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee2(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach$2;
function baseFindIndex$1(array, predicate, fromIndex, fromRight) {
  var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}
var _baseFindIndex = baseFindIndex$1;
function baseIsNaN$1(value) {
  return value !== value;
}
var _baseIsNaN = baseIsNaN$1;
function strictIndexOf$1(array, value, fromIndex) {
  var index = fromIndex - 1, length = array.length;
  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}
var _strictIndexOf = strictIndexOf$1;
var baseFindIndex = _baseFindIndex, baseIsNaN = _baseIsNaN, strictIndexOf = _strictIndexOf;
function baseIndexOf$3(array, value, fromIndex) {
  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
}
var _baseIndexOf = baseIndexOf$3;
var baseIndexOf$2 = _baseIndexOf;
function arrayIncludes$2(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf$2(array, value, 0) > -1;
}
var _arrayIncludes = arrayIncludes$2;
var arrayEach$1 = _arrayEach, arrayIncludes$1 = _arrayIncludes;
var WRAP_BIND_FLAG$5 = 1, WRAP_BIND_KEY_FLAG$4 = 2, WRAP_CURRY_FLAG$6 = 8, WRAP_CURRY_RIGHT_FLAG$2 = 16, WRAP_PARTIAL_FLAG$3 = 32, WRAP_PARTIAL_RIGHT_FLAG$2 = 64, WRAP_ARY_FLAG$4 = 128, WRAP_REARG_FLAG$3 = 256, WRAP_FLIP_FLAG$1 = 512;
var wrapFlags = [["ary", WRAP_ARY_FLAG$4], ["bind", WRAP_BIND_FLAG$5], ["bindKey", WRAP_BIND_KEY_FLAG$4], ["curry", WRAP_CURRY_FLAG$6], ["curryRight", WRAP_CURRY_RIGHT_FLAG$2], ["flip", WRAP_FLIP_FLAG$1], ["partial", WRAP_PARTIAL_FLAG$3], ["partialRight", WRAP_PARTIAL_RIGHT_FLAG$2], ["rearg", WRAP_REARG_FLAG$3]];
function updateWrapDetails$1(details, bitmask) {
  arrayEach$1(wrapFlags, function(pair) {
    var value = "_." + pair[0];
    if (bitmask & pair[1] && !arrayIncludes$1(details, value)) {
      details.push(value);
    }
  });
  return details.sort();
}
var _updateWrapDetails = updateWrapDetails$1;
var getWrapDetails = _getWrapDetails, insertWrapDetails = _insertWrapDetails, setToString$1 = _setToString, updateWrapDetails = _updateWrapDetails;
function setWrapToString$2(wrapper, reference, bitmask) {
  var source = reference + "";
  return setToString$1(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
}
var _setWrapToString = setWrapToString$2;
var isLaziable$1 = _isLaziable, setData$1 = _setData, setWrapToString$1 = _setWrapToString;
var WRAP_BIND_FLAG$4 = 1, WRAP_BIND_KEY_FLAG$3 = 2, WRAP_CURRY_BOUND_FLAG$1 = 4, WRAP_CURRY_FLAG$5 = 8, WRAP_PARTIAL_FLAG$2 = 32, WRAP_PARTIAL_RIGHT_FLAG$1 = 64;
function createRecurry$2(func2, bitmask, wrapFunc, placeholder2, thisArg, partials, holders, argPos, ary2, arity) {
  var isCurry = bitmask & WRAP_CURRY_FLAG$5, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
  bitmask |= isCurry ? WRAP_PARTIAL_FLAG$2 : WRAP_PARTIAL_RIGHT_FLAG$1;
  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG$1 : WRAP_PARTIAL_FLAG$2);
  if (!(bitmask & WRAP_CURRY_BOUND_FLAG$1)) {
    bitmask &= ~(WRAP_BIND_FLAG$4 | WRAP_BIND_KEY_FLAG$3);
  }
  var newData = [func2, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary2, arity];
  var result = wrapFunc.apply(void 0, newData);
  if (isLaziable$1(func2)) {
    setData$1(result, newData);
  }
  result.placeholder = placeholder2;
  return setWrapToString$1(result, func2, bitmask);
}
var _createRecurry = createRecurry$2;
function getHolder$2(func2) {
  var object = func2;
  return object.placeholder;
}
var _getHolder = getHolder$2;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$4(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
var _isIndex = isIndex$4;
var copyArray$2 = _copyArray, isIndex$3 = _isIndex;
var nativeMin$1 = Math.min;
function reorder$1(array, indexes) {
  var arrLength = array.length, length = nativeMin$1(indexes.length, arrLength), oldArray = copyArray$2(array);
  while (length--) {
    var index = indexes[length];
    array[length] = isIndex$3(index, arrLength) ? oldArray[index] : void 0;
  }
  return array;
}
var _reorder = reorder$1;
var PLACEHOLDER$1 = "__lodash_placeholder__";
function replaceHolders$3(array, placeholder2) {
  var index = -1, length = array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (value === placeholder2 || value === PLACEHOLDER$1) {
      array[index] = PLACEHOLDER$1;
      result[resIndex++] = index;
    }
  }
  return result;
}
var _replaceHolders = replaceHolders$3;
var composeArgs$1 = _composeArgs, composeArgsRight$1 = _composeArgsRight, countHolders = _countHolders, createCtor$2 = _createCtor, createRecurry$1 = _createRecurry, getHolder$1 = _getHolder, reorder = _reorder, replaceHolders$2 = _replaceHolders, root$7 = _root;
var WRAP_BIND_FLAG$3 = 1, WRAP_BIND_KEY_FLAG$2 = 2, WRAP_CURRY_FLAG$4 = 8, WRAP_CURRY_RIGHT_FLAG$1 = 16, WRAP_ARY_FLAG$3 = 128, WRAP_FLIP_FLAG = 512;
function createHybrid$2(func2, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
  var isAry = bitmask & WRAP_ARY_FLAG$3, isBind = bitmask & WRAP_BIND_FLAG$3, isBindKey = bitmask & WRAP_BIND_KEY_FLAG$2, isCurried = bitmask & (WRAP_CURRY_FLAG$4 | WRAP_CURRY_RIGHT_FLAG$1), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? void 0 : createCtor$2(func2);
  function wrapper() {
    var length = arguments.length, args = Array(length), index = length;
    while (index--) {
      args[index] = arguments[index];
    }
    if (isCurried) {
      var placeholder2 = getHolder$1(wrapper), holdersCount = countHolders(args, placeholder2);
    }
    if (partials) {
      args = composeArgs$1(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight$1(args, partialsRight, holdersRight, isCurried);
    }
    length -= holdersCount;
    if (isCurried && length < arity) {
      var newHolders = replaceHolders$2(args, placeholder2);
      return createRecurry$1(func2, bitmask, createHybrid$2, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
    }
    var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func2] : func2;
    length = args.length;
    if (argPos) {
      args = reorder(args, argPos);
    } else if (isFlip && length > 1) {
      args.reverse();
    }
    if (isAry && ary2 < length) {
      args.length = ary2;
    }
    if (this && this !== root$7 && this instanceof wrapper) {
      fn = Ctor || createCtor$2(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}
var _createHybrid = createHybrid$2;
var apply$2 = _apply, createCtor$1 = _createCtor, createHybrid$1 = _createHybrid, createRecurry = _createRecurry, getHolder = _getHolder, replaceHolders$1 = _replaceHolders, root$6 = _root;
function createCurry$1(func2, bitmask, arity) {
  var Ctor = createCtor$1(func2);
  function wrapper() {
    var length = arguments.length, args = Array(length), index = length, placeholder2 = getHolder(wrapper);
    while (index--) {
      args[index] = arguments[index];
    }
    var holders = length < 3 && args[0] !== placeholder2 && args[length - 1] !== placeholder2 ? [] : replaceHolders$1(args, placeholder2);
    length -= holders.length;
    if (length < arity) {
      return createRecurry(func2, bitmask, createHybrid$1, wrapper.placeholder, void 0, args, holders, void 0, void 0, arity - length);
    }
    var fn = this && this !== root$6 && this instanceof wrapper ? Ctor : func2;
    return apply$2(fn, this, args);
  }
  return wrapper;
}
var _createCurry = createCurry$1;
var apply$1 = _apply, createCtor = _createCtor, root$5 = _root;
var WRAP_BIND_FLAG$2 = 1;
function createPartial$1(func2, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG$2, Ctor = createCtor(func2);
  function wrapper() {
    var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root$5 && this instanceof wrapper ? Ctor : func2;
    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply$1(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}
var _createPartial = createPartial$1;
var composeArgs = _composeArgs, composeArgsRight = _composeArgsRight, replaceHolders = _replaceHolders;
var PLACEHOLDER = "__lodash_placeholder__";
var WRAP_BIND_FLAG$1 = 1, WRAP_BIND_KEY_FLAG$1 = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG$3 = 8, WRAP_ARY_FLAG$2 = 128, WRAP_REARG_FLAG$2 = 256;
var nativeMin = Math.min;
function mergeData$1(data, source) {
  var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG$1 | WRAP_BIND_KEY_FLAG$1 | WRAP_ARY_FLAG$2);
  var isCombo = srcBitmask == WRAP_ARY_FLAG$2 && bitmask == WRAP_CURRY_FLAG$3 || srcBitmask == WRAP_ARY_FLAG$2 && bitmask == WRAP_REARG_FLAG$2 && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG$2 | WRAP_REARG_FLAG$2) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG$3;
  if (!(isCommon || isCombo)) {
    return data;
  }
  if (srcBitmask & WRAP_BIND_FLAG$1) {
    data[2] = source[2];
    newBitmask |= bitmask & WRAP_BIND_FLAG$1 ? 0 : WRAP_CURRY_BOUND_FLAG;
  }
  var value = source[3];
  if (value) {
    var partials = data[3];
    data[3] = partials ? composeArgs(partials, value, source[4]) : value;
    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
  }
  value = source[5];
  if (value) {
    partials = data[5];
    data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
  }
  value = source[7];
  if (value) {
    data[7] = value;
  }
  if (srcBitmask & WRAP_ARY_FLAG$2) {
    data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
  }
  if (data[9] == null) {
    data[9] = source[9];
  }
  data[0] = source[0];
  data[1] = newBitmask;
  return data;
}
var _mergeData = mergeData$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$2(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim = baseTrim$2;
var baseGetTag$5 = _baseGetTag, isObjectLike$9 = isObjectLike_1;
var symbolTag$3 = "[object Symbol]";
function isSymbol$6(value) {
  return typeof value == "symbol" || isObjectLike$9(value) && baseGetTag$5(value) == symbolTag$3;
}
var isSymbol_1 = isSymbol$6;
var baseTrim$1 = _baseTrim, isObject$5 = isObject_1, isSymbol$5 = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$1(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$5(value)) {
    return NAN;
  }
  if (isObject$5(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$5(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim$1(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$1;
var toNumber = toNumber_1;
var INFINITY$3 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite$1(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY$3 || value === -INFINITY$3) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_1 = toFinite$1;
var toFinite = toFinite_1;
function toInteger$1(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_1 = toInteger$1;
var baseSetData = _baseSetData, createBind = _createBind, createCurry = _createCurry, createHybrid = _createHybrid, createPartial = _createPartial, getData$1 = _getData, mergeData2 = _mergeData, setData = _setData, setWrapToString = _setWrapToString, toInteger = toInteger_1;
var FUNC_ERROR_TEXT$3 = "Expected a function";
var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_FLAG$2 = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG$1 = 32, WRAP_PARTIAL_RIGHT_FLAG = 64;
var nativeMax$1 = Math.max;
function createWrap$3(func2, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
  if (!isBindKey && typeof func2 != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$3);
  }
  var length = partials ? partials.length : 0;
  if (!length) {
    bitmask &= ~(WRAP_PARTIAL_FLAG$1 | WRAP_PARTIAL_RIGHT_FLAG);
    partials = holders = void 0;
  }
  ary2 = ary2 === void 0 ? ary2 : nativeMax$1(toInteger(ary2), 0);
  arity = arity === void 0 ? arity : toInteger(arity);
  length -= holders ? holders.length : 0;
  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
    var partialsRight = partials, holdersRight = holders;
    partials = holders = void 0;
  }
  var data = isBindKey ? void 0 : getData$1(func2);
  var newData = [func2, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity];
  if (data) {
    mergeData2(newData, data);
  }
  func2 = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] === void 0 ? isBindKey ? 0 : func2.length : nativeMax$1(newData[9] - length, 0);
  if (!arity && bitmask & (WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG)) {
    bitmask &= ~(WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG);
  }
  if (!bitmask || bitmask == WRAP_BIND_FLAG) {
    var result = createBind(func2, bitmask, thisArg);
  } else if (bitmask == WRAP_CURRY_FLAG$2 || bitmask == WRAP_CURRY_RIGHT_FLAG) {
    result = createCurry(func2, bitmask, arity);
  } else if ((bitmask == WRAP_PARTIAL_FLAG$1 || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG$1)) && !holders.length) {
    result = createPartial(func2, bitmask, thisArg, partials);
  } else {
    result = createHybrid.apply(void 0, newData);
  }
  var setter = data ? baseSetData : setData;
  return setWrapToString(setter(result, newData), func2, bitmask);
}
var _createWrap = createWrap$3;
var createWrap$2 = _createWrap;
var WRAP_ARY_FLAG$1 = 128;
function ary(func2, n2, guard) {
  n2 = guard ? void 0 : n2;
  n2 = func2 && n2 == null ? func2.length : n2;
  return createWrap$2(func2, WRAP_ARY_FLAG$1, void 0, void 0, void 0, void 0, n2);
}
var ary_1 = ary;
var defineProperty = _defineProperty$2;
function baseAssignValue$2(object, key, value) {
  if (key == "__proto__" && defineProperty) {
    defineProperty(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$2;
function eq$3(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$3;
var baseAssignValue$1 = _baseAssignValue, eq$2 = eq_1;
var objectProto$d = Object.prototype;
var hasOwnProperty$c = objectProto$d.hasOwnProperty;
function assignValue$3(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$c.call(object, key) && eq$2(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue$1(object, key, value);
  }
}
var _assignValue = assignValue$3;
var assignValue$2 = _assignValue, baseAssignValue = _baseAssignValue;
function copyObject$5(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue$2(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$5;
function baseTimes$1(n2, iteratee2) {
  var index = -1, result = Array(n2);
  while (++index < n2) {
    result[index] = iteratee2(index);
  }
  return result;
}
var _baseTimes = baseTimes$1;
var baseGetTag$4 = _baseGetTag, isObjectLike$8 = isObjectLike_1;
var argsTag$3 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$8(value) && baseGetTag$4(value) == argsTag$3;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$7 = isObjectLike_1;
var objectProto$c = Object.prototype;
var hasOwnProperty$b = objectProto$c.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$c.propertyIsEnumerable;
var isArguments$4 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$7(value) && hasOwnProperty$b.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$4;
var isBuffer$5 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer3 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer3;
})(isBuffer$5, isBuffer$5.exports);
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$3;
var baseGetTag$3 = _baseGetTag, isLength$2 = isLength_1, isObjectLike$6 = isObjectLike_1;
var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$3 = "[object Error]", funcTag$1 = "[object Function]", mapTag$6 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$6 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$3 = "[object WeakMap]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$3] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$6] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$6] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$3] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$6(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$3(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$3(func2) {
  return function(value) {
    return func2(value);
  };
}
var _baseUnary = baseUnary$3;
var _nodeUtil = { exports: {} };
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray, baseUnary$2 = _baseUnary, nodeUtil$2 = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;
var isTypedArray$3 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$3;
var baseTimes = _baseTimes, isArguments$3 = isArguments_1, isArray$h = isArray_1, isBuffer$4 = isBuffer$5.exports, isIndex$2 = _isIndex, isTypedArray$2 = isTypedArray_1;
var objectProto$b = Object.prototype;
var hasOwnProperty$a = objectProto$b.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$h(value), isArg = !isArr && isArguments$3(value), isBuff = !isArr && !isArg && isBuffer$4(value), isType = !isArr && !isArg && !isBuff && isTypedArray$2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$a.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex$2(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$2;
var objectProto$a = Object.prototype;
function isPrototype$4(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
  return value === proto;
}
var _isPrototype = isPrototype$4;
function overArg$2(func2, transform) {
  return function(arg) {
    return func2(transform(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$3 = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$9 = Object.prototype;
var hasOwnProperty$9 = objectProto$9.hasOwnProperty;
function baseKeys$2(object) {
  if (!isPrototype$3(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$9.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$2;
var isFunction$1 = isFunction_1, isLength$1 = isLength_1;
function isArrayLike$5(value) {
  return value != null && isLength$1(value.length) && !isFunction$1(value);
}
var isArrayLike_1 = isArrayLike$5;
var arrayLikeKeys$1 = _arrayLikeKeys, baseKeys$1 = _baseKeys, isArrayLike$4 = isArrayLike_1;
function keys$5(object) {
  return isArrayLike$4(object) ? arrayLikeKeys$1(object) : baseKeys$1(object);
}
var keys_1 = keys$5;
var copyObject$4 = _copyObject, keys$4 = keys_1;
function baseAssign$1(object, source) {
  return object && copyObject$4(source, keys$4(source), object);
}
var _baseAssign = baseAssign$1;
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
var eq$1 = eq_1;
function assocIndexOf$4(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index = assocIndexOf$3(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index = assocIndexOf$2(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries2) {
  var index = -1, length = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index < length) {
    var entry = entries2[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var getNative$4 = _getNative, root$4 = _root;
var Map$5 = getNative$4(root$4, "Map");
var _Map = Map$5;
var getNative$3 = _getNative;
var nativeCreate$4 = getNative$3(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$8 = Object.prototype;
var hasOwnProperty$8 = objectProto$8.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$8.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$7 = Object.prototype;
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$7.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries2) {
  var index = -1, length = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index < length) {
    var entry = entries2[index];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash, ListCache$2 = _ListCache, Map$4 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$4 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$3(entries2) {
  var index = -1, length = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index < length) {
    var entry = entries2[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache$3.prototype.clear = mapCacheClear;
MapCache$3.prototype["delete"] = mapCacheDelete;
MapCache$3.prototype.get = mapCacheGet;
MapCache$3.prototype.has = mapCacheHas;
MapCache$3.prototype.set = mapCacheSet;
var _MapCache = MapCache$3;
var ListCache$1 = _ListCache, Map$3 = _Map, MapCache$2 = _MapCache;
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$3 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$2(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$4(entries2) {
  var data = this.__data__ = new ListCache(entries2);
  this.size = data.size;
}
Stack$4.prototype.clear = stackClear;
Stack$4.prototype["delete"] = stackDelete;
Stack$4.prototype.get = stackGet;
Stack$4.prototype.has = stackHas;
Stack$4.prototype.set = stackSet;
var _Stack = Stack$4;
function nativeKeysIn$1(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$4 = isObject_1, isPrototype$2 = _isPrototype, nativeKeysIn = _nativeKeysIn;
var objectProto$6 = Object.prototype;
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
function baseKeysIn$1(object) {
  if (!isObject$4(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype$2(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$6.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike$3 = isArrayLike_1;
function keysIn$3(object) {
  return isArrayLike$3(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var keysIn_1 = keysIn$3;
var copyObject$3 = _copyObject, keysIn$2 = keysIn_1;
function baseAssignIn$1(object, source) {
  return object && copyObject$3(source, keysIn$2(source), object);
}
var _baseAssignIn = baseAssignIn$1;
var _cloneBuffer = { exports: {} };
(function(module, exports) {
  var root2 = _root;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
function arrayFilter$1(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter = _arrayFilter, stubArray$1 = stubArray_1;
var objectProto$5 = Object.prototype;
var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var _getSymbols = getSymbols$3;
var copyObject$2 = _copyObject, getSymbols$2 = _getSymbols;
function copySymbols$1(source, object) {
  return copyObject$2(source, getSymbols$2(source), object);
}
var _copySymbols = copySymbols$1;
function arrayPush$3(array, values2) {
  var index = -1, length = values2.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values2[index];
  }
  return array;
}
var _arrayPush = arrayPush$3;
var overArg = _overArg;
var getPrototype$3 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$3;
var arrayPush$2 = _arrayPush, getPrototype$2 = _getPrototype, getSymbols$1 = _getSymbols, stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush$2(result, getSymbols$1(object));
    object = getPrototype$2(object);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject$1 = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object) {
  return copyObject$1(source, getSymbolsIn$1(source), object);
}
var _copySymbolsIn = copySymbolsIn$1;
var arrayPush$1 = _arrayPush, isArray$g = isArray_1;
function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$g(object) ? result : arrayPush$1(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$2;
var baseGetAllKeys$1 = _baseGetAllKeys, getSymbols = _getSymbols, keys$3 = keys_1;
function getAllKeys$2(object) {
  return baseGetAllKeys$1(object, keys$3, getSymbols);
}
var _getAllKeys = getAllKeys$2;
var baseGetAllKeys = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$1 = keysIn_1;
function getAllKeysIn$3(object) {
  return baseGetAllKeys(object, keysIn$1, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$3;
var getNative$2 = _getNative, root$3 = _root;
var DataView$2 = getNative$2(root$3, "DataView");
var _DataView = DataView$2;
var getNative$1 = _getNative, root$2 = _root;
var Promise$2 = getNative$1(root$2, "Promise");
var _Promise = Promise$2;
var getNative = _getNative, root$1 = _root;
var Set$4 = getNative(root$1, "Set");
var _Set = Set$4;
var DataView$1 = _DataView, Map$2 = _Map, Promise$1 = _Promise, Set$3 = _Set, WeakMap$1 = _WeakMap, baseGetTag$2 = _baseGetTag, toSource = _toSource;
var mapTag$5 = "[object Map]", objectTag$3 = "[object Object]", promiseTag = "[object Promise]", setTag$5 = "[object Set]", weakMapTag$2 = "[object WeakMap]";
var dataViewTag$3 = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$3), weakMapCtorString = toSource(WeakMap$1);
var getTag$6 = baseGetTag$2;
if (DataView$1 && getTag$6(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$2 && getTag$6(new Map$2()) != mapTag$5 || Promise$1 && getTag$6(Promise$1.resolve()) != promiseTag || Set$3 && getTag$6(new Set$3()) != setTag$5 || WeakMap$1 && getTag$6(new WeakMap$1()) != weakMapTag$2) {
  getTag$6 = function(value) {
    var result = baseGetTag$2(value), Ctor = result == objectTag$3 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$3;
        case mapCtorString:
          return mapTag$5;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$5;
        case weakMapCtorString:
          return weakMapTag$2;
      }
    }
    return result;
  };
}
var _getTag = getTag$6;
var objectProto$4 = Object.prototype;
var hasOwnProperty$5 = objectProto$4.hasOwnProperty;
function initCloneArray$1(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty$5.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var root = _root;
var Uint8Array$3 = root.Uint8Array;
var _Uint8Array = Uint8Array$3;
var Uint8Array$2 = _Uint8Array;
function cloneArrayBuffer$3(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$3;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$4 = _Symbol;
var symbolProto$2 = Symbol$4 ? Symbol$4.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneTypedArray$1(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$1;
var cloneArrayBuffer = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray = _cloneTypedArray;
var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(object);
    case boolTag$2:
    case dateTag$2:
      return new Ctor(+object);
    case dataViewTag$2:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object, isDeep);
    case mapTag$4:
      return new Ctor();
    case numberTag$2:
    case stringTag$2:
      return new Ctor(object);
    case regexpTag$2:
      return cloneRegExp(object);
    case setTag$4:
      return new Ctor();
    case symbolTag$2:
      return cloneSymbol(object);
  }
}
var _initCloneByTag = initCloneByTag$1;
var baseCreate = _baseCreate, getPrototype$1 = _getPrototype, isPrototype$1 = _isPrototype;
function initCloneObject$1(object) {
  return typeof object.constructor == "function" && !isPrototype$1(object) ? baseCreate(getPrototype$1(object)) : {};
}
var _initCloneObject = initCloneObject$1;
var getTag$5 = _getTag, isObjectLike$5 = isObjectLike_1;
var mapTag$3 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$5(value) && getTag$5(value) == mapTag$3;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap, baseUnary$1 = _baseUnary, nodeUtil$1 = _nodeUtil.exports;
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap$3 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$3;
var getTag$4 = _getTag, isObjectLike$4 = isObjectLike_1;
var setTag$3 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike$4(value) && getTag$4(value) == setTag$3;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet, baseUnary = _baseUnary, nodeUtil = _nodeUtil.exports;
var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet$3 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$3;
var Stack$3 = _Stack, arrayEach = _arrayEach, assignValue$1 = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer = _cloneBuffer.exports, copyArray$1 = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys$1 = _getAllKeys, getAllKeysIn$2 = _getAllKeysIn, getTag$3 = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject = _initCloneObject, isArray$f = isArray_1, isBuffer$3 = isBuffer$5.exports, isMap$2 = isMap_1, isObject$3 = isObject_1, isSet$2 = isSet_1, keys$2 = keys_1, keysIn = keysIn_1;
var CLONE_DEEP_FLAG$2 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$2 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$2] = cloneableTags[numberTag$1] = cloneableTags[objectTag$2] = cloneableTags[regexpTag$1] = cloneableTags[setTag$2] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$2] = cloneableTags[funcTag] = cloneableTags[weakMapTag$1] = false;
function baseClone$3(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$3(value)) {
    return value;
  }
  var isArr = isArray$f(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray$1(value, result);
    }
  } else {
    var tag = getTag$3(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$3(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag$2 || tag == argsTag$1 || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack$3());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet$2(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$3(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap$2(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone$3(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn$2 : getAllKeys$1 : isFlat ? keysIn : keys$2;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue$1(result, key2, baseClone$3(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var _baseClone = baseClone$3;
var baseClone$2 = _baseClone;
var CLONE_SYMBOLS_FLAG$1 = 4;
function clone(value) {
  return baseClone$2(value, CLONE_SYMBOLS_FLAG$1);
}
var clone_1 = clone;
var createWrap$1 = _createWrap;
var WRAP_CURRY_FLAG$1 = 8;
function curry(func2, arity, guard) {
  arity = guard ? void 0 : arity;
  var result = createWrap$1(func2, WRAP_CURRY_FLAG$1, void 0, void 0, void 0, void 0, void 0, arity);
  result.placeholder = curry.placeholder;
  return result;
}
curry.placeholder = {};
var curry_1 = curry;
var baseGetTag$1 = _baseGetTag, getPrototype = _getPrototype, isObjectLike$3 = isObjectLike_1;
var objectTag$1 = "[object Object]";
var funcProto = Function.prototype, objectProto$3 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$4 = objectProto$3.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$3(value) {
  if (!isObjectLike$3(value) || baseGetTag$1(value) != objectTag$1) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$4.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$3;
var baseGetTag = _baseGetTag, isObjectLike$2 = isObjectLike_1, isPlainObject$2 = isPlainObject_1;
var domExcTag = "[object DOMException]", errorTag$1 = "[object Error]";
function isError$1(value) {
  if (!isObjectLike$2(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == errorTag$1 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject$2(value);
}
var isError_1 = isError$1;
var getTag$2 = _getTag, isObjectLike$1 = isObjectLike_1;
var weakMapTag = "[object WeakMap]";
function isWeakMap$1(value) {
  return isObjectLike$1(value) && getTag$2(value) == weakMapTag;
}
var isWeakMap_1 = isWeakMap$1;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$1;
var MapCache$1 = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$2(values2) {
  var index = -1, length = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache$1();
  while (++index < length) {
    this.add(values2[index]);
  }
}
SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd;
SetCache$2.prototype.has = setCacheHas;
var _SetCache = SetCache$2;
function arraySome$1(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$1;
function cacheHas$2(cache, key) {
  return cache.has(key);
}
var _cacheHas = cacheHas$2;
var SetCache$1 = _SetCache, arraySome = _arraySome, cacheHas$1 = _cacheHas;
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache$1() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas$1(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
function mapToArray$1(map2) {
  var index = -1, result = Array(map2.size);
  map2.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$3(set3) {
  var index = -1, result = Array(set3.size);
  set3.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
var _setToArray = setToArray$3;
var Symbol$3 = _Symbol, Uint8Array$1 = _Uint8Array, eq = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray$2 = _setToArray;
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag$1 = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      return object == other + "";
    case mapTag$1:
      var convert2 = mapToArray;
    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert2 || (convert2 = setToArray$2);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object, other);
      var result = equalArrays$1(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
var getAllKeys = _getAllKeys;
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$2 = Object.prototype;
var hasOwnProperty$3 = objectProto$2.hasOwnProperty;
function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$3.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var Stack$2 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag$1 = _getTag, isArray$e = isArray_1, isBuffer$2 = isBuffer$5.exports, isTypedArray$1 = isTypedArray_1;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto$1 = Object.prototype;
var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$e(object), othIsArr = isArray$e(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$2(object)) {
    if (!isBuffer$2(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$2());
    return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$2.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$2());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$2());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike = isObjectLike_1;
function baseIsEqual$3(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$3, stack);
}
var _baseIsEqual = baseIsEqual$3;
var Stack$1 = _Stack, baseIsEqual$2 = _baseIsEqual;
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch$1(object, source, matchData, customizer) {
  var index = matchData.length, length = index, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack$1();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual$2(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch$1;
var isObject$2 = isObject_1;
function isStrictComparable$2(value) {
  return value === value && !isObject$2(value);
}
var _isStrictComparable = isStrictComparable$2;
var isStrictComparable$1 = _isStrictComparable, keys$1 = keys_1;
function getMatchData$1(object) {
  var result = keys$1(object), length = result.length;
  while (length--) {
    var key = result[length], value = object[key];
    result[length] = [key, value, isStrictComparable$1(value)];
  }
  return result;
}
var _getMatchData = getMatchData$1;
function matchesStrictComparable$2(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var _matchesStrictComparable = matchesStrictComparable$2;
var baseIsMatch = _baseIsMatch, getMatchData = _getMatchData, matchesStrictComparable$1 = _matchesStrictComparable;
function baseMatches$1(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}
var _baseMatches = baseMatches$1;
var isArray$d = isArray_1, isSymbol$4 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey$3(value, object) {
  if (isArray$d(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$4(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$3;
var MapCache = _MapCache;
var FUNC_ERROR_TEXT$2 = "Expected a function";
function memoize$1(func2, resolver) {
  if (typeof func2 != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func2.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache)();
  return memoized;
}
memoize$1.Cache = MapCache;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func2) {
  var result = memoize(func2, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar$1 = /\\(\\)?/g;
var stringToPath$3 = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName$1, function(match3, number, quote2, subString) {
    result.push(quote2 ? subString.replace(reEscapeChar$1, "$1") : number || match3);
  });
  return result;
});
var _stringToPath = stringToPath$3;
function arrayMap$4(array, iteratee2) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee2(array[index], index, array);
  }
  return result;
}
var _arrayMap = arrayMap$4;
var Symbol$2 = _Symbol, arrayMap$3 = _arrayMap, isArray$c = isArray_1, isSymbol$3 = isSymbol_1;
var INFINITY$2 = 1 / 0;
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString$2(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$c(value)) {
    return arrayMap$3(value, baseToString$2) + "";
  }
  if (isSymbol$3(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
}
var _baseToString = baseToString$2;
var baseToString$1 = _baseToString;
function toString$4(value) {
  return value == null ? "" : baseToString$1(value);
}
var toString_1 = toString$4;
var isArray$b = isArray_1, isKey$2 = _isKey, stringToPath$2 = _stringToPath, toString$3 = toString_1;
function castPath$6(value, object) {
  if (isArray$b(value)) {
    return value;
  }
  return isKey$2(value, object) ? [value] : stringToPath$2(toString$3(value));
}
var _castPath = castPath$6;
var isSymbol$2 = isSymbol_1;
var INFINITY$1 = 1 / 0;
function toKey$7(value) {
  if (typeof value == "string" || isSymbol$2(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var _toKey = toKey$7;
var castPath$5 = _castPath, toKey$6 = _toKey;
function baseGet$4(object, path) {
  path = castPath$5(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey$6(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var _baseGet = baseGet$4;
var baseGet$3 = _baseGet;
function get$3(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet$3(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get$3;
function baseHasIn$1(object, key) {
  return object != null && key in Object(object);
}
var _baseHasIn = baseHasIn$1;
var castPath$4 = _castPath, isArguments$2 = isArguments_1, isArray$a = isArray_1, isIndex$1 = _isIndex, isLength = isLength_1, toKey$5 = _toKey;
function hasPath$1(object, path, hasFunc) {
  path = castPath$4(path, object);
  var index = -1, length = path.length, result = false;
  while (++index < length) {
    var key = toKey$5(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex$1(key, length) && (isArray$a(object) || isArguments$2(object));
}
var _hasPath = hasPath$1;
var baseHasIn = _baseHasIn, hasPath = _hasPath;
function hasIn$3(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var hasIn_1 = hasIn$3;
var baseIsEqual$1 = _baseIsEqual, get$2 = get_1, hasIn$2 = hasIn_1, isKey$1 = _isKey, isStrictComparable = _isStrictComparable, matchesStrictComparable = _matchesStrictComparable, toKey$4 = _toKey;
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty$1(path, srcValue) {
  if (isKey$1(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey$4(path), srcValue);
  }
  return function(object) {
    var objValue = get$2(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn$2(object, path) : baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
var _baseMatchesProperty = baseMatchesProperty$1;
function baseProperty$1(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var _baseProperty = baseProperty$1;
var baseGet$2 = _baseGet;
function basePropertyDeep$1(path) {
  return function(object) {
    return baseGet$2(object, path);
  };
}
var _basePropertyDeep = basePropertyDeep$1;
var baseProperty = _baseProperty, basePropertyDeep = _basePropertyDeep, isKey = _isKey, toKey$3 = _toKey;
function property$1(path) {
  return isKey(path) ? baseProperty(toKey$3(path)) : basePropertyDeep(path);
}
var property_1 = property$1;
var baseMatches = _baseMatches, baseMatchesProperty = _baseMatchesProperty, identity = identity_1, isArray$9 = isArray_1, property = property_1;
function baseIteratee$4(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == "object") {
    return isArray$9(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
var _baseIteratee = baseIteratee$4;
var baseClone$1 = _baseClone, baseIteratee$3 = _baseIteratee;
var CLONE_DEEP_FLAG$1 = 1;
function iteratee(func2) {
  return baseIteratee$3(typeof func2 == "function" ? func2 : baseClone$1(func2, CLONE_DEEP_FLAG$1));
}
var iteratee_1 = iteratee;
var Symbol$1 = _Symbol, isArguments$1 = isArguments_1, isArray$8 = isArray_1;
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray$8(value) || isArguments$1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush = _arrayPush, isFlattenable = _isFlattenable;
function baseFlatten$1(array, depth, predicate, isStrict, result) {
  var index = -1, length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten$1(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten$1;
var baseFlatten = _baseFlatten;
function flatten$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}
var flatten_1 = flatten$1;
var apply = _apply;
var nativeMax = Math.max;
function overRest$1(func2, start, transform) {
  start = nativeMax(start === void 0 ? func2.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func2, this, otherArgs);
  };
}
var _overRest = overRest$1;
var flatten = flatten_1, overRest = _overRest, setToString = _setToString;
function flatRest$3(func2) {
  return setToString(overRest(func2, void 0, flatten), func2 + "");
}
var _flatRest = flatRest$3;
var createWrap = _createWrap, flatRest$2 = _flatRest;
var WRAP_REARG_FLAG$1 = 256;
var rearg = flatRest$2(function(func2, indexes) {
  return createWrap(func2, WRAP_REARG_FLAG$1, void 0, void 0, void 0, indexes);
});
var rearg_1 = rearg;
var arrayMap$2 = _arrayMap, copyArray = _copyArray, isArray$7 = isArray_1, isSymbol$1 = isSymbol_1, stringToPath$1 = _stringToPath, toKey$2 = _toKey, toString$2 = toString_1;
function toPath(value) {
  if (isArray$7(value)) {
    return arrayMap$2(value, toKey$2);
  }
  return isSymbol$1(value) ? [value] : copyArray(stringToPath$1(toString$2(value)));
}
var toPath_1 = toPath;
var _util = {
  "ary": ary_1,
  "assign": _baseAssign,
  "clone": clone_1,
  "curry": curry_1,
  "forEach": _arrayEach,
  "isArray": isArray_1,
  "isError": isError_1,
  "isFunction": isFunction_1,
  "isWeakMap": isWeakMap_1,
  "iteratee": iteratee_1,
  "keys": _baseKeys,
  "rearg": rearg_1,
  "toInteger": toInteger_1,
  "toPath": toPath_1
};
var baseConvert = _baseConvert, util = _util;
function convert$9(name, func2, options) {
  return baseConvert(util, name, func2, options);
}
var convert_1 = convert$9;
var LodashWrapper = _LodashWrapper, flatRest$1 = _flatRest, getData = _getData, getFuncName = _getFuncName, isArray$6 = isArray_1, isLaziable = _isLaziable;
var FUNC_ERROR_TEXT$1 = "Expected a function";
var WRAP_CURRY_FLAG = 8, WRAP_PARTIAL_FLAG = 32, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256;
function createFlow$1(fromRight) {
  return flatRest$1(function(funcs) {
    var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
    if (fromRight) {
      funcs.reverse();
    }
    while (index--) {
      var func2 = funcs[index];
      if (typeof func2 != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      if (prereq && !wrapper && getFuncName(func2) == "wrapper") {
        var wrapper = new LodashWrapper([], true);
      }
    }
    index = wrapper ? index : length;
    while (++index < length) {
      func2 = funcs[index];
      var funcName = getFuncName(func2), data = funcName == "wrapper" ? getData(func2) : void 0;
      if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
      } else {
        wrapper = func2.length == 1 && isLaziable(func2) ? wrapper[funcName]() : wrapper.thru(func2);
      }
    }
    return function() {
      var args = arguments, value = args[0];
      if (wrapper && args.length == 1 && isArray$6(value)) {
        return wrapper.plant(value).value();
      }
      var index2 = 0, result = length ? funcs[index2].apply(this, args) : value;
      while (++index2 < length) {
        result = funcs[index2].call(this, result);
      }
      return result;
    };
  });
}
var _createFlow = createFlow$1;
var createFlow = _createFlow;
var flow$1 = createFlow();
var flow_1 = flow$1;
var convert$8 = convert_1, func$8 = convert$8("flow", flow_1);
func$8.placeholder = placeholder;
var flow = func$8;
function arrayReduce$1(array, iteratee2, accumulator, initAccum) {
  var index = -1, length = array == null ? 0 : array.length;
  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee2(accumulator, array[index], index, array);
  }
  return accumulator;
}
var _arrayReduce = arrayReduce$1;
function createBaseFor$1(fromRight) {
  return function(object, iteratee2, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee2(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
var baseFor = _baseFor, keys = keys_1;
function baseForOwn$1(object, iteratee2) {
  return object && baseFor(object, iteratee2, keys);
}
var _baseForOwn = baseForOwn$1;
var isArrayLike$2 = isArrayLike_1;
function createBaseEach$1(eachFunc, fromRight) {
  return function(collection, iteratee2) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike$2(collection)) {
      return eachFunc(collection, iteratee2);
    }
    var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index-- : ++index < length) {
      if (iteratee2(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var _createBaseEach = createBaseEach$1;
var baseForOwn = _baseForOwn, createBaseEach = _createBaseEach;
var baseEach$1 = createBaseEach(baseForOwn);
var _baseEach = baseEach$1;
function baseReduce$1(collection, iteratee2, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index, collection2) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee2(accumulator, value, index, collection2);
  });
  return accumulator;
}
var _baseReduce = baseReduce$1;
var arrayReduce = _arrayReduce, baseEach = _baseEach, baseIteratee$2 = _baseIteratee, baseReduce = _baseReduce, isArray$5 = isArray_1;
function reduce$1(collection, iteratee2, accumulator) {
  var func2 = isArray$5(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
  return func2(collection, baseIteratee$2(iteratee2), accumulator, initAccum, baseEach);
}
var reduce_1 = reduce$1;
var convert$7 = convert_1, func$7 = convert$7("reduce", reduce_1);
func$7.placeholder = placeholder;
var convert$6 = convert_1, func$6 = convert$6("get", get_1);
func$6.placeholder = placeholder;
var get$1 = func$6;
function baseSlice$2(array, start, end) {
  var index = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}
var _baseSlice = baseSlice$2;
var baseSlice$1 = _baseSlice;
function castSlice$1(array, start, end) {
  var length = array.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array : baseSlice$1(array, start, end);
}
var _castSlice = castSlice$1;
var baseIndexOf$1 = _baseIndexOf;
function charsEndIndex$1(strSymbols, chrSymbols) {
  var index = strSymbols.length;
  while (index-- && baseIndexOf$1(chrSymbols, strSymbols[index], 0) > -1) {
  }
  return index;
}
var _charsEndIndex = charsEndIndex$1;
var baseIndexOf = _baseIndexOf;
function charsStartIndex$1(strSymbols, chrSymbols) {
  var index = -1, length = strSymbols.length;
  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
  }
  return index;
}
var _charsStartIndex = charsStartIndex$1;
function asciiToArray$1(string) {
  return string.split("");
}
var _asciiToArray = asciiToArray$1;
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsZWJ$1 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
function hasUnicode$1(string) {
  return reHasUnicode.test(string);
}
var _hasUnicode = hasUnicode$1;
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray$1(string) {
  return string.match(reUnicode) || [];
}
var _unicodeToArray = unicodeToArray$1;
var asciiToArray = _asciiToArray, hasUnicode = _hasUnicode, unicodeToArray = _unicodeToArray;
function stringToArray$1(string) {
  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
}
var _stringToArray = stringToArray$1;
var baseToString = _baseToString, baseTrim = _baseTrim, castSlice = _castSlice, charsEndIndex = _charsEndIndex, charsStartIndex = _charsStartIndex, stringToArray = _stringToArray, toString$1 = toString_1;
function trim$1(string, chars, guard) {
  string = toString$1(string);
  if (string && (guard || chars === void 0)) {
    return baseTrim(string);
  }
  if (!string || !(chars = baseToString(chars))) {
    return string;
  }
  var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
  return castSlice(strSymbols, start, end).join("");
}
var trim_1 = trim$1;
var convert$5 = convert_1, func$5 = convert$5("trim", trim_1);
func$5.placeholder = placeholder;
var trim = func$5;
var baseKeys = _baseKeys, getTag = _getTag, isArguments = isArguments_1, isArray$4 = isArray_1, isArrayLike$1 = isArrayLike_1, isBuffer$1 = isBuffer$5.exports, isPrototype = _isPrototype, isTypedArray = isTypedArray_1;
var mapTag = "[object Map]", setTag = "[object Set]";
var objectProto = Object.prototype;
var hasOwnProperty$1 = objectProto.hasOwnProperty;
function isEmpty$1(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike$1(value) && (isArray$4(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer$1(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty$1.call(value, key)) {
      return false;
    }
  }
  return true;
}
var isEmpty_1 = isEmpty$1;
var _falseOptions = {
  "cap": false,
  "curry": false,
  "fixed": false,
  "immutable": false,
  "rearg": false
};
var convert$4 = convert_1, func$4 = convert$4("isEmpty", isEmpty_1, _falseOptions);
func$4.placeholder = placeholder;
var isEmpty = func$4;
function last$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
var last_1 = last$1;
var baseGet$1 = _baseGet, baseSlice = _baseSlice;
function parent$1(object, path) {
  return path.length < 2 ? object : baseGet$1(object, baseSlice(path, 0, -1));
}
var _parent = parent$1;
var castPath$3 = _castPath, last = last_1, parent = _parent, toKey$1 = _toKey;
function baseUnset$1(object, path) {
  path = castPath$3(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey$1(last(path))];
}
var _baseUnset = baseUnset$1;
var isPlainObject$1 = isPlainObject_1;
function customOmitClone$1(value) {
  return isPlainObject$1(value) ? void 0 : value;
}
var _customOmitClone = customOmitClone$1;
var arrayMap$1 = _arrayMap, baseClone = _baseClone, baseUnset = _baseUnset, castPath$2 = _castPath, copyObject = _copyObject, customOmitClone = _customOmitClone, flatRest = _flatRest, getAllKeysIn$1 = _getAllKeysIn;
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
var omit$1 = flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = arrayMap$1(paths, function(path) {
    path = castPath$2(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject(object, getAllKeysIn$1(object), result);
  if (isDeep) {
    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    baseUnset(result, paths[length]);
  }
  return result;
});
var omit_1 = omit$1;
var convert$3 = convert_1, func$3 = convert$3("omit", omit_1);
func$3.placeholder = placeholder;
var omit = func$3;
var DELETE = "delete";
var SHIFT = 5;
var SIZE = 1 << SHIFT;
var MASK = SIZE - 1;
var NOT_SET = {};
function MakeRef() {
  return {
    value: false
  };
}
function SetRef(ref) {
  if (ref) {
    ref.value = true;
  }
}
function OwnerID() {
}
function ensureSize(iter) {
  if (iter.size === void 0) {
    iter.size = iter.__iterate(returnTrue2);
  }
  return iter.size;
}
function wrapIndex(iter, index) {
  if (typeof index !== "number") {
    var uint32Index = index >>> 0;
    if ("" + uint32Index !== index || uint32Index === 4294967295) {
      return NaN;
    }
    index = uint32Index;
  }
  return index < 0 ? ensureSize(iter) + index : index;
}
function returnTrue2() {
  return true;
}
function wholeSlice(begin, end, size) {
  return (begin === 0 && !isNeg(begin) || size !== void 0 && begin <= -size) && (end === void 0 || size !== void 0 && end >= size);
}
function resolveBegin(begin, size) {
  return resolveIndex(begin, size, 0);
}
function resolveEnd(end, size) {
  return resolveIndex(end, size, size);
}
function resolveIndex(index, size, defaultIndex) {
  return index === void 0 ? defaultIndex : isNeg(index) ? size === Infinity ? size : Math.max(0, size + index) | 0 : size === void 0 || size === index ? index : Math.min(size, index) | 0;
}
function isNeg(value) {
  return value < 0 || value === 0 && 1 / value === -Infinity;
}
var IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
function isCollection(maybeCollection) {
  return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);
}
var IS_KEYED_SYMBOL = "@@__IMMUTABLE_KEYED__@@";
function isKeyed(maybeKeyed) {
  return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);
}
var IS_INDEXED_SYMBOL = "@@__IMMUTABLE_INDEXED__@@";
function isIndexed(maybeIndexed) {
  return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);
}
function isAssociative(maybeAssociative) {
  return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
}
var Collection = function Collection2(value) {
  return isCollection(value) ? value : Seq(value);
};
var KeyedCollection = /* @__PURE__ */ function(Collection3) {
  function KeyedCollection2(value) {
    return isKeyed(value) ? value : KeyedSeq(value);
  }
  if (Collection3)
    KeyedCollection2.__proto__ = Collection3;
  KeyedCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
  KeyedCollection2.prototype.constructor = KeyedCollection2;
  return KeyedCollection2;
}(Collection);
var IndexedCollection = /* @__PURE__ */ function(Collection3) {
  function IndexedCollection2(value) {
    return isIndexed(value) ? value : IndexedSeq(value);
  }
  if (Collection3)
    IndexedCollection2.__proto__ = Collection3;
  IndexedCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
  IndexedCollection2.prototype.constructor = IndexedCollection2;
  return IndexedCollection2;
}(Collection);
var SetCollection = /* @__PURE__ */ function(Collection3) {
  function SetCollection2(value) {
    return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
  }
  if (Collection3)
    SetCollection2.__proto__ = Collection3;
  SetCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
  SetCollection2.prototype.constructor = SetCollection2;
  return SetCollection2;
}(Collection);
Collection.Keyed = KeyedCollection;
Collection.Indexed = IndexedCollection;
Collection.Set = SetCollection;
var IS_SEQ_SYMBOL = "@@__IMMUTABLE_SEQ__@@";
function isSeq(maybeSeq) {
  return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);
}
var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
function isRecord(maybeRecord) {
  return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);
}
function isImmutable(maybeImmutable) {
  return isCollection(maybeImmutable) || isRecord(maybeImmutable);
}
var IS_ORDERED_SYMBOL = "@@__IMMUTABLE_ORDERED__@@";
function isOrdered(maybeOrdered) {
  return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);
}
var ITERATE_KEYS = 0;
var ITERATE_VALUES = 1;
var ITERATE_ENTRIES = 2;
var REAL_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = "@@iterator";
var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
var Iterator = function Iterator2(next) {
  this.next = next;
};
Iterator.prototype.toString = function toString() {
  return "[Iterator]";
};
Iterator.KEYS = ITERATE_KEYS;
Iterator.VALUES = ITERATE_VALUES;
Iterator.ENTRIES = ITERATE_ENTRIES;
Iterator.prototype.inspect = Iterator.prototype.toSource = function() {
  return this.toString();
};
Iterator.prototype[ITERATOR_SYMBOL] = function() {
  return this;
};
function iteratorValue(type, k, v, iteratorResult) {
  var value = type === 0 ? k : type === 1 ? v : [k, v];
  iteratorResult ? iteratorResult.value = value : iteratorResult = {
    value,
    done: false
  };
  return iteratorResult;
}
function iteratorDone() {
  return {
    value: void 0,
    done: true
  };
}
function hasIterator(maybeIterable) {
  if (Array.isArray(maybeIterable)) {
    return true;
  }
  return !!getIteratorFn(maybeIterable);
}
function isIterator(maybeIterator) {
  return maybeIterator && typeof maybeIterator.next === "function";
}
function getIterator(iterable) {
  var iteratorFn = getIteratorFn(iterable);
  return iteratorFn && iteratorFn.call(iterable);
}
function getIteratorFn(iterable) {
  var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === "function") {
    return iteratorFn;
  }
}
function isEntriesIterable(maybeIterable) {
  var iteratorFn = getIteratorFn(maybeIterable);
  return iteratorFn && iteratorFn === maybeIterable.entries;
}
function isKeysIterable(maybeIterable) {
  var iteratorFn = getIteratorFn(maybeIterable);
  return iteratorFn && iteratorFn === maybeIterable.keys;
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function isArrayLike(value) {
  if (Array.isArray(value) || typeof value === "string") {
    return true;
  }
  return value && typeof value === "object" && Number.isInteger(value.length) && value.length >= 0 && (value.length === 0 ? Object.keys(value).length === 1 : value.hasOwnProperty(value.length - 1));
}
var Seq = /* @__PURE__ */ function(Collection3) {
  function Seq2(value) {
    return value === null || value === void 0 ? emptySequence() : isImmutable(value) ? value.toSeq() : seqFromValue(value);
  }
  if (Collection3)
    Seq2.__proto__ = Collection3;
  Seq2.prototype = Object.create(Collection3 && Collection3.prototype);
  Seq2.prototype.constructor = Seq2;
  Seq2.prototype.toSeq = function toSeq2() {
    return this;
  };
  Seq2.prototype.toString = function toString4() {
    return this.__toString("Seq {", "}");
  };
  Seq2.prototype.cacheResult = function cacheResult() {
    if (!this._cache && this.__iterateUncached) {
      this._cache = this.entrySeq().toArray();
      this.size = this._cache.length;
    }
    return this;
  };
  Seq2.prototype.__iterate = function __iterate(fn, reverse3) {
    var cache = this._cache;
    if (cache) {
      var size = cache.length;
      var i = 0;
      while (i !== size) {
        var entry = cache[reverse3 ? size - ++i : i++];
        if (fn(entry[1], entry[0], this) === false) {
          break;
        }
      }
      return i;
    }
    return this.__iterateUncached(fn, reverse3);
  };
  Seq2.prototype.__iterator = function __iterator(type, reverse3) {
    var cache = this._cache;
    if (cache) {
      var size = cache.length;
      var i = 0;
      return new Iterator(function() {
        if (i === size) {
          return iteratorDone();
        }
        var entry = cache[reverse3 ? size - ++i : i++];
        return iteratorValue(type, entry[0], entry[1]);
      });
    }
    return this.__iteratorUncached(type, reverse3);
  };
  return Seq2;
}(Collection);
var KeyedSeq = /* @__PURE__ */ function(Seq2) {
  function KeyedSeq2(value) {
    return value === null || value === void 0 ? emptySequence().toKeyedSeq() : isCollection(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);
  }
  if (Seq2)
    KeyedSeq2.__proto__ = Seq2;
  KeyedSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
  KeyedSeq2.prototype.constructor = KeyedSeq2;
  KeyedSeq2.prototype.toKeyedSeq = function toKeyedSeq3() {
    return this;
  };
  return KeyedSeq2;
}(Seq);
var IndexedSeq = /* @__PURE__ */ function(Seq2) {
  function IndexedSeq2(value) {
    return value === null || value === void 0 ? emptySequence() : isCollection(value) ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq() : isRecord(value) ? value.toSeq().entrySeq() : indexedSeqFromValue(value);
  }
  if (Seq2)
    IndexedSeq2.__proto__ = Seq2;
  IndexedSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
  IndexedSeq2.prototype.constructor = IndexedSeq2;
  IndexedSeq2.of = function of() {
    return IndexedSeq2(arguments);
  };
  IndexedSeq2.prototype.toIndexedSeq = function toIndexedSeq2() {
    return this;
  };
  IndexedSeq2.prototype.toString = function toString4() {
    return this.__toString("Seq [", "]");
  };
  return IndexedSeq2;
}(Seq);
var SetSeq = /* @__PURE__ */ function(Seq2) {
  function SetSeq2(value) {
    return (isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)).toSetSeq();
  }
  if (Seq2)
    SetSeq2.__proto__ = Seq2;
  SetSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
  SetSeq2.prototype.constructor = SetSeq2;
  SetSeq2.of = function of() {
    return SetSeq2(arguments);
  };
  SetSeq2.prototype.toSetSeq = function toSetSeq2() {
    return this;
  };
  return SetSeq2;
}(Seq);
Seq.isSeq = isSeq;
Seq.Keyed = KeyedSeq;
Seq.Set = SetSeq;
Seq.Indexed = IndexedSeq;
Seq.prototype[IS_SEQ_SYMBOL] = true;
var ArraySeq = /* @__PURE__ */ function(IndexedSeq2) {
  function ArraySeq2(array) {
    this._array = array;
    this.size = array.length;
  }
  if (IndexedSeq2)
    ArraySeq2.__proto__ = IndexedSeq2;
  ArraySeq2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  ArraySeq2.prototype.constructor = ArraySeq2;
  ArraySeq2.prototype.get = function get11(index, notSetValue) {
    return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
  };
  ArraySeq2.prototype.__iterate = function __iterate(fn, reverse3) {
    var array = this._array;
    var size = array.length;
    var i = 0;
    while (i !== size) {
      var ii = reverse3 ? size - ++i : i++;
      if (fn(array[ii], ii, this) === false) {
        break;
      }
    }
    return i;
  };
  ArraySeq2.prototype.__iterator = function __iterator(type, reverse3) {
    var array = this._array;
    var size = array.length;
    var i = 0;
    return new Iterator(function() {
      if (i === size) {
        return iteratorDone();
      }
      var ii = reverse3 ? size - ++i : i++;
      return iteratorValue(type, ii, array[ii]);
    });
  };
  return ArraySeq2;
}(IndexedSeq);
var ObjectSeq = /* @__PURE__ */ function(KeyedSeq2) {
  function ObjectSeq2(object) {
    var keys3 = Object.keys(object);
    this._object = object;
    this._keys = keys3;
    this.size = keys3.length;
  }
  if (KeyedSeq2)
    ObjectSeq2.__proto__ = KeyedSeq2;
  ObjectSeq2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
  ObjectSeq2.prototype.constructor = ObjectSeq2;
  ObjectSeq2.prototype.get = function get11(key, notSetValue) {
    if (notSetValue !== void 0 && !this.has(key)) {
      return notSetValue;
    }
    return this._object[key];
  };
  ObjectSeq2.prototype.has = function has4(key) {
    return hasOwnProperty.call(this._object, key);
  };
  ObjectSeq2.prototype.__iterate = function __iterate(fn, reverse3) {
    var object = this._object;
    var keys3 = this._keys;
    var size = keys3.length;
    var i = 0;
    while (i !== size) {
      var key = keys3[reverse3 ? size - ++i : i++];
      if (fn(object[key], key, this) === false) {
        break;
      }
    }
    return i;
  };
  ObjectSeq2.prototype.__iterator = function __iterator(type, reverse3) {
    var object = this._object;
    var keys3 = this._keys;
    var size = keys3.length;
    var i = 0;
    return new Iterator(function() {
      if (i === size) {
        return iteratorDone();
      }
      var key = keys3[reverse3 ? size - ++i : i++];
      return iteratorValue(type, key, object[key]);
    });
  };
  return ObjectSeq2;
}(KeyedSeq);
ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;
var CollectionSeq = /* @__PURE__ */ function(IndexedSeq2) {
  function CollectionSeq2(collection) {
    this._collection = collection;
    this.size = collection.length || collection.size;
  }
  if (IndexedSeq2)
    CollectionSeq2.__proto__ = IndexedSeq2;
  CollectionSeq2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  CollectionSeq2.prototype.constructor = CollectionSeq2;
  CollectionSeq2.prototype.__iterateUncached = function __iterateUncached(fn, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var collection = this._collection;
    var iterator = getIterator(collection);
    var iterations = 0;
    if (isIterator(iterator)) {
      var step;
      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this) === false) {
          break;
        }
      }
    }
    return iterations;
  };
  CollectionSeq2.prototype.__iteratorUncached = function __iteratorUncached(type, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var collection = this._collection;
    var iterator = getIterator(collection);
    if (!isIterator(iterator)) {
      return new Iterator(iteratorDone);
    }
    var iterations = 0;
    return new Iterator(function() {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, iterations++, step.value);
    });
  };
  return CollectionSeq2;
}(IndexedSeq);
var EMPTY_SEQ;
function emptySequence() {
  return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
}
function keyedSeqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq.fromEntrySeq();
  }
  if (typeof value === "object") {
    return new ObjectSeq(value);
  }
  throw new TypeError("Expected Array or collection object of [k, v] entries, or keyed object: " + value);
}
function indexedSeqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq;
  }
  throw new TypeError("Expected Array or collection object of values: " + value);
}
function seqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return isEntriesIterable(value) ? seq.fromEntrySeq() : isKeysIterable(value) ? seq.toSetSeq() : seq;
  }
  if (typeof value === "object") {
    return new ObjectSeq(value);
  }
  throw new TypeError("Expected Array or collection object of values, or keyed object: " + value);
}
function maybeIndexedSeqFromValue(value) {
  return isArrayLike(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : void 0;
}
var IS_MAP_SYMBOL = "@@__IMMUTABLE_MAP__@@";
function isMap$1(maybeMap3) {
  return Boolean(maybeMap3 && maybeMap3[IS_MAP_SYMBOL]);
}
function isOrderedMap(maybeOrderedMap) {
  return isMap$1(maybeOrderedMap) && isOrdered(maybeOrderedMap);
}
function isValueObject(maybeValue) {
  return Boolean(maybeValue && typeof maybeValue.equals === "function" && typeof maybeValue.hashCode === "function");
}
function is(valueA, valueB) {
  if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
    return true;
  }
  if (!valueA || !valueB) {
    return false;
  }
  if (typeof valueA.valueOf === "function" && typeof valueB.valueOf === "function") {
    valueA = valueA.valueOf();
    valueB = valueB.valueOf();
    if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
  }
  return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));
}
var imul = typeof Math.imul === "function" && Math.imul(4294967295, 2) === -2 ? Math.imul : function imul2(a, b) {
  a |= 0;
  b |= 0;
  var c = a & 65535;
  var d = b & 65535;
  return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0;
};
function smi(i32) {
  return i32 >>> 1 & 1073741824 | i32 & 3221225471;
}
var defaultValueOf = Object.prototype.valueOf;
function hash(o) {
  if (o == null) {
    return hashNullish(o);
  }
  if (typeof o.hashCode === "function") {
    return smi(o.hashCode(o));
  }
  var v = valueOf(o);
  if (v == null) {
    return hashNullish(v);
  }
  switch (typeof v) {
    case "boolean":
      return v ? 1108378657 : 1108378656;
    case "number":
      return hashNumber(v);
    case "string":
      return v.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(v) : hashString(v);
    case "object":
    case "function":
      return hashJSObj(v);
    case "symbol":
      return hashSymbol(v);
    default:
      if (typeof v.toString === "function") {
        return hashString(v.toString());
      }
      throw new Error("Value type " + typeof v + " cannot be hashed.");
  }
}
function hashNullish(nullish) {
  return nullish === null ? 1108378658 : 1108378659;
}
function hashNumber(n2) {
  if (n2 !== n2 || n2 === Infinity) {
    return 0;
  }
  var hash2 = n2 | 0;
  if (hash2 !== n2) {
    hash2 ^= n2 * 4294967295;
  }
  while (n2 > 4294967295) {
    n2 /= 4294967295;
    hash2 ^= n2;
  }
  return smi(hash2);
}
function cachedHashString(string) {
  var hashed = stringHashCache[string];
  if (hashed === void 0) {
    hashed = hashString(string);
    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
      STRING_HASH_CACHE_SIZE = 0;
      stringHashCache = {};
    }
    STRING_HASH_CACHE_SIZE++;
    stringHashCache[string] = hashed;
  }
  return hashed;
}
function hashString(string) {
  var hashed = 0;
  for (var ii = 0; ii < string.length; ii++) {
    hashed = 31 * hashed + string.charCodeAt(ii) | 0;
  }
  return smi(hashed);
}
function hashSymbol(sym) {
  var hashed = symbolMap[sym];
  if (hashed !== void 0) {
    return hashed;
  }
  hashed = nextHash();
  symbolMap[sym] = hashed;
  return hashed;
}
function hashJSObj(obj) {
  var hashed;
  if (usingWeakMap) {
    hashed = weakMap.get(obj);
    if (hashed !== void 0) {
      return hashed;
    }
  }
  hashed = obj[UID_HASH_KEY];
  if (hashed !== void 0) {
    return hashed;
  }
  if (!canDefineProperty) {
    hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
    if (hashed !== void 0) {
      return hashed;
    }
    hashed = getIENodeHash(obj);
    if (hashed !== void 0) {
      return hashed;
    }
  }
  hashed = nextHash();
  if (usingWeakMap) {
    weakMap.set(obj, hashed);
  } else if (isExtensible !== void 0 && isExtensible(obj) === false) {
    throw new Error("Non-extensible objects are not allowed as keys.");
  } else if (canDefineProperty) {
    Object.defineProperty(obj, UID_HASH_KEY, {
      enumerable: false,
      configurable: false,
      writable: false,
      value: hashed
    });
  } else if (obj.propertyIsEnumerable !== void 0 && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
    obj.propertyIsEnumerable = function() {
      return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
    };
    obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
  } else if (obj.nodeType !== void 0) {
    obj[UID_HASH_KEY] = hashed;
  } else {
    throw new Error("Unable to set a non-enumerable property on object.");
  }
  return hashed;
}
var isExtensible = Object.isExtensible;
var canDefineProperty = function() {
  try {
    Object.defineProperty({}, "@", {});
    return true;
  } catch (e) {
    return false;
  }
}();
function getIENodeHash(node) {
  if (node && node.nodeType > 0) {
    switch (node.nodeType) {
      case 1:
        return node.uniqueID;
      case 9:
        return node.documentElement && node.documentElement.uniqueID;
    }
  }
}
function valueOf(obj) {
  return obj.valueOf !== defaultValueOf && typeof obj.valueOf === "function" ? obj.valueOf(obj) : obj;
}
function nextHash() {
  var nextHash2 = ++_objHashUID;
  if (_objHashUID & 1073741824) {
    _objHashUID = 0;
  }
  return nextHash2;
}
var usingWeakMap = typeof WeakMap === "function";
var weakMap;
if (usingWeakMap) {
  weakMap = new WeakMap();
}
var symbolMap = Object.create(null);
var _objHashUID = 0;
var UID_HASH_KEY = "__immutablehash__";
if (typeof Symbol === "function") {
  UID_HASH_KEY = Symbol(UID_HASH_KEY);
}
var STRING_HASH_CACHE_MIN_STRLEN = 16;
var STRING_HASH_CACHE_MAX_SIZE = 255;
var STRING_HASH_CACHE_SIZE = 0;
var stringHashCache = {};
var ToKeyedSequence = /* @__PURE__ */ function(KeyedSeq2) {
  function ToKeyedSequence2(indexed, useKeys) {
    this._iter = indexed;
    this._useKeys = useKeys;
    this.size = indexed.size;
  }
  if (KeyedSeq2)
    ToKeyedSequence2.__proto__ = KeyedSeq2;
  ToKeyedSequence2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
  ToKeyedSequence2.prototype.constructor = ToKeyedSequence2;
  ToKeyedSequence2.prototype.get = function get11(key, notSetValue) {
    return this._iter.get(key, notSetValue);
  };
  ToKeyedSequence2.prototype.has = function has4(key) {
    return this._iter.has(key);
  };
  ToKeyedSequence2.prototype.valueSeq = function valueSeq2() {
    return this._iter.valueSeq();
  };
  ToKeyedSequence2.prototype.reverse = function reverse3() {
    var this$1$1 = this;
    var reversedSequence = reverseFactory(this, true);
    if (!this._useKeys) {
      reversedSequence.valueSeq = function() {
        return this$1$1._iter.toSeq().reverse();
      };
    }
    return reversedSequence;
  };
  ToKeyedSequence2.prototype.map = function map2(mapper, context) {
    var this$1$1 = this;
    var mappedSequence = mapFactory(this, mapper, context);
    if (!this._useKeys) {
      mappedSequence.valueSeq = function() {
        return this$1$1._iter.toSeq().map(mapper, context);
      };
    }
    return mappedSequence;
  };
  ToKeyedSequence2.prototype.__iterate = function __iterate(fn, reverse3) {
    var this$1$1 = this;
    return this._iter.__iterate(function(v, k) {
      return fn(v, k, this$1$1);
    }, reverse3);
  };
  ToKeyedSequence2.prototype.__iterator = function __iterator(type, reverse3) {
    return this._iter.__iterator(type, reverse3);
  };
  return ToKeyedSequence2;
}(KeyedSeq);
ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;
var ToIndexedSequence = /* @__PURE__ */ function(IndexedSeq2) {
  function ToIndexedSequence2(iter) {
    this._iter = iter;
    this.size = iter.size;
  }
  if (IndexedSeq2)
    ToIndexedSequence2.__proto__ = IndexedSeq2;
  ToIndexedSequence2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  ToIndexedSequence2.prototype.constructor = ToIndexedSequence2;
  ToIndexedSequence2.prototype.includes = function includes3(value) {
    return this._iter.includes(value);
  };
  ToIndexedSequence2.prototype.__iterate = function __iterate(fn, reverse3) {
    var this$1$1 = this;
    var i = 0;
    reverse3 && ensureSize(this);
    return this._iter.__iterate(function(v) {
      return fn(v, reverse3 ? this$1$1.size - ++i : i++, this$1$1);
    }, reverse3);
  };
  ToIndexedSequence2.prototype.__iterator = function __iterator(type, reverse3) {
    var this$1$1 = this;
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
    var i = 0;
    reverse3 && ensureSize(this);
    return new Iterator(function() {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, reverse3 ? this$1$1.size - ++i : i++, step.value, step);
    });
  };
  return ToIndexedSequence2;
}(IndexedSeq);
var ToSetSequence = /* @__PURE__ */ function(SetSeq2) {
  function ToSetSequence2(iter) {
    this._iter = iter;
    this.size = iter.size;
  }
  if (SetSeq2)
    ToSetSequence2.__proto__ = SetSeq2;
  ToSetSequence2.prototype = Object.create(SetSeq2 && SetSeq2.prototype);
  ToSetSequence2.prototype.constructor = ToSetSequence2;
  ToSetSequence2.prototype.has = function has4(key) {
    return this._iter.includes(key);
  };
  ToSetSequence2.prototype.__iterate = function __iterate(fn, reverse3) {
    var this$1$1 = this;
    return this._iter.__iterate(function(v) {
      return fn(v, v, this$1$1);
    }, reverse3);
  };
  ToSetSequence2.prototype.__iterator = function __iterator(type, reverse3) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, step.value, step.value, step);
    });
  };
  return ToSetSequence2;
}(SetSeq);
var FromEntriesSequence = /* @__PURE__ */ function(KeyedSeq2) {
  function FromEntriesSequence2(entries2) {
    this._iter = entries2;
    this.size = entries2.size;
  }
  if (KeyedSeq2)
    FromEntriesSequence2.__proto__ = KeyedSeq2;
  FromEntriesSequence2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
  FromEntriesSequence2.prototype.constructor = FromEntriesSequence2;
  FromEntriesSequence2.prototype.entrySeq = function entrySeq2() {
    return this._iter.toSeq();
  };
  FromEntriesSequence2.prototype.__iterate = function __iterate(fn, reverse3) {
    var this$1$1 = this;
    return this._iter.__iterate(function(entry) {
      if (entry) {
        validateEntry(entry);
        var indexedCollection = isCollection(entry);
        return fn(indexedCollection ? entry.get(1) : entry[1], indexedCollection ? entry.get(0) : entry[0], this$1$1);
      }
    }, reverse3);
  };
  FromEntriesSequence2.prototype.__iterator = function __iterator(type, reverse3) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
    return new Iterator(function() {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        if (entry) {
          validateEntry(entry);
          var indexedCollection = isCollection(entry);
          return iteratorValue(type, indexedCollection ? entry.get(0) : entry[0], indexedCollection ? entry.get(1) : entry[1], step);
        }
      }
    });
  };
  return FromEntriesSequence2;
}(KeyedSeq);
ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
function flipFactory(collection) {
  var flipSequence = makeSequence(collection);
  flipSequence._iter = collection;
  flipSequence.size = collection.size;
  flipSequence.flip = function() {
    return collection;
  };
  flipSequence.reverse = function() {
    var reversedSequence = collection.reverse.apply(this);
    reversedSequence.flip = function() {
      return collection.reverse();
    };
    return reversedSequence;
  };
  flipSequence.has = function(key) {
    return collection.includes(key);
  };
  flipSequence.includes = function(key) {
    return collection.has(key);
  };
  flipSequence.cacheResult = cacheResultThrough;
  flipSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    return collection.__iterate(function(v, k) {
      return fn(k, v, this$1$1) !== false;
    }, reverse3);
  };
  flipSequence.__iteratorUncached = function(type, reverse3) {
    if (type === ITERATE_ENTRIES) {
      var iterator = collection.__iterator(type, reverse3);
      return new Iterator(function() {
        var step = iterator.next();
        if (!step.done) {
          var k = step.value[0];
          step.value[0] = step.value[1];
          step.value[1] = k;
        }
        return step;
      });
    }
    return collection.__iterator(type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES, reverse3);
  };
  return flipSequence;
}
function mapFactory(collection, mapper, context) {
  var mappedSequence = makeSequence(collection);
  mappedSequence.size = collection.size;
  mappedSequence.has = function(key) {
    return collection.has(key);
  };
  mappedSequence.get = function(key, notSetValue) {
    var v = collection.get(key, NOT_SET);
    return v === NOT_SET ? notSetValue : mapper.call(context, v, key, collection);
  };
  mappedSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    return collection.__iterate(function(v, k, c) {
      return fn(mapper.call(context, v, k, c), k, this$1$1) !== false;
    }, reverse3);
  };
  mappedSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var key = entry[0];
      return iteratorValue(type, key, mapper.call(context, entry[1], key, collection), step);
    });
  };
  return mappedSequence;
}
function reverseFactory(collection, useKeys) {
  var this$1$1 = this;
  var reversedSequence = makeSequence(collection);
  reversedSequence._iter = collection;
  reversedSequence.size = collection.size;
  reversedSequence.reverse = function() {
    return collection;
  };
  if (collection.flip) {
    reversedSequence.flip = function() {
      var flipSequence = flipFactory(collection);
      flipSequence.reverse = function() {
        return collection.flip();
      };
      return flipSequence;
    };
  }
  reversedSequence.get = function(key, notSetValue) {
    return collection.get(useKeys ? key : -1 - key, notSetValue);
  };
  reversedSequence.has = function(key) {
    return collection.has(useKeys ? key : -1 - key);
  };
  reversedSequence.includes = function(value) {
    return collection.includes(value);
  };
  reversedSequence.cacheResult = cacheResultThrough;
  reversedSequence.__iterate = function(fn, reverse3) {
    var this$1$12 = this;
    var i = 0;
    reverse3 && ensureSize(collection);
    return collection.__iterate(function(v, k) {
      return fn(v, useKeys ? k : reverse3 ? this$1$12.size - ++i : i++, this$1$12);
    }, !reverse3);
  };
  reversedSequence.__iterator = function(type, reverse3) {
    var i = 0;
    reverse3 && ensureSize(collection);
    var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      return iteratorValue(type, useKeys ? entry[0] : reverse3 ? this$1$1.size - ++i : i++, entry[1], step);
    });
  };
  return reversedSequence;
}
function filterFactory(collection, predicate, context, useKeys) {
  var filterSequence = makeSequence(collection);
  if (useKeys) {
    filterSequence.has = function(key) {
      var v = collection.get(key, NOT_SET);
      return v !== NOT_SET && !!predicate.call(context, v, key, collection);
    };
    filterSequence.get = function(key, notSetValue) {
      var v = collection.get(key, NOT_SET);
      return v !== NOT_SET && predicate.call(context, v, key, collection) ? v : notSetValue;
    };
  }
  filterSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    collection.__iterate(function(v, k, c) {
      if (predicate.call(context, v, k, c)) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1$1);
      }
    }, reverse3);
    return iterations;
  };
  filterSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var iterations = 0;
    return new Iterator(function() {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        var value = entry[1];
        if (predicate.call(context, value, key, collection)) {
          return iteratorValue(type, useKeys ? key : iterations++, value, step);
        }
      }
    });
  };
  return filterSequence;
}
function countByFactory(collection, grouper, context) {
  var groups = Map$1().asMutable();
  collection.__iterate(function(v, k) {
    groups.update(grouper.call(context, v, k, collection), 0, function(a) {
      return a + 1;
    });
  });
  return groups.asImmutable();
}
function groupByFactory(collection, grouper, context) {
  var isKeyedIter = isKeyed(collection);
  var groups = (isOrdered(collection) ? OrderedMap() : Map$1()).asMutable();
  collection.__iterate(function(v, k) {
    groups.update(grouper.call(context, v, k, collection), function(a) {
      return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;
    });
  });
  var coerce = collectionClass(collection);
  return groups.map(function(arr) {
    return reify(collection, coerce(arr));
  }).asImmutable();
}
function sliceFactory(collection, begin, end, useKeys) {
  var originalSize = collection.size;
  if (wholeSlice(begin, end, originalSize)) {
    return collection;
  }
  var resolvedBegin = resolveBegin(begin, originalSize);
  var resolvedEnd = resolveEnd(end, originalSize);
  if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
    return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
  }
  var resolvedSize = resolvedEnd - resolvedBegin;
  var sliceSize;
  if (resolvedSize === resolvedSize) {
    sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
  }
  var sliceSeq = makeSequence(collection);
  sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || void 0;
  if (!useKeys && isSeq(collection) && sliceSize >= 0) {
    sliceSeq.get = function(index, notSetValue) {
      index = wrapIndex(this, index);
      return index >= 0 && index < sliceSize ? collection.get(index + resolvedBegin, notSetValue) : notSetValue;
    };
  }
  sliceSeq.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (sliceSize === 0) {
      return 0;
    }
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var skipped = 0;
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function(v, k) {
      if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1$1) !== false && iterations !== sliceSize;
      }
    });
    return iterations;
  };
  sliceSeq.__iteratorUncached = function(type, reverse3) {
    if (sliceSize !== 0 && reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    if (sliceSize === 0) {
      return new Iterator(iteratorDone);
    }
    var iterator = collection.__iterator(type, reverse3);
    var skipped = 0;
    var iterations = 0;
    return new Iterator(function() {
      while (skipped++ < resolvedBegin) {
        iterator.next();
      }
      if (++iterations > sliceSize) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (useKeys || type === ITERATE_VALUES || step.done) {
        return step;
      }
      if (type === ITERATE_KEYS) {
        return iteratorValue(type, iterations - 1, void 0, step);
      }
      return iteratorValue(type, iterations - 1, step.value[1], step);
    });
  };
  return sliceSeq;
}
function takeWhileFactory(collection, predicate, context) {
  var takeSequence = makeSequence(collection);
  takeSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var iterations = 0;
    collection.__iterate(function(v, k, c) {
      return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1$1);
    });
    return iterations;
  };
  takeSequence.__iteratorUncached = function(type, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var iterating = true;
    return new Iterator(function() {
      if (!iterating) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var k = entry[0];
      var v = entry[1];
      if (!predicate.call(context, v, k, this$1$1)) {
        iterating = false;
        return iteratorDone();
      }
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
    });
  };
  return takeSequence;
}
function skipWhileFactory(collection, predicate, context, useKeys) {
  var skipSequence = makeSequence(collection);
  skipSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function(v, k, c) {
      if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1$1);
      }
    });
    return iterations;
  };
  skipSequence.__iteratorUncached = function(type, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var skipping = true;
    var iterations = 0;
    return new Iterator(function() {
      var step;
      var k;
      var v;
      do {
        step = iterator.next();
        if (step.done) {
          if (useKeys || type === ITERATE_VALUES) {
            return step;
          }
          if (type === ITERATE_KEYS) {
            return iteratorValue(type, iterations++, void 0, step);
          }
          return iteratorValue(type, iterations++, step.value[1], step);
        }
        var entry = step.value;
        k = entry[0];
        v = entry[1];
        skipping && (skipping = predicate.call(context, v, k, this$1$1));
      } while (skipping);
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
    });
  };
  return skipSequence;
}
function concatFactory(collection, values2) {
  var isKeyedCollection = isKeyed(collection);
  var iters = [collection].concat(values2).map(function(v) {
    if (!isCollection(v)) {
      v = isKeyedCollection ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
    } else if (isKeyedCollection) {
      v = KeyedCollection(v);
    }
    return v;
  }).filter(function(v) {
    return v.size !== 0;
  });
  if (iters.length === 0) {
    return collection;
  }
  if (iters.length === 1) {
    var singleton = iters[0];
    if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) {
      return singleton;
    }
  }
  var concatSeq = new ArraySeq(iters);
  if (isKeyedCollection) {
    concatSeq = concatSeq.toKeyedSeq();
  } else if (!isIndexed(collection)) {
    concatSeq = concatSeq.toSetSeq();
  }
  concatSeq = concatSeq.flatten(true);
  concatSeq.size = iters.reduce(function(sum, seq) {
    if (sum !== void 0) {
      var size = seq.size;
      if (size !== void 0) {
        return sum + size;
      }
    }
  }, 0);
  return concatSeq;
}
function flattenFactory(collection, depth, useKeys) {
  var flatSequence = makeSequence(collection);
  flatSequence.__iterateUncached = function(fn, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var iterations = 0;
    var stopped = false;
    function flatDeep(iter, currentDepth) {
      iter.__iterate(function(v, k) {
        if ((!depth || currentDepth < depth) && isCollection(v)) {
          flatDeep(v, currentDepth + 1);
        } else {
          iterations++;
          if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {
            stopped = true;
          }
        }
        return !stopped;
      }, reverse3);
    }
    flatDeep(collection, 0);
    return iterations;
  };
  flatSequence.__iteratorUncached = function(type, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(type, reverse3);
    var stack = [];
    var iterations = 0;
    return new Iterator(function() {
      while (iterator) {
        var step = iterator.next();
        if (step.done !== false) {
          iterator = stack.pop();
          continue;
        }
        var v = step.value;
        if (type === ITERATE_ENTRIES) {
          v = v[1];
        }
        if ((!depth || stack.length < depth) && isCollection(v)) {
          stack.push(iterator);
          iterator = v.__iterator(type, reverse3);
        } else {
          return useKeys ? step : iteratorValue(type, iterations++, v, step);
        }
      }
      return iteratorDone();
    });
  };
  return flatSequence;
}
function flatMapFactory(collection, mapper, context) {
  var coerce = collectionClass(collection);
  return collection.toSeq().map(function(v, k) {
    return coerce(mapper.call(context, v, k, collection));
  }).flatten(true);
}
function interposeFactory(collection, separator) {
  var interposedSequence = makeSequence(collection);
  interposedSequence.size = collection.size && collection.size * 2 - 1;
  interposedSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    collection.__iterate(function(v) {
      return (!iterations || fn(separator, iterations++, this$1$1) !== false) && fn(v, iterations++, this$1$1) !== false;
    }, reverse3);
    return iterations;
  };
  interposedSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_VALUES, reverse3);
    var iterations = 0;
    var step;
    return new Iterator(function() {
      if (!step || iterations % 2) {
        step = iterator.next();
        if (step.done) {
          return step;
        }
      }
      return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
    });
  };
  return interposedSequence;
}
function sortFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  var isKeyedCollection = isKeyed(collection);
  var index = 0;
  var entries2 = collection.toSeq().map(function(v, k) {
    return [k, v, index++, mapper ? mapper(v, k, collection) : v];
  }).valueSeq().toArray();
  entries2.sort(function(a, b) {
    return comparator(a[3], b[3]) || a[2] - b[2];
  }).forEach(isKeyedCollection ? function(v, i) {
    entries2[i].length = 2;
  } : function(v, i) {
    entries2[i] = v[1];
  });
  return isKeyedCollection ? KeyedSeq(entries2) : isIndexed(collection) ? IndexedSeq(entries2) : SetSeq(entries2);
}
function maxFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  if (mapper) {
    var entry = collection.toSeq().map(function(v, k) {
      return [v, mapper(v, k, collection)];
    }).reduce(function(a, b) {
      return maxCompare(comparator, a[1], b[1]) ? b : a;
    });
    return entry && entry[0];
  }
  return collection.reduce(function(a, b) {
    return maxCompare(comparator, a, b) ? b : a;
  });
}
function maxCompare(comparator, a, b) {
  var comp = comparator(b, a);
  return comp === 0 && b !== a && (b === void 0 || b === null || b !== b) || comp > 0;
}
function zipWithFactory(keyIter, zipper, iters, zipAll2) {
  var zipSequence = makeSequence(keyIter);
  var sizes = new ArraySeq(iters).map(function(i) {
    return i.size;
  });
  zipSequence.size = zipAll2 ? sizes.max() : sizes.min();
  zipSequence.__iterate = function(fn, reverse3) {
    var iterator = this.__iterator(ITERATE_VALUES, reverse3);
    var step;
    var iterations = 0;
    while (!(step = iterator.next()).done) {
      if (fn(step.value, iterations++, this) === false) {
        break;
      }
    }
    return iterations;
  };
  zipSequence.__iteratorUncached = function(type, reverse3) {
    var iterators = iters.map(function(i) {
      return i = Collection(i), getIterator(reverse3 ? i.reverse() : i);
    });
    var iterations = 0;
    var isDone = false;
    return new Iterator(function() {
      var steps;
      if (!isDone) {
        steps = iterators.map(function(i) {
          return i.next();
        });
        isDone = zipAll2 ? steps.every(function(s) {
          return s.done;
        }) : steps.some(function(s) {
          return s.done;
        });
      }
      if (isDone) {
        return iteratorDone();
      }
      return iteratorValue(type, iterations++, zipper.apply(null, steps.map(function(s) {
        return s.value;
      })));
    });
  };
  return zipSequence;
}
function reify(iter, seq) {
  return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
}
function validateEntry(entry) {
  if (entry !== Object(entry)) {
    throw new TypeError("Expected [K, V] tuple: " + entry);
  }
}
function collectionClass(collection) {
  return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;
}
function makeSequence(collection) {
  return Object.create((isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype);
}
function cacheResultThrough() {
  if (this._iter.cacheResult) {
    this._iter.cacheResult();
    this.size = this._iter.size;
    return this;
  }
  return Seq.prototype.cacheResult.call(this);
}
function defaultComparator(a, b) {
  if (a === void 0 && b === void 0) {
    return 0;
  }
  if (a === void 0) {
    return 1;
  }
  if (b === void 0) {
    return -1;
  }
  return a > b ? 1 : a < b ? -1 : 0;
}
function arrCopy(arr, offset) {
  offset = offset || 0;
  var len = Math.max(0, arr.length - offset);
  var newArr = new Array(len);
  for (var ii = 0; ii < len; ii++) {
    newArr[ii] = arr[ii + offset];
  }
  return newArr;
}
function invariant(condition, error) {
  if (!condition) {
    throw new Error(error);
  }
}
function assertNotInfinite(size) {
  invariant(size !== Infinity, "Cannot perform this action with an infinite size.");
}
function coerceKeyPath(keyPath) {
  if (isArrayLike(keyPath) && typeof keyPath !== "string") {
    return keyPath;
  }
  if (isOrdered(keyPath)) {
    return keyPath.toArray();
  }
  throw new TypeError("Invalid keyPath: expected Ordered Collection or Array: " + keyPath);
}
var toString2 = Object.prototype.toString;
function isPlainObject(value) {
  if (!value || typeof value !== "object" || toString2.call(value) !== "[object Object]") {
    return false;
  }
  var proto = Object.getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  var parentProto = proto;
  var nextProto = Object.getPrototypeOf(proto);
  while (nextProto !== null) {
    parentProto = nextProto;
    nextProto = Object.getPrototypeOf(parentProto);
  }
  return parentProto === proto;
}
function isDataStructure(value) {
  return typeof value === "object" && (isImmutable(value) || Array.isArray(value) || isPlainObject(value));
}
function quoteString(value) {
  try {
    return typeof value === "string" ? JSON.stringify(value) : String(value);
  } catch (_ignoreError) {
    return JSON.stringify(value);
  }
}
function has$4(collection, key) {
  return isImmutable(collection) ? collection.has(key) : isDataStructure(collection) && hasOwnProperty.call(collection, key);
}
function get2(collection, key, notSetValue) {
  return isImmutable(collection) ? collection.get(key, notSetValue) : !has$4(collection, key) ? notSetValue : typeof collection.get === "function" ? collection.get(key) : collection[key];
}
function shallowCopy(from) {
  if (Array.isArray(from)) {
    return arrCopy(from);
  }
  var to = {};
  for (var key in from) {
    if (hasOwnProperty.call(from, key)) {
      to[key] = from[key];
    }
  }
  return to;
}
function remove2(collection, key) {
  if (!isDataStructure(collection)) {
    throw new TypeError("Cannot update non-data-structure value: " + collection);
  }
  if (isImmutable(collection)) {
    if (!collection.remove) {
      throw new TypeError("Cannot update immutable value without .remove() method: " + collection);
    }
    return collection.remove(key);
  }
  if (!hasOwnProperty.call(collection, key)) {
    return collection;
  }
  var collectionCopy = shallowCopy(collection);
  if (Array.isArray(collectionCopy)) {
    collectionCopy.splice(key, 1);
  } else {
    delete collectionCopy[key];
  }
  return collectionCopy;
}
function set(collection, key, value) {
  if (!isDataStructure(collection)) {
    throw new TypeError("Cannot update non-data-structure value: " + collection);
  }
  if (isImmutable(collection)) {
    if (!collection.set) {
      throw new TypeError("Cannot update immutable value without .set() method: " + collection);
    }
    return collection.set(key, value);
  }
  if (hasOwnProperty.call(collection, key) && value === collection[key]) {
    return collection;
  }
  var collectionCopy = shallowCopy(collection);
  collectionCopy[key] = value;
  return collectionCopy;
}
function updateIn$1(collection, keyPath, notSetValue, updater) {
  if (!updater) {
    updater = notSetValue;
    notSetValue = void 0;
  }
  var updatedValue = updateInDeeply(isImmutable(collection), collection, coerceKeyPath(keyPath), 0, notSetValue, updater);
  return updatedValue === NOT_SET ? notSetValue : updatedValue;
}
function updateInDeeply(inImmutable, existing, keyPath, i, notSetValue, updater) {
  var wasNotSet = existing === NOT_SET;
  if (i === keyPath.length) {
    var existingValue = wasNotSet ? notSetValue : existing;
    var newValue = updater(existingValue);
    return newValue === existingValue ? existing : newValue;
  }
  if (!wasNotSet && !isDataStructure(existing)) {
    throw new TypeError("Cannot update within non-data-structure value in path [" + keyPath.slice(0, i).map(quoteString) + "]: " + existing);
  }
  var key = keyPath[i];
  var nextExisting = wasNotSet ? NOT_SET : get2(existing, key, NOT_SET);
  var nextUpdated = updateInDeeply(nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting), nextExisting, keyPath, i + 1, notSetValue, updater);
  return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? remove2(existing, key) : set(wasNotSet ? inImmutable ? emptyMap() : {} : existing, key, nextUpdated);
}
function setIn$1(collection, keyPath, value) {
  return updateIn$1(collection, keyPath, NOT_SET, function() {
    return value;
  });
}
function setIn(keyPath, v) {
  return setIn$1(this, keyPath, v);
}
function removeIn(collection, keyPath) {
  return updateIn$1(collection, keyPath, function() {
    return NOT_SET;
  });
}
function deleteIn(keyPath) {
  return removeIn(this, keyPath);
}
function update$1(collection, key, notSetValue, updater) {
  return updateIn$1(collection, [key], notSetValue, updater);
}
function update(key, notSetValue, updater) {
  return arguments.length === 1 ? key(this) : update$1(this, key, notSetValue, updater);
}
function updateIn(keyPath, notSetValue, updater) {
  return updateIn$1(this, keyPath, notSetValue, updater);
}
function merge$1() {
  var iters = [], len = arguments.length;
  while (len--)
    iters[len] = arguments[len];
  return mergeIntoKeyedWith(this, iters);
}
function mergeWith$1(merger) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0)
    iters[len] = arguments[len + 1];
  if (typeof merger !== "function") {
    throw new TypeError("Invalid merger function: " + merger);
  }
  return mergeIntoKeyedWith(this, iters, merger);
}
function mergeIntoKeyedWith(collection, collections, merger) {
  var iters = [];
  for (var ii = 0; ii < collections.length; ii++) {
    var collection$1 = KeyedCollection(collections[ii]);
    if (collection$1.size !== 0) {
      iters.push(collection$1);
    }
  }
  if (iters.length === 0) {
    return collection;
  }
  if (collection.toSeq().size === 0 && !collection.__ownerID && iters.length === 1) {
    return collection.constructor(iters[0]);
  }
  return collection.withMutations(function(collection2) {
    var mergeIntoCollection = merger ? function(value, key) {
      update$1(collection2, key, NOT_SET, function(oldVal) {
        return oldVal === NOT_SET ? value : merger(oldVal, value, key);
      });
    } : function(value, key) {
      collection2.set(key, value);
    };
    for (var ii2 = 0; ii2 < iters.length; ii2++) {
      iters[ii2].forEach(mergeIntoCollection);
    }
  });
}
function mergeDeepWithSources(collection, sources, merger) {
  return mergeWithSources(collection, sources, deepMergerWith(merger));
}
function mergeWithSources(collection, sources, merger) {
  if (!isDataStructure(collection)) {
    throw new TypeError("Cannot merge into non-data-structure value: " + collection);
  }
  if (isImmutable(collection)) {
    return typeof merger === "function" && collection.mergeWith ? collection.mergeWith.apply(collection, [merger].concat(sources)) : collection.merge ? collection.merge.apply(collection, sources) : collection.concat.apply(collection, sources);
  }
  var isArray2 = Array.isArray(collection);
  var merged = collection;
  var Collection3 = isArray2 ? IndexedCollection : KeyedCollection;
  var mergeItem = isArray2 ? function(value) {
    if (merged === collection) {
      merged = shallowCopy(merged);
    }
    merged.push(value);
  } : function(value, key) {
    var hasVal = hasOwnProperty.call(merged, key);
    var nextVal = hasVal && merger ? merger(merged[key], value, key) : value;
    if (!hasVal || nextVal !== merged[key]) {
      if (merged === collection) {
        merged = shallowCopy(merged);
      }
      merged[key] = nextVal;
    }
  };
  for (var i = 0; i < sources.length; i++) {
    Collection3(sources[i]).forEach(mergeItem);
  }
  return merged;
}
function deepMergerWith(merger) {
  function deepMerger(oldValue, newValue, key) {
    return isDataStructure(oldValue) && isDataStructure(newValue) && areMergeable(oldValue, newValue) ? mergeWithSources(oldValue, [newValue], deepMerger) : merger ? merger(oldValue, newValue, key) : newValue;
  }
  return deepMerger;
}
function areMergeable(oldDataStructure, newDataStructure) {
  var oldSeq = Seq(oldDataStructure);
  var newSeq = Seq(newDataStructure);
  return isIndexed(oldSeq) === isIndexed(newSeq) && isKeyed(oldSeq) === isKeyed(newSeq);
}
function mergeDeep() {
  var iters = [], len = arguments.length;
  while (len--)
    iters[len] = arguments[len];
  return mergeDeepWithSources(this, iters);
}
function mergeDeepWith(merger) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0)
    iters[len] = arguments[len + 1];
  return mergeDeepWithSources(this, iters, merger);
}
function mergeIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0)
    iters[len] = arguments[len + 1];
  return updateIn$1(this, keyPath, emptyMap(), function(m2) {
    return mergeWithSources(m2, iters);
  });
}
function mergeDeepIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0)
    iters[len] = arguments[len + 1];
  return updateIn$1(this, keyPath, emptyMap(), function(m2) {
    return mergeDeepWithSources(m2, iters);
  });
}
function withMutations(fn) {
  var mutable = this.asMutable();
  fn(mutable);
  return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
}
function asMutable() {
  return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
}
function asImmutable() {
  return this.__ensureOwner();
}
function wasAltered() {
  return this.__altered;
}
var Map$1 = /* @__PURE__ */ function(KeyedCollection2) {
  function Map2(value) {
    return value === null || value === void 0 ? emptyMap() : isMap$1(value) && !isOrdered(value) ? value : emptyMap().withMutations(function(map2) {
      var iter = KeyedCollection2(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v, k) {
        return map2.set(k, v);
      });
    });
  }
  if (KeyedCollection2)
    Map2.__proto__ = KeyedCollection2;
  Map2.prototype = Object.create(KeyedCollection2 && KeyedCollection2.prototype);
  Map2.prototype.constructor = Map2;
  Map2.of = function of() {
    var keyValues = [], len = arguments.length;
    while (len--)
      keyValues[len] = arguments[len];
    return emptyMap().withMutations(function(map2) {
      for (var i = 0; i < keyValues.length; i += 2) {
        if (i + 1 >= keyValues.length) {
          throw new Error("Missing value for key: " + keyValues[i]);
        }
        map2.set(keyValues[i], keyValues[i + 1]);
      }
    });
  };
  Map2.prototype.toString = function toString4() {
    return this.__toString("Map {", "}");
  };
  Map2.prototype.get = function get11(k, notSetValue) {
    return this._root ? this._root.get(0, void 0, k, notSetValue) : notSetValue;
  };
  Map2.prototype.set = function set3(k, v) {
    return updateMap(this, k, v);
  };
  Map2.prototype.remove = function remove3(k) {
    return updateMap(this, k, NOT_SET);
  };
  Map2.prototype.deleteAll = function deleteAll(keys3) {
    var collection = Collection(keys3);
    if (collection.size === 0) {
      return this;
    }
    return this.withMutations(function(map2) {
      collection.forEach(function(key) {
        return map2.remove(key);
      });
    });
  };
  Map2.prototype.clear = function clear() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._root = null;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return emptyMap();
  };
  Map2.prototype.sort = function sort2(comparator) {
    return OrderedMap(sortFactory(this, comparator));
  };
  Map2.prototype.sortBy = function sortBy2(mapper, comparator) {
    return OrderedMap(sortFactory(this, comparator, mapper));
  };
  Map2.prototype.map = function map2(mapper, context) {
    var this$1$1 = this;
    return this.withMutations(function(map3) {
      map3.forEach(function(value, key) {
        map3.set(key, mapper.call(context, value, key, this$1$1));
      });
    });
  };
  Map2.prototype.__iterator = function __iterator(type, reverse3) {
    return new MapIterator(this, type, reverse3);
  };
  Map2.prototype.__iterate = function __iterate(fn, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    this._root && this._root.iterate(function(entry) {
      iterations++;
      return fn(entry[1], entry[0], this$1$1);
    }, reverse3);
    return iterations;
  };
  Map2.prototype.__ensureOwner = function __ensureOwner(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyMap();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeMap(this.size, this._root, ownerID, this.__hash);
  };
  return Map2;
}(KeyedCollection);
Map$1.isMap = isMap$1;
var MapPrototype = Map$1.prototype;
MapPrototype[IS_MAP_SYMBOL] = true;
MapPrototype[DELETE] = MapPrototype.remove;
MapPrototype.removeAll = MapPrototype.deleteAll;
MapPrototype.setIn = setIn;
MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
MapPrototype.update = update;
MapPrototype.updateIn = updateIn;
MapPrototype.merge = MapPrototype.concat = merge$1;
MapPrototype.mergeWith = mergeWith$1;
MapPrototype.mergeDeep = mergeDeep;
MapPrototype.mergeDeepWith = mergeDeepWith;
MapPrototype.mergeIn = mergeIn;
MapPrototype.mergeDeepIn = mergeDeepIn;
MapPrototype.withMutations = withMutations;
MapPrototype.wasAltered = wasAltered;
MapPrototype.asImmutable = asImmutable;
MapPrototype["@@transducer/init"] = MapPrototype.asMutable = asMutable;
MapPrototype["@@transducer/step"] = function(result, arr) {
  return result.set(arr[0], arr[1]);
};
MapPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
var ArrayMapNode = function ArrayMapNode2(ownerID, entries2) {
  this.ownerID = ownerID;
  this.entries = entries2;
};
ArrayMapNode.prototype.get = function get3(shift, keyHash, key, notSetValue) {
  var entries2 = this.entries;
  for (var ii = 0, len = entries2.length; ii < len; ii++) {
    if (is(key, entries2[ii][0])) {
      return entries2[ii][1];
    }
  }
  return notSetValue;
};
ArrayMapNode.prototype.update = function update2(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  var removed = value === NOT_SET;
  var entries2 = this.entries;
  var idx = 0;
  var len = entries2.length;
  for (; idx < len; idx++) {
    if (is(key, entries2[idx][0])) {
      break;
    }
  }
  var exists = idx < len;
  if (exists ? entries2[idx][1] === value : removed) {
    return this;
  }
  SetRef(didAlter);
  (removed || !exists) && SetRef(didChangeSize);
  if (removed && entries2.length === 1) {
    return;
  }
  if (!exists && !removed && entries2.length >= MAX_ARRAY_MAP_SIZE) {
    return createNodes(ownerID, entries2, key, value);
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newEntries = isEditable ? entries2 : arrCopy(entries2);
  if (exists) {
    if (removed) {
      idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
    } else {
      newEntries[idx] = [key, value];
    }
  } else {
    newEntries.push([key, value]);
  }
  if (isEditable) {
    this.entries = newEntries;
    return this;
  }
  return new ArrayMapNode(ownerID, newEntries);
};
var BitmapIndexedNode = function BitmapIndexedNode2(ownerID, bitmap, nodes) {
  this.ownerID = ownerID;
  this.bitmap = bitmap;
  this.nodes = nodes;
};
BitmapIndexedNode.prototype.get = function get4(shift, keyHash, key, notSetValue) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
  var bitmap = this.bitmap;
  return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key, notSetValue);
};
BitmapIndexedNode.prototype.update = function update3(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var bit = 1 << keyHashFrag;
  var bitmap = this.bitmap;
  var exists = (bitmap & bit) !== 0;
  if (!exists && value === NOT_SET) {
    return this;
  }
  var idx = popCount(bitmap & bit - 1);
  var nodes = this.nodes;
  var node = exists ? nodes[idx] : void 0;
  var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
  if (newNode === node) {
    return this;
  }
  if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
    return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
  }
  if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
    return nodes[idx ^ 1];
  }
  if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
    return newNode;
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
  var newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
  if (isEditable) {
    this.bitmap = newBitmap;
    this.nodes = newNodes;
    return this;
  }
  return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
};
var HashArrayMapNode = function HashArrayMapNode2(ownerID, count2, nodes) {
  this.ownerID = ownerID;
  this.count = count2;
  this.nodes = nodes;
};
HashArrayMapNode.prototype.get = function get5(shift, keyHash, key, notSetValue) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var node = this.nodes[idx];
  return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
};
HashArrayMapNode.prototype.update = function update4(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var removed = value === NOT_SET;
  var nodes = this.nodes;
  var node = nodes[idx];
  if (removed && !node) {
    return this;
  }
  var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
  if (newNode === node) {
    return this;
  }
  var newCount = this.count;
  if (!node) {
    newCount++;
  } else if (!newNode) {
    newCount--;
    if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
      return packNodes(ownerID, nodes, newCount, idx);
    }
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newNodes = setAt(nodes, idx, newNode, isEditable);
  if (isEditable) {
    this.count = newCount;
    this.nodes = newNodes;
    return this;
  }
  return new HashArrayMapNode(ownerID, newCount, newNodes);
};
var HashCollisionNode = function HashCollisionNode2(ownerID, keyHash, entries2) {
  this.ownerID = ownerID;
  this.keyHash = keyHash;
  this.entries = entries2;
};
HashCollisionNode.prototype.get = function get6(shift, keyHash, key, notSetValue) {
  var entries2 = this.entries;
  for (var ii = 0, len = entries2.length; ii < len; ii++) {
    if (is(key, entries2[ii][0])) {
      return entries2[ii][1];
    }
  }
  return notSetValue;
};
HashCollisionNode.prototype.update = function update5(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var removed = value === NOT_SET;
  if (keyHash !== this.keyHash) {
    if (removed) {
      return this;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
  }
  var entries2 = this.entries;
  var idx = 0;
  var len = entries2.length;
  for (; idx < len; idx++) {
    if (is(key, entries2[idx][0])) {
      break;
    }
  }
  var exists = idx < len;
  if (exists ? entries2[idx][1] === value : removed) {
    return this;
  }
  SetRef(didAlter);
  (removed || !exists) && SetRef(didChangeSize);
  if (removed && len === 2) {
    return new ValueNode(ownerID, this.keyHash, entries2[idx ^ 1]);
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newEntries = isEditable ? entries2 : arrCopy(entries2);
  if (exists) {
    if (removed) {
      idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
    } else {
      newEntries[idx] = [key, value];
    }
  } else {
    newEntries.push([key, value]);
  }
  if (isEditable) {
    this.entries = newEntries;
    return this;
  }
  return new HashCollisionNode(ownerID, this.keyHash, newEntries);
};
var ValueNode = function ValueNode2(ownerID, keyHash, entry) {
  this.ownerID = ownerID;
  this.keyHash = keyHash;
  this.entry = entry;
};
ValueNode.prototype.get = function get7(shift, keyHash, key, notSetValue) {
  return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
};
ValueNode.prototype.update = function update6(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  var removed = value === NOT_SET;
  var keyMatch = is(key, this.entry[0]);
  if (keyMatch ? value === this.entry[1] : removed) {
    return this;
  }
  SetRef(didAlter);
  if (removed) {
    SetRef(didChangeSize);
    return;
  }
  if (keyMatch) {
    if (ownerID && ownerID === this.ownerID) {
      this.entry[1] = value;
      return this;
    }
    return new ValueNode(ownerID, this.keyHash, [key, value]);
  }
  SetRef(didChangeSize);
  return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
};
ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(fn, reverse3) {
  var entries2 = this.entries;
  for (var ii = 0, maxIndex = entries2.length - 1; ii <= maxIndex; ii++) {
    if (fn(entries2[reverse3 ? maxIndex - ii : ii]) === false) {
      return false;
    }
  }
};
BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(fn, reverse3) {
  var nodes = this.nodes;
  for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
    var node = nodes[reverse3 ? maxIndex - ii : ii];
    if (node && node.iterate(fn, reverse3) === false) {
      return false;
    }
  }
};
ValueNode.prototype.iterate = function(fn, reverse3) {
  return fn(this.entry);
};
var MapIterator = /* @__PURE__ */ function(Iterator3) {
  function MapIterator2(map2, type, reverse3) {
    this._type = type;
    this._reverse = reverse3;
    this._stack = map2._root && mapIteratorFrame(map2._root);
  }
  if (Iterator3)
    MapIterator2.__proto__ = Iterator3;
  MapIterator2.prototype = Object.create(Iterator3 && Iterator3.prototype);
  MapIterator2.prototype.constructor = MapIterator2;
  MapIterator2.prototype.next = function next() {
    var type = this._type;
    var stack = this._stack;
    while (stack) {
      var node = stack.node;
      var index = stack.index++;
      var maxIndex = void 0;
      if (node.entry) {
        if (index === 0) {
          return mapIteratorValue(type, node.entry);
        }
      } else if (node.entries) {
        maxIndex = node.entries.length - 1;
        if (index <= maxIndex) {
          return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
        }
      } else {
        maxIndex = node.nodes.length - 1;
        if (index <= maxIndex) {
          var subNode = node.nodes[this._reverse ? maxIndex - index : index];
          if (subNode) {
            if (subNode.entry) {
              return mapIteratorValue(type, subNode.entry);
            }
            stack = this._stack = mapIteratorFrame(subNode, stack);
          }
          continue;
        }
      }
      stack = this._stack = this._stack.__prev;
    }
    return iteratorDone();
  };
  return MapIterator2;
}(Iterator);
function mapIteratorValue(type, entry) {
  return iteratorValue(type, entry[0], entry[1]);
}
function mapIteratorFrame(node, prev) {
  return {
    node,
    index: 0,
    __prev: prev
  };
}
function makeMap(size, root2, ownerID, hash2) {
  var map2 = Object.create(MapPrototype);
  map2.size = size;
  map2._root = root2;
  map2.__ownerID = ownerID;
  map2.__hash = hash2;
  map2.__altered = false;
  return map2;
}
var EMPTY_MAP;
function emptyMap() {
  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}
function updateMap(map2, k, v) {
  var newRoot;
  var newSize;
  if (!map2._root) {
    if (v === NOT_SET) {
      return map2;
    }
    newSize = 1;
    newRoot = new ArrayMapNode(map2.__ownerID, [[k, v]]);
  } else {
    var didChangeSize = MakeRef();
    var didAlter = MakeRef();
    newRoot = updateNode(map2._root, map2.__ownerID, 0, void 0, k, v, didChangeSize, didAlter);
    if (!didAlter.value) {
      return map2;
    }
    newSize = map2.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
  }
  if (map2.__ownerID) {
    map2.size = newSize;
    map2._root = newRoot;
    map2.__hash = void 0;
    map2.__altered = true;
    return map2;
  }
  return newRoot ? makeMap(newSize, newRoot) : emptyMap();
}
function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (!node) {
    if (value === NOT_SET) {
      return node;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return new ValueNode(ownerID, keyHash, [key, value]);
  }
  return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
}
function isLeafNode(node) {
  return node.constructor === ValueNode || node.constructor === HashCollisionNode;
}
function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
  if (node.keyHash === keyHash) {
    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
  }
  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var newNode;
  var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
  return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
}
function createNodes(ownerID, entries2, key, value) {
  if (!ownerID) {
    ownerID = new OwnerID();
  }
  var node = new ValueNode(ownerID, hash(key), [key, value]);
  for (var ii = 0; ii < entries2.length; ii++) {
    var entry = entries2[ii];
    node = node.update(ownerID, 0, void 0, entry[0], entry[1]);
  }
  return node;
}
function packNodes(ownerID, nodes, count2, excluding) {
  var bitmap = 0;
  var packedII = 0;
  var packedNodes = new Array(count2);
  for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
    var node = nodes[ii];
    if (node !== void 0 && ii !== excluding) {
      bitmap |= bit;
      packedNodes[packedII++] = node;
    }
  }
  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}
function expandNodes(ownerID, nodes, bitmap, including, node) {
  var count2 = 0;
  var expandedNodes = new Array(SIZE);
  for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
    expandedNodes[ii] = bitmap & 1 ? nodes[count2++] : void 0;
  }
  expandedNodes[including] = node;
  return new HashArrayMapNode(ownerID, count2 + 1, expandedNodes);
}
function popCount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function setAt(array, idx, val, canEdit) {
  var newArray = canEdit ? array : arrCopy(array);
  newArray[idx] = val;
  return newArray;
}
function spliceIn(array, idx, val, canEdit) {
  var newLen = array.length + 1;
  if (canEdit && idx + 1 === newLen) {
    array[idx] = val;
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      newArray[ii] = val;
      after = -1;
    } else {
      newArray[ii] = array[ii + after];
    }
  }
  return newArray;
}
function spliceOut(array, idx, canEdit) {
  var newLen = array.length - 1;
  if (canEdit && idx === newLen) {
    array.pop();
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      after = 1;
    }
    newArray[ii] = array[ii + after];
  }
  return newArray;
}
var MAX_ARRAY_MAP_SIZE = SIZE / 4;
var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
var IS_LIST_SYMBOL = "@@__IMMUTABLE_LIST__@@";
function isList(maybeList) {
  return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);
}
var List$1 = /* @__PURE__ */ function(IndexedCollection2) {
  function List2(value) {
    var empty = emptyList();
    if (value === null || value === void 0) {
      return empty;
    }
    if (isList(value)) {
      return value;
    }
    var iter = IndexedCollection2(value);
    var size = iter.size;
    if (size === 0) {
      return empty;
    }
    assertNotInfinite(size);
    if (size > 0 && size < SIZE) {
      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
    }
    return empty.withMutations(function(list) {
      list.setSize(size);
      iter.forEach(function(v, i) {
        return list.set(i, v);
      });
    });
  }
  if (IndexedCollection2)
    List2.__proto__ = IndexedCollection2;
  List2.prototype = Object.create(IndexedCollection2 && IndexedCollection2.prototype);
  List2.prototype.constructor = List2;
  List2.of = function of() {
    return this(arguments);
  };
  List2.prototype.toString = function toString4() {
    return this.__toString("List [", "]");
  };
  List2.prototype.get = function get11(index, notSetValue) {
    index = wrapIndex(this, index);
    if (index >= 0 && index < this.size) {
      index += this._origin;
      var node = listNodeFor(this, index);
      return node && node.array[index & MASK];
    }
    return notSetValue;
  };
  List2.prototype.set = function set3(index, value) {
    return updateList(this, index, value);
  };
  List2.prototype.remove = function remove3(index) {
    return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
  };
  List2.prototype.insert = function insert(index, value) {
    return this.splice(index, 0, value);
  };
  List2.prototype.clear = function clear() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = this._origin = this._capacity = 0;
      this._level = SHIFT;
      this._root = this._tail = this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return emptyList();
  };
  List2.prototype.push = function push2() {
    var values2 = arguments;
    var oldSize = this.size;
    return this.withMutations(function(list) {
      setListBounds(list, 0, oldSize + values2.length);
      for (var ii = 0; ii < values2.length; ii++) {
        list.set(oldSize + ii, values2[ii]);
      }
    });
  };
  List2.prototype.pop = function pop() {
    return setListBounds(this, 0, -1);
  };
  List2.prototype.unshift = function unshift() {
    var values2 = arguments;
    return this.withMutations(function(list) {
      setListBounds(list, -values2.length);
      for (var ii = 0; ii < values2.length; ii++) {
        list.set(ii, values2[ii]);
      }
    });
  };
  List2.prototype.shift = function shift() {
    return setListBounds(this, 1);
  };
  List2.prototype.concat = function concat2() {
    var arguments$1 = arguments;
    var seqs = [];
    for (var i = 0; i < arguments.length; i++) {
      var argument = arguments$1[i];
      var seq = IndexedCollection2(typeof argument !== "string" && hasIterator(argument) ? argument : [argument]);
      if (seq.size !== 0) {
        seqs.push(seq);
      }
    }
    if (seqs.length === 0) {
      return this;
    }
    if (this.size === 0 && !this.__ownerID && seqs.length === 1) {
      return this.constructor(seqs[0]);
    }
    return this.withMutations(function(list) {
      seqs.forEach(function(seq2) {
        return seq2.forEach(function(value) {
          return list.push(value);
        });
      });
    });
  };
  List2.prototype.setSize = function setSize2(size) {
    return setListBounds(this, 0, size);
  };
  List2.prototype.map = function map2(mapper, context) {
    var this$1$1 = this;
    return this.withMutations(function(list) {
      for (var i = 0; i < this$1$1.size; i++) {
        list.set(i, mapper.call(context, list.get(i), i, this$1$1));
      }
    });
  };
  List2.prototype.slice = function slice4(begin, end) {
    var size = this.size;
    if (wholeSlice(begin, end, size)) {
      return this;
    }
    return setListBounds(this, resolveBegin(begin, size), resolveEnd(end, size));
  };
  List2.prototype.__iterator = function __iterator(type, reverse3) {
    var index = reverse3 ? this.size : 0;
    var values2 = iterateList(this, reverse3);
    return new Iterator(function() {
      var value = values2();
      return value === DONE ? iteratorDone() : iteratorValue(type, reverse3 ? --index : index++, value);
    });
  };
  List2.prototype.__iterate = function __iterate(fn, reverse3) {
    var index = reverse3 ? this.size : 0;
    var values2 = iterateList(this, reverse3);
    var value;
    while ((value = values2()) !== DONE) {
      if (fn(value, reverse3 ? --index : index++, this) === false) {
        break;
      }
    }
    return index;
  };
  List2.prototype.__ensureOwner = function __ensureOwner(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyList();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
  };
  return List2;
}(IndexedCollection);
List$1.isList = isList;
var ListPrototype = List$1.prototype;
ListPrototype[IS_LIST_SYMBOL] = true;
ListPrototype[DELETE] = ListPrototype.remove;
ListPrototype.merge = ListPrototype.concat;
ListPrototype.setIn = setIn;
ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
ListPrototype.update = update;
ListPrototype.updateIn = updateIn;
ListPrototype.mergeIn = mergeIn;
ListPrototype.mergeDeepIn = mergeDeepIn;
ListPrototype.withMutations = withMutations;
ListPrototype.wasAltered = wasAltered;
ListPrototype.asImmutable = asImmutable;
ListPrototype["@@transducer/init"] = ListPrototype.asMutable = asMutable;
ListPrototype["@@transducer/step"] = function(result, arr) {
  return result.push(arr);
};
ListPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
var VNode = function VNode2(array, ownerID) {
  this.array = array;
  this.ownerID = ownerID;
};
VNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {
  if (index === level ? 1 << level : this.array.length === 0) {
    return this;
  }
  var originIndex = index >>> level & MASK;
  if (originIndex >= this.array.length) {
    return new VNode([], ownerID);
  }
  var removingFirst = originIndex === 0;
  var newChild;
  if (level > 0) {
    var oldChild = this.array[originIndex];
    newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
    if (newChild === oldChild && removingFirst) {
      return this;
    }
  }
  if (removingFirst && !newChild) {
    return this;
  }
  var editable = editableVNode(this, ownerID);
  if (!removingFirst) {
    for (var ii = 0; ii < originIndex; ii++) {
      editable.array[ii] = void 0;
    }
  }
  if (newChild) {
    editable.array[originIndex] = newChild;
  }
  return editable;
};
VNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {
  if (index === (level ? 1 << level : 0) || this.array.length === 0) {
    return this;
  }
  var sizeIndex = index - 1 >>> level & MASK;
  if (sizeIndex >= this.array.length) {
    return this;
  }
  var newChild;
  if (level > 0) {
    var oldChild = this.array[sizeIndex];
    newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
    if (newChild === oldChild && sizeIndex === this.array.length - 1) {
      return this;
    }
  }
  var editable = editableVNode(this, ownerID);
  editable.array.splice(sizeIndex + 1);
  if (newChild) {
    editable.array[sizeIndex] = newChild;
  }
  return editable;
};
var DONE = {};
function iterateList(list, reverse3) {
  var left = list._origin;
  var right = list._capacity;
  var tailPos = getTailOffset(right);
  var tail = list._tail;
  return iterateNodeOrLeaf(list._root, list._level, 0);
  function iterateNodeOrLeaf(node, level, offset) {
    return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
  }
  function iterateLeaf(node, offset) {
    var array = offset === tailPos ? tail && tail.array : node && node.array;
    var from = offset > left ? 0 : left - offset;
    var to = right - offset;
    if (to > SIZE) {
      to = SIZE;
    }
    return function() {
      if (from === to) {
        return DONE;
      }
      var idx = reverse3 ? --to : from++;
      return array && array[idx];
    };
  }
  function iterateNode(node, level, offset) {
    var values2;
    var array = node && node.array;
    var from = offset > left ? 0 : left - offset >> level;
    var to = (right - offset >> level) + 1;
    if (to > SIZE) {
      to = SIZE;
    }
    return function() {
      while (true) {
        if (values2) {
          var value = values2();
          if (value !== DONE) {
            return value;
          }
          values2 = null;
        }
        if (from === to) {
          return DONE;
        }
        var idx = reverse3 ? --to : from++;
        values2 = iterateNodeOrLeaf(array && array[idx], level - SHIFT, offset + (idx << level));
      }
    };
  }
}
function makeList(origin, capacity, level, root2, tail, ownerID, hash2) {
  var list = Object.create(ListPrototype);
  list.size = capacity - origin;
  list._origin = origin;
  list._capacity = capacity;
  list._level = level;
  list._root = root2;
  list._tail = tail;
  list.__ownerID = ownerID;
  list.__hash = hash2;
  list.__altered = false;
  return list;
}
var EMPTY_LIST;
function emptyList() {
  return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
}
function updateList(list, index, value) {
  index = wrapIndex(list, index);
  if (index !== index) {
    return list;
  }
  if (index >= list.size || index < 0) {
    return list.withMutations(function(list2) {
      index < 0 ? setListBounds(list2, index).set(0, value) : setListBounds(list2, 0, index + 1).set(index, value);
    });
  }
  index += list._origin;
  var newTail = list._tail;
  var newRoot = list._root;
  var didAlter = MakeRef();
  if (index >= getTailOffset(list._capacity)) {
    newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
  } else {
    newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
  }
  if (!didAlter.value) {
    return list;
  }
  if (list.__ownerID) {
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = void 0;
    list.__altered = true;
    return list;
  }
  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
}
function updateVNode(node, ownerID, level, index, value, didAlter) {
  var idx = index >>> level & MASK;
  var nodeHas = node && idx < node.array.length;
  if (!nodeHas && value === void 0) {
    return node;
  }
  var newNode;
  if (level > 0) {
    var lowerNode = node && node.array[idx];
    var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
    if (newLowerNode === lowerNode) {
      return node;
    }
    newNode = editableVNode(node, ownerID);
    newNode.array[idx] = newLowerNode;
    return newNode;
  }
  if (nodeHas && node.array[idx] === value) {
    return node;
  }
  if (didAlter) {
    SetRef(didAlter);
  }
  newNode = editableVNode(node, ownerID);
  if (value === void 0 && idx === newNode.array.length - 1) {
    newNode.array.pop();
  } else {
    newNode.array[idx] = value;
  }
  return newNode;
}
function editableVNode(node, ownerID) {
  if (ownerID && node && ownerID === node.ownerID) {
    return node;
  }
  return new VNode(node ? node.array.slice() : [], ownerID);
}
function listNodeFor(list, rawIndex) {
  if (rawIndex >= getTailOffset(list._capacity)) {
    return list._tail;
  }
  if (rawIndex < 1 << list._level + SHIFT) {
    var node = list._root;
    var level = list._level;
    while (node && level > 0) {
      node = node.array[rawIndex >>> level & MASK];
      level -= SHIFT;
    }
    return node;
  }
}
function setListBounds(list, begin, end) {
  if (begin !== void 0) {
    begin |= 0;
  }
  if (end !== void 0) {
    end |= 0;
  }
  var owner = list.__ownerID || new OwnerID();
  var oldOrigin = list._origin;
  var oldCapacity = list._capacity;
  var newOrigin = oldOrigin + begin;
  var newCapacity = end === void 0 ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
    return list;
  }
  if (newOrigin >= newCapacity) {
    return list.clear();
  }
  var newLevel = list._level;
  var newRoot = list._root;
  var offsetShift = 0;
  while (newOrigin + offsetShift < 0) {
    newRoot = new VNode(newRoot && newRoot.array.length ? [void 0, newRoot] : [], owner);
    newLevel += SHIFT;
    offsetShift += 1 << newLevel;
  }
  if (offsetShift) {
    newOrigin += offsetShift;
    oldOrigin += offsetShift;
    newCapacity += offsetShift;
    oldCapacity += offsetShift;
  }
  var oldTailOffset = getTailOffset(oldCapacity);
  var newTailOffset = getTailOffset(newCapacity);
  while (newTailOffset >= 1 << newLevel + SHIFT) {
    newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
    newLevel += SHIFT;
  }
  var oldTail = list._tail;
  var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
  if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
    newRoot = editableVNode(newRoot, owner);
    var node = newRoot;
    for (var level = newLevel; level > SHIFT; level -= SHIFT) {
      var idx = oldTailOffset >>> level & MASK;
      node = node.array[idx] = editableVNode(node.array[idx], owner);
    }
    node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
  }
  if (newCapacity < oldCapacity) {
    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
  }
  if (newOrigin >= newTailOffset) {
    newOrigin -= newTailOffset;
    newCapacity -= newTailOffset;
    newLevel = SHIFT;
    newRoot = null;
    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
    offsetShift = 0;
    while (newRoot) {
      var beginIndex = newOrigin >>> newLevel & MASK;
      if (beginIndex !== newTailOffset >>> newLevel & MASK) {
        break;
      }
      if (beginIndex) {
        offsetShift += (1 << newLevel) * beginIndex;
      }
      newLevel -= SHIFT;
      newRoot = newRoot.array[beginIndex];
    }
    if (newRoot && newOrigin > oldOrigin) {
      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
    }
    if (newRoot && newTailOffset < oldTailOffset) {
      newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
    }
    if (offsetShift) {
      newOrigin -= offsetShift;
      newCapacity -= offsetShift;
    }
  }
  if (list.__ownerID) {
    list.size = newCapacity - newOrigin;
    list._origin = newOrigin;
    list._capacity = newCapacity;
    list._level = newLevel;
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = void 0;
    list.__altered = true;
    return list;
  }
  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
}
function getTailOffset(size) {
  return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
}
var OrderedMap = /* @__PURE__ */ function(Map2) {
  function OrderedMap2(value) {
    return value === null || value === void 0 ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function(map2) {
      var iter = KeyedCollection(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v, k) {
        return map2.set(k, v);
      });
    });
  }
  if (Map2)
    OrderedMap2.__proto__ = Map2;
  OrderedMap2.prototype = Object.create(Map2 && Map2.prototype);
  OrderedMap2.prototype.constructor = OrderedMap2;
  OrderedMap2.of = function of() {
    return this(arguments);
  };
  OrderedMap2.prototype.toString = function toString4() {
    return this.__toString("OrderedMap {", "}");
  };
  OrderedMap2.prototype.get = function get11(k, notSetValue) {
    var index = this._map.get(k);
    return index !== void 0 ? this._list.get(index)[1] : notSetValue;
  };
  OrderedMap2.prototype.clear = function clear() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._map.clear();
      this._list.clear();
      this.__altered = true;
      return this;
    }
    return emptyOrderedMap();
  };
  OrderedMap2.prototype.set = function set3(k, v) {
    return updateOrderedMap(this, k, v);
  };
  OrderedMap2.prototype.remove = function remove3(k) {
    return updateOrderedMap(this, k, NOT_SET);
  };
  OrderedMap2.prototype.__iterate = function __iterate(fn, reverse3) {
    var this$1$1 = this;
    return this._list.__iterate(function(entry) {
      return entry && fn(entry[1], entry[0], this$1$1);
    }, reverse3);
  };
  OrderedMap2.prototype.__iterator = function __iterator(type, reverse3) {
    return this._list.fromEntrySeq().__iterator(type, reverse3);
  };
  OrderedMap2.prototype.__ensureOwner = function __ensureOwner(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    var newList = this._list.__ensureOwner(ownerID);
    if (!ownerID) {
      if (this.size === 0) {
        return emptyOrderedMap();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      this._map = newMap;
      this._list = newList;
      return this;
    }
    return makeOrderedMap(newMap, newList, ownerID, this.__hash);
  };
  return OrderedMap2;
}(Map$1);
OrderedMap.isOrderedMap = isOrderedMap;
OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;
OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
function makeOrderedMap(map2, list, ownerID, hash2) {
  var omap = Object.create(OrderedMap.prototype);
  omap.size = map2 ? map2.size : 0;
  omap._map = map2;
  omap._list = list;
  omap.__ownerID = ownerID;
  omap.__hash = hash2;
  omap.__altered = false;
  return omap;
}
var EMPTY_ORDERED_MAP;
function emptyOrderedMap() {
  return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
}
function updateOrderedMap(omap, k, v) {
  var map2 = omap._map;
  var list = omap._list;
  var i = map2.get(k);
  var has4 = i !== void 0;
  var newMap;
  var newList;
  if (v === NOT_SET) {
    if (!has4) {
      return omap;
    }
    if (list.size >= SIZE && list.size >= map2.size * 2) {
      newList = list.filter(function(entry, idx) {
        return entry !== void 0 && i !== idx;
      });
      newMap = newList.toKeyedSeq().map(function(entry) {
        return entry[0];
      }).flip().toMap();
      if (omap.__ownerID) {
        newMap.__ownerID = newList.__ownerID = omap.__ownerID;
      }
    } else {
      newMap = map2.remove(k);
      newList = i === list.size - 1 ? list.pop() : list.set(i, void 0);
    }
  } else if (has4) {
    if (v === list.get(i)[1]) {
      return omap;
    }
    newMap = map2;
    newList = list.set(i, [k, v]);
  } else {
    newMap = map2.set(k, list.size);
    newList = list.set(list.size, [k, v]);
  }
  if (omap.__ownerID) {
    omap.size = newMap.size;
    omap._map = newMap;
    omap._list = newList;
    omap.__hash = void 0;
    omap.__altered = true;
    return omap;
  }
  return makeOrderedMap(newMap, newList);
}
var IS_STACK_SYMBOL = "@@__IMMUTABLE_STACK__@@";
function isStack(maybeStack) {
  return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);
}
var Stack = /* @__PURE__ */ function(IndexedCollection2) {
  function Stack2(value) {
    return value === null || value === void 0 ? emptyStack() : isStack(value) ? value : emptyStack().pushAll(value);
  }
  if (IndexedCollection2)
    Stack2.__proto__ = IndexedCollection2;
  Stack2.prototype = Object.create(IndexedCollection2 && IndexedCollection2.prototype);
  Stack2.prototype.constructor = Stack2;
  Stack2.of = function of() {
    return this(arguments);
  };
  Stack2.prototype.toString = function toString4() {
    return this.__toString("Stack [", "]");
  };
  Stack2.prototype.get = function get11(index, notSetValue) {
    var head = this._head;
    index = wrapIndex(this, index);
    while (head && index--) {
      head = head.next;
    }
    return head ? head.value : notSetValue;
  };
  Stack2.prototype.peek = function peek() {
    return this._head && this._head.value;
  };
  Stack2.prototype.push = function push2() {
    var arguments$1 = arguments;
    if (arguments.length === 0) {
      return this;
    }
    var newSize = this.size + arguments.length;
    var head = this._head;
    for (var ii = arguments.length - 1; ii >= 0; ii--) {
      head = {
        value: arguments$1[ii],
        next: head
      };
    }
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };
  Stack2.prototype.pushAll = function pushAll(iter) {
    iter = IndexedCollection2(iter);
    if (iter.size === 0) {
      return this;
    }
    if (this.size === 0 && isStack(iter)) {
      return iter;
    }
    assertNotInfinite(iter.size);
    var newSize = this.size;
    var head = this._head;
    iter.__iterate(function(value) {
      newSize++;
      head = {
        value,
        next: head
      };
    }, true);
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };
  Stack2.prototype.pop = function pop() {
    return this.slice(1);
  };
  Stack2.prototype.clear = function clear() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._head = void 0;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return emptyStack();
  };
  Stack2.prototype.slice = function slice4(begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }
    var resolvedBegin = resolveBegin(begin, this.size);
    var resolvedEnd = resolveEnd(end, this.size);
    if (resolvedEnd !== this.size) {
      return IndexedCollection2.prototype.slice.call(this, begin, end);
    }
    var newSize = this.size - resolvedBegin;
    var head = this._head;
    while (resolvedBegin--) {
      head = head.next;
    }
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };
  Stack2.prototype.__ensureOwner = function __ensureOwner(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyStack();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeStack(this.size, this._head, ownerID, this.__hash);
  };
  Stack2.prototype.__iterate = function __iterate(fn, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return new ArraySeq(this.toArray()).__iterate(function(v, k) {
        return fn(v, k, this$1$1);
      }, reverse3);
    }
    var iterations = 0;
    var node = this._head;
    while (node) {
      if (fn(node.value, iterations++, this) === false) {
        break;
      }
      node = node.next;
    }
    return iterations;
  };
  Stack2.prototype.__iterator = function __iterator(type, reverse3) {
    if (reverse3) {
      return new ArraySeq(this.toArray()).__iterator(type, reverse3);
    }
    var iterations = 0;
    var node = this._head;
    return new Iterator(function() {
      if (node) {
        var value = node.value;
        node = node.next;
        return iteratorValue(type, iterations++, value);
      }
      return iteratorDone();
    });
  };
  return Stack2;
}(IndexedCollection);
Stack.isStack = isStack;
var StackPrototype = Stack.prototype;
StackPrototype[IS_STACK_SYMBOL] = true;
StackPrototype.shift = StackPrototype.pop;
StackPrototype.unshift = StackPrototype.push;
StackPrototype.unshiftAll = StackPrototype.pushAll;
StackPrototype.withMutations = withMutations;
StackPrototype.wasAltered = wasAltered;
StackPrototype.asImmutable = asImmutable;
StackPrototype["@@transducer/init"] = StackPrototype.asMutable = asMutable;
StackPrototype["@@transducer/step"] = function(result, arr) {
  return result.unshift(arr);
};
StackPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
function makeStack(size, head, ownerID, hash2) {
  var map2 = Object.create(StackPrototype);
  map2.size = size;
  map2._head = head;
  map2.__ownerID = ownerID;
  map2.__hash = hash2;
  map2.__altered = false;
  return map2;
}
var EMPTY_STACK;
function emptyStack() {
  return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
}
var IS_SET_SYMBOL = "@@__IMMUTABLE_SET__@@";
function isSet$1(maybeSet) {
  return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);
}
function isOrderedSet(maybeOrderedSet) {
  return isSet$1(maybeOrderedSet) && isOrdered(maybeOrderedSet);
}
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (!isCollection(b) || a.size !== void 0 && b.size !== void 0 && a.size !== b.size || a.__hash !== void 0 && b.__hash !== void 0 && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
    return false;
  }
  if (a.size === 0 && b.size === 0) {
    return true;
  }
  var notAssociative = !isAssociative(a);
  if (isOrdered(a)) {
    var entries2 = a.entries();
    return b.every(function(v, k) {
      var entry = entries2.next().value;
      return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
    }) && entries2.next().done;
  }
  var flipped = false;
  if (a.size === void 0) {
    if (b.size === void 0) {
      if (typeof a.cacheResult === "function") {
        a.cacheResult();
      }
    } else {
      flipped = true;
      var _ = a;
      a = b;
      b = _;
    }
  }
  var allEqual = true;
  var bSize = b.__iterate(function(v, k) {
    if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
      allEqual = false;
      return false;
    }
  });
  return allEqual && a.size === bSize;
}
function mixin(ctor, methods) {
  var keyCopier = function(key) {
    ctor.prototype[key] = methods[key];
  };
  Object.keys(methods).forEach(keyCopier);
  Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
  return ctor;
}
function toJS(value) {
  if (!value || typeof value !== "object") {
    return value;
  }
  if (!isCollection(value)) {
    if (!isDataStructure(value)) {
      return value;
    }
    value = Seq(value);
  }
  if (isKeyed(value)) {
    var result$1 = {};
    value.__iterate(function(v, k) {
      result$1[k] = toJS(v);
    });
    return result$1;
  }
  var result = [];
  value.__iterate(function(v) {
    result.push(toJS(v));
  });
  return result;
}
var Set$2 = /* @__PURE__ */ function(SetCollection2) {
  function Set2(value) {
    return value === null || value === void 0 ? emptySet() : isSet$1(value) && !isOrdered(value) ? value : emptySet().withMutations(function(set3) {
      var iter = SetCollection2(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v) {
        return set3.add(v);
      });
    });
  }
  if (SetCollection2)
    Set2.__proto__ = SetCollection2;
  Set2.prototype = Object.create(SetCollection2 && SetCollection2.prototype);
  Set2.prototype.constructor = Set2;
  Set2.of = function of() {
    return this(arguments);
  };
  Set2.fromKeys = function fromKeys(value) {
    return this(KeyedCollection(value).keySeq());
  };
  Set2.intersect = function intersect(sets) {
    sets = Collection(sets).toArray();
    return sets.length ? SetPrototype.intersect.apply(Set2(sets.pop()), sets) : emptySet();
  };
  Set2.union = function union(sets) {
    sets = Collection(sets).toArray();
    return sets.length ? SetPrototype.union.apply(Set2(sets.pop()), sets) : emptySet();
  };
  Set2.prototype.toString = function toString4() {
    return this.__toString("Set {", "}");
  };
  Set2.prototype.has = function has4(value) {
    return this._map.has(value);
  };
  Set2.prototype.add = function add4(value) {
    return updateSet(this, this._map.set(value, value));
  };
  Set2.prototype.remove = function remove3(value) {
    return updateSet(this, this._map.remove(value));
  };
  Set2.prototype.clear = function clear() {
    return updateSet(this, this._map.clear());
  };
  Set2.prototype.map = function map2(mapper, context) {
    var this$1$1 = this;
    var didChanges = false;
    var newMap = updateSet(this, this._map.mapEntries(function(ref) {
      var v = ref[1];
      var mapped = mapper.call(context, v, v, this$1$1);
      if (mapped !== v) {
        didChanges = true;
      }
      return [mapped, mapped];
    }, context));
    return didChanges ? newMap : this;
  };
  Set2.prototype.union = function union() {
    var iters = [], len = arguments.length;
    while (len--)
      iters[len] = arguments[len];
    iters = iters.filter(function(x) {
      return x.size !== 0;
    });
    if (iters.length === 0) {
      return this;
    }
    if (this.size === 0 && !this.__ownerID && iters.length === 1) {
      return this.constructor(iters[0]);
    }
    return this.withMutations(function(set3) {
      for (var ii = 0; ii < iters.length; ii++) {
        SetCollection2(iters[ii]).forEach(function(value) {
          return set3.add(value);
        });
      }
    });
  };
  Set2.prototype.intersect = function intersect() {
    var iters = [], len = arguments.length;
    while (len--)
      iters[len] = arguments[len];
    if (iters.length === 0) {
      return this;
    }
    iters = iters.map(function(iter) {
      return SetCollection2(iter);
    });
    var toRemove = [];
    this.forEach(function(value) {
      if (!iters.every(function(iter) {
        return iter.includes(value);
      })) {
        toRemove.push(value);
      }
    });
    return this.withMutations(function(set3) {
      toRemove.forEach(function(value) {
        set3.remove(value);
      });
    });
  };
  Set2.prototype.subtract = function subtract() {
    var iters = [], len = arguments.length;
    while (len--)
      iters[len] = arguments[len];
    if (iters.length === 0) {
      return this;
    }
    iters = iters.map(function(iter) {
      return SetCollection2(iter);
    });
    var toRemove = [];
    this.forEach(function(value) {
      if (iters.some(function(iter) {
        return iter.includes(value);
      })) {
        toRemove.push(value);
      }
    });
    return this.withMutations(function(set3) {
      toRemove.forEach(function(value) {
        set3.remove(value);
      });
    });
  };
  Set2.prototype.sort = function sort2(comparator) {
    return OrderedSet(sortFactory(this, comparator));
  };
  Set2.prototype.sortBy = function sortBy2(mapper, comparator) {
    return OrderedSet(sortFactory(this, comparator, mapper));
  };
  Set2.prototype.wasAltered = function wasAltered2() {
    return this._map.wasAltered();
  };
  Set2.prototype.__iterate = function __iterate(fn, reverse3) {
    var this$1$1 = this;
    return this._map.__iterate(function(k) {
      return fn(k, k, this$1$1);
    }, reverse3);
  };
  Set2.prototype.__iterator = function __iterator(type, reverse3) {
    return this._map.__iterator(type, reverse3);
  };
  Set2.prototype.__ensureOwner = function __ensureOwner(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    if (!ownerID) {
      if (this.size === 0) {
        return this.__empty();
      }
      this.__ownerID = ownerID;
      this._map = newMap;
      return this;
    }
    return this.__make(newMap, ownerID);
  };
  return Set2;
}(SetCollection);
Set$2.isSet = isSet$1;
var SetPrototype = Set$2.prototype;
SetPrototype[IS_SET_SYMBOL] = true;
SetPrototype[DELETE] = SetPrototype.remove;
SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
SetPrototype.withMutations = withMutations;
SetPrototype.asImmutable = asImmutable;
SetPrototype["@@transducer/init"] = SetPrototype.asMutable = asMutable;
SetPrototype["@@transducer/step"] = function(result, arr) {
  return result.add(arr);
};
SetPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
SetPrototype.__empty = emptySet;
SetPrototype.__make = makeSet;
function updateSet(set3, newMap) {
  if (set3.__ownerID) {
    set3.size = newMap.size;
    set3._map = newMap;
    return set3;
  }
  return newMap === set3._map ? set3 : newMap.size === 0 ? set3.__empty() : set3.__make(newMap);
}
function makeSet(map2, ownerID) {
  var set3 = Object.create(SetPrototype);
  set3.size = map2 ? map2.size : 0;
  set3._map = map2;
  set3.__ownerID = ownerID;
  return set3;
}
var EMPTY_SET$1;
function emptySet() {
  return EMPTY_SET$1 || (EMPTY_SET$1 = makeSet(emptyMap()));
}
var Range = /* @__PURE__ */ function(IndexedSeq2) {
  function Range2(start, end, step) {
    if (!(this instanceof Range2)) {
      return new Range2(start, end, step);
    }
    invariant(step !== 0, "Cannot step a Range by 0");
    start = start || 0;
    if (end === void 0) {
      end = Infinity;
    }
    step = step === void 0 ? 1 : Math.abs(step);
    if (end < start) {
      step = -step;
    }
    this._start = start;
    this._end = end;
    this._step = step;
    this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
    if (this.size === 0) {
      if (EMPTY_RANGE) {
        return EMPTY_RANGE;
      }
      EMPTY_RANGE = this;
    }
  }
  if (IndexedSeq2)
    Range2.__proto__ = IndexedSeq2;
  Range2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  Range2.prototype.constructor = Range2;
  Range2.prototype.toString = function toString4() {
    if (this.size === 0) {
      return "Range []";
    }
    return "Range [ " + this._start + "..." + this._end + (this._step !== 1 ? " by " + this._step : "") + " ]";
  };
  Range2.prototype.get = function get11(index, notSetValue) {
    return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
  };
  Range2.prototype.includes = function includes3(searchValue) {
    var possibleIndex = (searchValue - this._start) / this._step;
    return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
  };
  Range2.prototype.slice = function slice4(begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }
    begin = resolveBegin(begin, this.size);
    end = resolveEnd(end, this.size);
    if (end <= begin) {
      return new Range2(0, 0);
    }
    return new Range2(this.get(begin, this._end), this.get(end, this._end), this._step);
  };
  Range2.prototype.indexOf = function indexOf3(searchValue) {
    var offsetValue = searchValue - this._start;
    if (offsetValue % this._step === 0) {
      var index = offsetValue / this._step;
      if (index >= 0 && index < this.size) {
        return index;
      }
    }
    return -1;
  };
  Range2.prototype.lastIndexOf = function lastIndexOf2(searchValue) {
    return this.indexOf(searchValue);
  };
  Range2.prototype.__iterate = function __iterate(fn, reverse3) {
    var size = this.size;
    var step = this._step;
    var value = reverse3 ? this._start + (size - 1) * step : this._start;
    var i = 0;
    while (i !== size) {
      if (fn(value, reverse3 ? size - ++i : i++, this) === false) {
        break;
      }
      value += reverse3 ? -step : step;
    }
    return i;
  };
  Range2.prototype.__iterator = function __iterator(type, reverse3) {
    var size = this.size;
    var step = this._step;
    var value = reverse3 ? this._start + (size - 1) * step : this._start;
    var i = 0;
    return new Iterator(function() {
      if (i === size) {
        return iteratorDone();
      }
      var v = value;
      value += reverse3 ? -step : step;
      return iteratorValue(type, reverse3 ? size - ++i : i++, v);
    });
  };
  Range2.prototype.equals = function equals2(other) {
    return other instanceof Range2 ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
  };
  return Range2;
}(IndexedSeq);
var EMPTY_RANGE;
function getIn$1(collection, searchKeyPath, notSetValue) {
  var keyPath = coerceKeyPath(searchKeyPath);
  var i = 0;
  while (i !== keyPath.length) {
    collection = get2(collection, keyPath[i++], NOT_SET);
    if (collection === NOT_SET) {
      return notSetValue;
    }
  }
  return collection;
}
function getIn(searchKeyPath, notSetValue) {
  return getIn$1(this, searchKeyPath, notSetValue);
}
function hasIn$1(collection, keyPath) {
  return getIn$1(collection, keyPath, NOT_SET) !== NOT_SET;
}
function hasIn(searchKeyPath) {
  return hasIn$1(this, searchKeyPath);
}
function toObject() {
  assertNotInfinite(this.size);
  var object = {};
  this.__iterate(function(v, k) {
    object[k] = v;
  });
  return object;
}
Collection.isIterable = isCollection;
Collection.isKeyed = isKeyed;
Collection.isIndexed = isIndexed;
Collection.isAssociative = isAssociative;
Collection.isOrdered = isOrdered;
Collection.Iterator = Iterator;
mixin(Collection, {
  toArray: function toArray2() {
    assertNotInfinite(this.size);
    var array = new Array(this.size || 0);
    var useTuples = isKeyed(this);
    var i = 0;
    this.__iterate(function(v, k) {
      array[i++] = useTuples ? [k, v] : v;
    });
    return array;
  },
  toIndexedSeq: function toIndexedSeq() {
    return new ToIndexedSequence(this);
  },
  toJS: function toJS$1() {
    return toJS(this);
  },
  toKeyedSeq: function toKeyedSeq() {
    return new ToKeyedSequence(this, true);
  },
  toMap: function toMap() {
    return Map$1(this.toKeyedSeq());
  },
  toObject,
  toOrderedMap: function toOrderedMap() {
    return OrderedMap(this.toKeyedSeq());
  },
  toOrderedSet: function toOrderedSet() {
    return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
  },
  toSet: function toSet() {
    return Set$2(isKeyed(this) ? this.valueSeq() : this);
  },
  toSetSeq: function toSetSeq() {
    return new ToSetSequence(this);
  },
  toSeq: function toSeq() {
    return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
  },
  toStack: function toStack() {
    return Stack(isKeyed(this) ? this.valueSeq() : this);
  },
  toList: function toList() {
    return List$1(isKeyed(this) ? this.valueSeq() : this);
  },
  toString: function toString3() {
    return "[Collection]";
  },
  __toString: function __toString(head, tail) {
    if (this.size === 0) {
      return head + tail;
    }
    return head + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + tail;
  },
  concat: function concat() {
    var values2 = [], len = arguments.length;
    while (len--)
      values2[len] = arguments[len];
    return reify(this, concatFactory(this, values2));
  },
  includes: function includes(searchValue) {
    return this.some(function(value) {
      return is(value, searchValue);
    });
  },
  entries: function entries() {
    return this.__iterator(ITERATE_ENTRIES);
  },
  every: function every(predicate, context) {
    assertNotInfinite(this.size);
    var returnValue = true;
    this.__iterate(function(v, k, c) {
      if (!predicate.call(context, v, k, c)) {
        returnValue = false;
        return false;
      }
    });
    return returnValue;
  },
  filter: function filter(predicate, context) {
    return reify(this, filterFactory(this, predicate, context, true));
  },
  find: function find(predicate, context, notSetValue) {
    var entry = this.findEntry(predicate, context);
    return entry ? entry[1] : notSetValue;
  },
  forEach: function forEach(sideEffect, context) {
    assertNotInfinite(this.size);
    return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
  },
  join: function join(separator) {
    assertNotInfinite(this.size);
    separator = separator !== void 0 ? "" + separator : ",";
    var joined = "";
    var isFirst = true;
    this.__iterate(function(v) {
      isFirst ? isFirst = false : joined += separator;
      joined += v !== null && v !== void 0 ? v.toString() : "";
    });
    return joined;
  },
  keys: function keys2() {
    return this.__iterator(ITERATE_KEYS);
  },
  map: function map(mapper, context) {
    return reify(this, mapFactory(this, mapper, context));
  },
  reduce: function reduce$12(reducer2, initialReduction, context) {
    return reduce(this, reducer2, initialReduction, context, arguments.length < 2, false);
  },
  reduceRight: function reduceRight(reducer2, initialReduction, context) {
    return reduce(this, reducer2, initialReduction, context, arguments.length < 2, true);
  },
  reverse: function reverse() {
    return reify(this, reverseFactory(this, true));
  },
  slice: function slice(begin, end) {
    return reify(this, sliceFactory(this, begin, end, true));
  },
  some: function some(predicate, context) {
    return !this.every(not(predicate), context);
  },
  sort: function sort(comparator) {
    return reify(this, sortFactory(this, comparator));
  },
  values: function values() {
    return this.__iterator(ITERATE_VALUES);
  },
  butLast: function butLast() {
    return this.slice(0, -1);
  },
  isEmpty: function isEmpty2() {
    return this.size !== void 0 ? this.size === 0 : !this.some(function() {
      return true;
    });
  },
  count: function count(predicate, context) {
    return ensureSize(predicate ? this.toSeq().filter(predicate, context) : this);
  },
  countBy: function countBy(grouper, context) {
    return countByFactory(this, grouper, context);
  },
  equals: function equals(other) {
    return deepEqual(this, other);
  },
  entrySeq: function entrySeq() {
    var collection = this;
    if (collection._cache) {
      return new ArraySeq(collection._cache);
    }
    var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();
    entriesSequence.fromEntrySeq = function() {
      return collection.toSeq();
    };
    return entriesSequence;
  },
  filterNot: function filterNot(predicate, context) {
    return this.filter(not(predicate), context);
  },
  findEntry: function findEntry(predicate, context, notSetValue) {
    var found = notSetValue;
    this.__iterate(function(v, k, c) {
      if (predicate.call(context, v, k, c)) {
        found = [k, v];
        return false;
      }
    });
    return found;
  },
  findKey: function findKey(predicate, context) {
    var entry = this.findEntry(predicate, context);
    return entry && entry[0];
  },
  findLast: function findLast(predicate, context, notSetValue) {
    return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
  },
  findLastEntry: function findLastEntry(predicate, context, notSetValue) {
    return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
  },
  findLastKey: function findLastKey(predicate, context) {
    return this.toKeyedSeq().reverse().findKey(predicate, context);
  },
  first: function first(notSetValue) {
    return this.find(returnTrue2, null, notSetValue);
  },
  flatMap: function flatMap(mapper, context) {
    return reify(this, flatMapFactory(this, mapper, context));
  },
  flatten: function flatten2(depth) {
    return reify(this, flattenFactory(this, depth, true));
  },
  fromEntrySeq: function fromEntrySeq() {
    return new FromEntriesSequence(this);
  },
  get: function get8(searchKey, notSetValue) {
    return this.find(function(_, key) {
      return is(key, searchKey);
    }, void 0, notSetValue);
  },
  getIn,
  groupBy: function groupBy(grouper, context) {
    return groupByFactory(this, grouper, context);
  },
  has: function has(searchKey) {
    return this.get(searchKey, NOT_SET) !== NOT_SET;
  },
  hasIn,
  isSubset: function isSubset(iter) {
    iter = typeof iter.includes === "function" ? iter : Collection(iter);
    return this.every(function(value) {
      return iter.includes(value);
    });
  },
  isSuperset: function isSuperset(iter) {
    iter = typeof iter.isSubset === "function" ? iter : Collection(iter);
    return iter.isSubset(this);
  },
  keyOf: function keyOf(searchValue) {
    return this.findKey(function(value) {
      return is(value, searchValue);
    });
  },
  keySeq: function keySeq() {
    return this.toSeq().map(keyMapper).toIndexedSeq();
  },
  last: function last2(notSetValue) {
    return this.toSeq().reverse().first(notSetValue);
  },
  lastKeyOf: function lastKeyOf(searchValue) {
    return this.toKeyedSeq().reverse().keyOf(searchValue);
  },
  max: function max(comparator) {
    return maxFactory(this, comparator);
  },
  maxBy: function maxBy(mapper, comparator) {
    return maxFactory(this, comparator, mapper);
  },
  min: function min(comparator) {
    return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
  },
  minBy: function minBy(mapper, comparator) {
    return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
  },
  rest: function rest() {
    return this.slice(1);
  },
  skip: function skip(amount) {
    return amount === 0 ? this : this.slice(Math.max(0, amount));
  },
  skipLast: function skipLast(amount) {
    return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
  },
  skipWhile: function skipWhile(predicate, context) {
    return reify(this, skipWhileFactory(this, predicate, context, true));
  },
  skipUntil: function skipUntil(predicate, context) {
    return this.skipWhile(not(predicate), context);
  },
  sortBy: function sortBy(mapper, comparator) {
    return reify(this, sortFactory(this, comparator, mapper));
  },
  take: function take(amount) {
    return this.slice(0, Math.max(0, amount));
  },
  takeLast: function takeLast(amount) {
    return this.slice(-Math.max(0, amount));
  },
  takeWhile: function takeWhile(predicate, context) {
    return reify(this, takeWhileFactory(this, predicate, context));
  },
  takeUntil: function takeUntil(predicate, context) {
    return this.takeWhile(not(predicate), context);
  },
  update: function update7(fn) {
    return fn(this);
  },
  valueSeq: function valueSeq() {
    return this.toIndexedSeq();
  },
  hashCode: function hashCode() {
    return this.__hash || (this.__hash = hashCollection(this));
  }
});
var CollectionPrototype = Collection.prototype;
CollectionPrototype[IS_COLLECTION_SYMBOL] = true;
CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
CollectionPrototype.toJSON = CollectionPrototype.toArray;
CollectionPrototype.__toStringMapper = quoteString;
CollectionPrototype.inspect = CollectionPrototype.toSource = function() {
  return this.toString();
};
CollectionPrototype.chain = CollectionPrototype.flatMap;
CollectionPrototype.contains = CollectionPrototype.includes;
mixin(KeyedCollection, {
  flip: function flip() {
    return reify(this, flipFactory(this));
  },
  mapEntries: function mapEntries(mapper, context) {
    var this$1$1 = this;
    var iterations = 0;
    return reify(this, this.toSeq().map(function(v, k) {
      return mapper.call(context, [k, v], iterations++, this$1$1);
    }).fromEntrySeq());
  },
  mapKeys: function mapKeys(mapper, context) {
    var this$1$1 = this;
    return reify(this, this.toSeq().flip().map(function(k, v) {
      return mapper.call(context, k, v, this$1$1);
    }).flip());
  }
});
var KeyedCollectionPrototype = KeyedCollection.prototype;
KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;
KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
KeyedCollectionPrototype.toJSON = toObject;
KeyedCollectionPrototype.__toStringMapper = function(v, k) {
  return quoteString(k) + ": " + quoteString(v);
};
mixin(IndexedCollection, {
  toKeyedSeq: function toKeyedSeq2() {
    return new ToKeyedSequence(this, false);
  },
  filter: function filter2(predicate, context) {
    return reify(this, filterFactory(this, predicate, context, false));
  },
  findIndex: function findIndex(predicate, context) {
    var entry = this.findEntry(predicate, context);
    return entry ? entry[0] : -1;
  },
  indexOf: function indexOf(searchValue) {
    var key = this.keyOf(searchValue);
    return key === void 0 ? -1 : key;
  },
  lastIndexOf: function lastIndexOf(searchValue) {
    var key = this.lastKeyOf(searchValue);
    return key === void 0 ? -1 : key;
  },
  reverse: function reverse2() {
    return reify(this, reverseFactory(this, false));
  },
  slice: function slice2(begin, end) {
    return reify(this, sliceFactory(this, begin, end, false));
  },
  splice: function splice2(index, removeNum) {
    var numArgs = arguments.length;
    removeNum = Math.max(removeNum || 0, 0);
    if (numArgs === 0 || numArgs === 2 && !removeNum) {
      return this;
    }
    index = resolveBegin(index, index < 0 ? this.count() : this.size);
    var spliced = this.slice(0, index);
    return reify(this, numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum)));
  },
  findLastIndex: function findLastIndex(predicate, context) {
    var entry = this.findLastEntry(predicate, context);
    return entry ? entry[0] : -1;
  },
  first: function first2(notSetValue) {
    return this.get(0, notSetValue);
  },
  flatten: function flatten3(depth) {
    return reify(this, flattenFactory(this, depth, false));
  },
  get: function get9(index, notSetValue) {
    index = wrapIndex(this, index);
    return index < 0 || this.size === Infinity || this.size !== void 0 && index > this.size ? notSetValue : this.find(function(_, key) {
      return key === index;
    }, void 0, notSetValue);
  },
  has: function has2(index) {
    index = wrapIndex(this, index);
    return index >= 0 && (this.size !== void 0 ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
  },
  interpose: function interpose(separator) {
    return reify(this, interposeFactory(this, separator));
  },
  interleave: function interleave() {
    var collections = [this].concat(arrCopy(arguments));
    var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
    var interleaved = zipped.flatten(true);
    if (zipped.size) {
      interleaved.size = zipped.size * collections.length;
    }
    return reify(this, interleaved);
  },
  keySeq: function keySeq2() {
    return Range(0, this.size);
  },
  last: function last3(notSetValue) {
    return this.get(-1, notSetValue);
  },
  skipWhile: function skipWhile2(predicate, context) {
    return reify(this, skipWhileFactory(this, predicate, context, false));
  },
  zip: function zip() {
    var collections = [this].concat(arrCopy(arguments));
    return reify(this, zipWithFactory(this, defaultZipper, collections));
  },
  zipAll: function zipAll() {
    var collections = [this].concat(arrCopy(arguments));
    return reify(this, zipWithFactory(this, defaultZipper, collections, true));
  },
  zipWith: function zipWith(zipper) {
    var collections = arrCopy(arguments);
    collections[0] = this;
    return reify(this, zipWithFactory(this, zipper, collections));
  }
});
var IndexedCollectionPrototype = IndexedCollection.prototype;
IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;
IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;
mixin(SetCollection, {
  get: function get10(value, notSetValue) {
    return this.has(value) ? value : notSetValue;
  },
  includes: function includes2(value) {
    return this.has(value);
  },
  keySeq: function keySeq3() {
    return this.valueSeq();
  }
});
var SetCollectionPrototype = SetCollection.prototype;
SetCollectionPrototype.has = CollectionPrototype.includes;
SetCollectionPrototype.contains = SetCollectionPrototype.includes;
SetCollectionPrototype.keys = SetCollectionPrototype.values;
mixin(KeyedSeq, KeyedCollectionPrototype);
mixin(IndexedSeq, IndexedCollectionPrototype);
mixin(SetSeq, SetCollectionPrototype);
function reduce(collection, reducer2, reduction, context, useFirst, reverse3) {
  assertNotInfinite(collection.size);
  collection.__iterate(function(v, k, c) {
    if (useFirst) {
      useFirst = false;
      reduction = v;
    } else {
      reduction = reducer2.call(context, reduction, v, k, c);
    }
  }, reverse3);
  return reduction;
}
function keyMapper(v, k) {
  return k;
}
function entryMapper(v, k) {
  return [k, v];
}
function not(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}
function neg(predicate) {
  return function() {
    return -predicate.apply(this, arguments);
  };
}
function defaultZipper() {
  return arrCopy(arguments);
}
function defaultNegComparator(a, b) {
  return a < b ? 1 : a > b ? -1 : 0;
}
function hashCollection(collection) {
  if (collection.size === Infinity) {
    return 0;
  }
  var ordered = isOrdered(collection);
  var keyed = isKeyed(collection);
  var h = ordered ? 1 : 0;
  var size = collection.__iterate(keyed ? ordered ? function(v, k) {
    h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
  } : function(v, k) {
    h = h + hashMerge(hash(v), hash(k)) | 0;
  } : ordered ? function(v) {
    h = 31 * h + hash(v) | 0;
  } : function(v) {
    h = h + hash(v) | 0;
  });
  return murmurHashOfSize(size, h);
}
function murmurHashOfSize(size, h) {
  h = imul(h, 3432918353);
  h = imul(h << 15 | h >>> -15, 461845907);
  h = imul(h << 13 | h >>> -13, 5);
  h = (h + 3864292196 | 0) ^ size;
  h = imul(h ^ h >>> 16, 2246822507);
  h = imul(h ^ h >>> 13, 3266489909);
  h = smi(h ^ h >>> 16);
  return h;
}
function hashMerge(a, b) {
  return a ^ b + 2654435769 + (a << 6) + (a >> 2) | 0;
}
var OrderedSet = /* @__PURE__ */ function(Set2) {
  function OrderedSet2(value) {
    return value === null || value === void 0 ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function(set3) {
      var iter = SetCollection(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v) {
        return set3.add(v);
      });
    });
  }
  if (Set2)
    OrderedSet2.__proto__ = Set2;
  OrderedSet2.prototype = Object.create(Set2 && Set2.prototype);
  OrderedSet2.prototype.constructor = OrderedSet2;
  OrderedSet2.of = function of() {
    return this(arguments);
  };
  OrderedSet2.fromKeys = function fromKeys(value) {
    return this(KeyedCollection(value).keySeq());
  };
  OrderedSet2.prototype.toString = function toString4() {
    return this.__toString("OrderedSet {", "}");
  };
  return OrderedSet2;
}(Set$2);
OrderedSet.isOrderedSet = isOrderedSet;
var OrderedSetPrototype = OrderedSet.prototype;
OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;
OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;
OrderedSetPrototype.zipAll = IndexedCollectionPrototype.zipAll;
OrderedSetPrototype.__empty = emptyOrderedSet;
OrderedSetPrototype.__make = makeOrderedSet;
function makeOrderedSet(map2, ownerID) {
  var set3 = Object.create(OrderedSetPrototype);
  set3.size = map2 ? map2.size : 0;
  set3._map = map2;
  set3.__ownerID = ownerID;
  return set3;
}
var EMPTY_ORDERED_SET;
function emptyOrderedSet() {
  return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
}
var reactDomServer_browser_production_min = {};
/** @license React v17.0.2
 * react-dom-server.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l = objectAssign, m = React$a;
function p(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var q = 60106, r = 60107, u = 60108, z = 60114, B = 60109, aa = 60110, ba = 60112, D = 60113, ca = 60120, da = 60115, ea = 60116, fa = 60121, ha = 60117, ia = 60119, ja = 60129, ka = 60131;
if (typeof Symbol === "function" && Symbol.for) {
  var E = Symbol.for;
  q = E("react.portal");
  r = E("react.fragment");
  u = E("react.strict_mode");
  z = E("react.profiler");
  B = E("react.provider");
  aa = E("react.context");
  ba = E("react.forward_ref");
  D = E("react.suspense");
  ca = E("react.suspense_list");
  da = E("react.memo");
  ea = E("react.lazy");
  fa = E("react.block");
  ha = E("react.fundamental");
  ia = E("react.scope");
  ja = E("react.debug_trace_mode");
  ka = E("react.legacy_hidden");
}
function F(a) {
  if (a == null)
    return null;
  if (typeof a === "function")
    return a.displayName || a.name || null;
  if (typeof a === "string")
    return a;
  switch (a) {
    case r:
      return "Fragment";
    case q:
      return "Portal";
    case z:
      return "Profiler";
    case u:
      return "StrictMode";
    case D:
      return "Suspense";
    case ca:
      return "SuspenseList";
  }
  if (typeof a === "object")
    switch (a.$$typeof) {
      case aa:
        return (a.displayName || "Context") + ".Consumer";
      case B:
        return (a._context.displayName || "Context") + ".Provider";
      case ba:
        var b = a.render;
        b = b.displayName || b.name || "";
        return a.displayName || (b !== "" ? "ForwardRef(" + b + ")" : "ForwardRef");
      case da:
        return F(a.type);
      case fa:
        return F(a._render);
      case ea:
        b = a._payload;
        a = a._init;
        try {
          return F(a(b));
        } catch (c) {
        }
    }
  return null;
}
var la = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ma = {};
function I(a, b) {
  for (var c = a._threadCount | 0; c <= b; c++)
    a[c] = a._currentValue2, a._threadCount = c + 1;
}
function na(a, b, c, d) {
  if (d && (d = a.contextType, typeof d === "object" && d !== null))
    return I(d, c), d[c];
  if (a = a.contextTypes) {
    c = {};
    for (var f2 in a)
      c[f2] = b[f2];
    b = c;
  } else
    b = ma;
  return b;
}
for (var J = new Uint16Array(16), K = 0; 15 > K; K++)
  J[K] = K + 1;
J[15] = 0;
var oa = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, pa = Object.prototype.hasOwnProperty, qa = {}, ra = {};
function sa(a) {
  if (pa.call(ra, a))
    return true;
  if (pa.call(qa, a))
    return false;
  if (oa.test(a))
    return ra[a] = true;
  qa[a] = true;
  return false;
}
function ta(a, b, c, d) {
  if (c !== null && c.type === 0)
    return false;
  switch (typeof b) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d)
        return false;
      if (c !== null)
        return !c.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return a !== "data-" && a !== "aria-";
    default:
      return false;
  }
}
function ua(a, b, c, d) {
  if (b === null || typeof b === "undefined" || ta(a, b, c, d))
    return true;
  if (d)
    return false;
  if (c !== null)
    switch (c.type) {
      case 3:
        return !b;
      case 4:
        return b === false;
      case 5:
        return isNaN(b);
      case 6:
        return isNaN(b) || 1 > b;
    }
  return false;
}
function M(a, b, c, d, f2, h, t) {
  this.acceptsBooleans = b === 2 || b === 3 || b === 4;
  this.attributeName = d;
  this.attributeNamespace = f2;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b;
  this.sanitizeURL = h;
  this.removeEmptyString = t;
}
var N = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  N[a] = new M(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b = a[0];
  N[b] = new M(b, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  N[a] = new M(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  N[a] = new M(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  N[a] = new M(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  N[a] = new M(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  N[a] = new M(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  N[a] = new M(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  N[a] = new M(a, 5, false, a.toLowerCase(), null, false, false);
});
var va = /[\-:]([a-z])/g;
function wa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b = a.replace(va, wa);
  N[b] = new M(b, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b = a.replace(va, wa);
  N[b] = new M(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b = a.replace(va, wa);
  N[b] = new M(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  N[a] = new M(a, 1, false, a.toLowerCase(), null, false, false);
});
N.xlinkHref = new M("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  N[a] = new M(a, 1, false, a.toLowerCase(), null, true, true);
});
var xa = /["'&<>]/;
function O(a) {
  if (typeof a === "boolean" || typeof a === "number")
    return "" + a;
  a = "" + a;
  var b = xa.exec(a);
  if (b) {
    var c = "", d, f2 = 0;
    for (d = b.index; d < a.length; d++) {
      switch (a.charCodeAt(d)) {
        case 34:
          b = "&quot;";
          break;
        case 38:
          b = "&amp;";
          break;
        case 39:
          b = "&#x27;";
          break;
        case 60:
          b = "&lt;";
          break;
        case 62:
          b = "&gt;";
          break;
        default:
          continue;
      }
      f2 !== d && (c += a.substring(f2, d));
      f2 = d + 1;
      c += b;
    }
    a = f2 !== d ? c + a.substring(f2, d) : c;
  }
  return a;
}
function ya(a, b) {
  var c = N.hasOwnProperty(a) ? N[a] : null;
  var d;
  if (d = a !== "style")
    d = c !== null ? c.type === 0 : !(2 < a.length) || a[0] !== "o" && a[0] !== "O" || a[1] !== "n" && a[1] !== "N" ? false : true;
  if (d || ua(a, b, c, false))
    return "";
  if (c !== null) {
    a = c.attributeName;
    d = c.type;
    if (d === 3 || d === 4 && b === true)
      return a + '=""';
    c.sanitizeURL && (b = "" + b);
    return a + '="' + (O(b) + '"');
  }
  return sa(a) ? a + '="' + (O(b) + '"') : "";
}
function za(a, b) {
  return a === b && (a !== 0 || 1 / a === 1 / b) || a !== a && b !== b;
}
var Aa = typeof Object.is === "function" ? Object.is : za, P = null, Q = null, R = null, S = false, T = false, U = null, V = 0;
function W() {
  if (P === null)
    throw Error(p(321));
  return P;
}
function Ba() {
  if (0 < V)
    throw Error(p(312));
  return {
    memoizedState: null,
    queue: null,
    next: null
  };
}
function Ca() {
  R === null ? Q === null ? (S = false, Q = R = Ba()) : (S = true, R = Q) : R.next === null ? (S = false, R = R.next = Ba()) : (S = true, R = R.next);
  return R;
}
function Da(a, b, c, d) {
  for (; T; )
    T = false, V += 1, R = null, c = a(b, d);
  Ea();
  return c;
}
function Ea() {
  P = null;
  T = false;
  Q = null;
  V = 0;
  R = U = null;
}
function Fa(a, b) {
  return typeof b === "function" ? b(a) : b;
}
function Ga(a, b, c) {
  P = W();
  R = Ca();
  if (S) {
    var d = R.queue;
    b = d.dispatch;
    if (U !== null && (c = U.get(d), c !== void 0)) {
      U.delete(d);
      d = R.memoizedState;
      do
        d = a(d, c.action), c = c.next;
      while (c !== null);
      R.memoizedState = d;
      return [d, b];
    }
    return [R.memoizedState, b];
  }
  a = a === Fa ? typeof b === "function" ? b() : b : c !== void 0 ? c(b) : b;
  R.memoizedState = a;
  a = R.queue = {
    last: null,
    dispatch: null
  };
  a = a.dispatch = Ha.bind(null, P, a);
  return [R.memoizedState, a];
}
function Ia(a, b) {
  P = W();
  R = Ca();
  b = b === void 0 ? null : b;
  if (R !== null) {
    var c = R.memoizedState;
    if (c !== null && b !== null) {
      var d = c[1];
      a:
        if (d === null)
          d = false;
        else {
          for (var f2 = 0; f2 < d.length && f2 < b.length; f2++)
            if (!Aa(b[f2], d[f2])) {
              d = false;
              break a;
            }
          d = true;
        }
      if (d)
        return c[0];
    }
  }
  a = a();
  R.memoizedState = [a, b];
  return a;
}
function Ha(a, b, c) {
  if (!(25 > V))
    throw Error(p(301));
  if (a === P)
    if (T = true, a = {
      action: c,
      next: null
    }, U === null && (U = new Map()), c = U.get(b), c === void 0)
      U.set(b, a);
    else {
      for (b = c; b.next !== null; )
        b = b.next;
      b.next = a;
    }
}
function Ja() {
}
var X = null, Ka = {
  readContext: function(a) {
    var b = X.threadID;
    I(a, b);
    return a[b];
  },
  useContext: function(a) {
    W();
    var b = X.threadID;
    I(a, b);
    return a[b];
  },
  useMemo: Ia,
  useReducer: Ga,
  useRef: function(a) {
    P = W();
    R = Ca();
    var b = R.memoizedState;
    return b === null ? (a = {
      current: a
    }, R.memoizedState = a) : b;
  },
  useState: function(a) {
    return Ga(Fa, a);
  },
  useLayoutEffect: function() {
  },
  useCallback: function(a, b) {
    return Ia(function() {
      return a;
    }, b);
  },
  useImperativeHandle: Ja,
  useEffect: Ja,
  useDebugValue: Ja,
  useDeferredValue: function(a) {
    W();
    return a;
  },
  useTransition: function() {
    W();
    return [function(a) {
      a();
    }, false];
  },
  useOpaqueIdentifier: function() {
    return (X.identifierPrefix || "") + "R:" + (X.uniqueID++).toString(36);
  },
  useMutableSource: function(a, b) {
    W();
    return b(a._source);
  }
}, La = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg"
};
function Ma(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
var Na = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
}, Oa = l({
  menuitem: true
}, Na), Y = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, Pa = ["Webkit", "ms", "Moz", "O"];
Object.keys(Y).forEach(function(a) {
  Pa.forEach(function(b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    Y[b] = Y[a];
  });
});
var Qa = /([A-Z])/g, Ra = /^ms-/, Z = m.Children.toArray, Sa = la.ReactCurrentDispatcher, Ta = {
  listing: true,
  pre: true,
  textarea: true
}, Ua = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Va = {}, Wa = {};
function Xa(a) {
  if (a === void 0 || a === null)
    return a;
  var b = "";
  m.Children.forEach(a, function(a2) {
    a2 != null && (b += a2);
  });
  return b;
}
var Ya = Object.prototype.hasOwnProperty, Za = {
  children: null,
  dangerouslySetInnerHTML: null,
  suppressContentEditableWarning: null,
  suppressHydrationWarning: null
};
function $a(a, b) {
  if (a === void 0)
    throw Error(p(152, F(b) || "Component"));
}
function ab(a, b, c) {
  function d(d2, h2) {
    var e = h2.prototype && h2.prototype.isReactComponent, f3 = na(h2, b, c, e), t = [], g2 = false, n2 = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function() {
        if (t === null)
          return null;
      },
      enqueueReplaceState: function(a2, c2) {
        g2 = true;
        t = [c2];
      },
      enqueueSetState: function(a2, c2) {
        if (t === null)
          return null;
        t.push(c2);
      }
    };
    if (e) {
      if (e = new h2(d2.props, f3, n2), typeof h2.getDerivedStateFromProps === "function") {
        var k = h2.getDerivedStateFromProps.call(null, d2.props, e.state);
        k != null && (e.state = l({}, e.state, k));
      }
    } else if (P = {}, e = h2(d2.props, f3, n2), e = Da(h2, d2.props, e, f3), e == null || e.render == null) {
      a = e;
      $a(a, h2);
      return;
    }
    e.props = d2.props;
    e.context = f3;
    e.updater = n2;
    n2 = e.state;
    n2 === void 0 && (e.state = n2 = null);
    if (typeof e.UNSAFE_componentWillMount === "function" || typeof e.componentWillMount === "function")
      if (typeof e.componentWillMount === "function" && typeof h2.getDerivedStateFromProps !== "function" && e.componentWillMount(), typeof e.UNSAFE_componentWillMount === "function" && typeof h2.getDerivedStateFromProps !== "function" && e.UNSAFE_componentWillMount(), t.length) {
        n2 = t;
        var v = g2;
        t = null;
        g2 = false;
        if (v && n2.length === 1)
          e.state = n2[0];
        else {
          k = v ? n2[0] : e.state;
          var H = true;
          for (v = v ? 1 : 0; v < n2.length; v++) {
            var x = n2[v];
            x = typeof x === "function" ? x.call(e, k, d2.props, f3) : x;
            x != null && (H ? (H = false, k = l({}, k, x)) : l(k, x));
          }
          e.state = k;
        }
      } else
        t = null;
    a = e.render();
    $a(a, h2);
    if (typeof e.getChildContext === "function" && (d2 = h2.childContextTypes, typeof d2 === "object")) {
      var y = e.getChildContext();
      for (var A in y)
        if (!(A in d2))
          throw Error(p(108, F(h2) || "Unknown", A));
    }
    y && (b = l({}, b, y));
  }
  for (; m.isValidElement(a); ) {
    var f2 = a, h = f2.type;
    if (typeof h !== "function")
      break;
    d(f2, h);
  }
  return {
    child: a,
    context: b
  };
}
var bb = function() {
  function a(a2, b2, f2) {
    m.isValidElement(a2) ? a2.type !== r ? a2 = [a2] : (a2 = a2.props.children, a2 = m.isValidElement(a2) ? [a2] : Z(a2)) : a2 = Z(a2);
    a2 = {
      type: null,
      domNamespace: La.html,
      children: a2,
      childIndex: 0,
      context: ma,
      footer: ""
    };
    var c = J[0];
    if (c === 0) {
      var d = J;
      c = d.length;
      var g2 = 2 * c;
      if (!(65536 >= g2))
        throw Error(p(304));
      var e = new Uint16Array(g2);
      e.set(d);
      J = e;
      J[0] = c + 1;
      for (d = c; d < g2 - 1; d++)
        J[d] = d + 1;
      J[g2 - 1] = 0;
    } else
      J[0] = J[c];
    this.threadID = c;
    this.stack = [a2];
    this.exhausted = false;
    this.currentSelectValue = null;
    this.previousWasTextNode = false;
    this.makeStaticMarkup = b2;
    this.suspenseDepth = 0;
    this.contextIndex = -1;
    this.contextStack = [];
    this.contextValueStack = [];
    this.uniqueID = 0;
    this.identifierPrefix = f2 && f2.identifierPrefix || "";
  }
  var b = a.prototype;
  b.destroy = function() {
    if (!this.exhausted) {
      this.exhausted = true;
      this.clearProviders();
      var a2 = this.threadID;
      J[a2] = J[0];
      J[0] = a2;
    }
  };
  b.pushProvider = function(a2) {
    var b2 = ++this.contextIndex, c = a2.type._context, h = this.threadID;
    I(c, h);
    var t = c[h];
    this.contextStack[b2] = c;
    this.contextValueStack[b2] = t;
    c[h] = a2.props.value;
  };
  b.popProvider = function() {
    var a2 = this.contextIndex, b2 = this.contextStack[a2], f2 = this.contextValueStack[a2];
    this.contextStack[a2] = null;
    this.contextValueStack[a2] = null;
    this.contextIndex--;
    b2[this.threadID] = f2;
  };
  b.clearProviders = function() {
    for (var a2 = this.contextIndex; 0 <= a2; a2--)
      this.contextStack[a2][this.threadID] = this.contextValueStack[a2];
  };
  b.read = function(a2) {
    if (this.exhausted)
      return null;
    var b2 = X;
    X = this;
    var c = Sa.current;
    Sa.current = Ka;
    try {
      for (var h = [""], t = false; h[0].length < a2; ) {
        if (this.stack.length === 0) {
          this.exhausted = true;
          var g2 = this.threadID;
          J[g2] = J[0];
          J[0] = g2;
          break;
        }
        var e = this.stack[this.stack.length - 1];
        if (t || e.childIndex >= e.children.length) {
          var L = e.footer;
          L !== "" && (this.previousWasTextNode = false);
          this.stack.pop();
          if (e.type === "select")
            this.currentSelectValue = null;
          else if (e.type != null && e.type.type != null && e.type.type.$$typeof === B)
            this.popProvider(e.type);
          else if (e.type === D) {
            this.suspenseDepth--;
            var G = h.pop();
            if (t) {
              t = false;
              var C = e.fallbackFrame;
              if (!C)
                throw Error(p(303));
              this.stack.push(C);
              h[this.suspenseDepth] += "<!--$!-->";
              continue;
            } else
              h[this.suspenseDepth] += G;
          }
          h[this.suspenseDepth] += L;
        } else {
          var n2 = e.children[e.childIndex++], k = "";
          try {
            k += this.render(n2, e.context, e.domNamespace);
          } catch (v) {
            if (v != null && typeof v.then === "function")
              throw Error(p(294));
            throw v;
          } finally {
          }
          h.length <= this.suspenseDepth && h.push("");
          h[this.suspenseDepth] += k;
        }
      }
      return h[0];
    } finally {
      Sa.current = c, X = b2, Ea();
    }
  };
  b.render = function(a2, b2, f2) {
    if (typeof a2 === "string" || typeof a2 === "number") {
      f2 = "" + a2;
      if (f2 === "")
        return "";
      if (this.makeStaticMarkup)
        return O(f2);
      if (this.previousWasTextNode)
        return "<!-- -->" + O(f2);
      this.previousWasTextNode = true;
      return O(f2);
    }
    b2 = ab(a2, b2, this.threadID);
    a2 = b2.child;
    b2 = b2.context;
    if (a2 === null || a2 === false)
      return "";
    if (!m.isValidElement(a2)) {
      if (a2 != null && a2.$$typeof != null) {
        f2 = a2.$$typeof;
        if (f2 === q)
          throw Error(p(257));
        throw Error(p(258, f2.toString()));
      }
      a2 = Z(a2);
      this.stack.push({
        type: null,
        domNamespace: f2,
        children: a2,
        childIndex: 0,
        context: b2,
        footer: ""
      });
      return "";
    }
    var c = a2.type;
    if (typeof c === "string")
      return this.renderDOM(a2, b2, f2);
    switch (c) {
      case ka:
      case ja:
      case u:
      case z:
      case ca:
      case r:
        return a2 = Z(a2.props.children), this.stack.push({
          type: null,
          domNamespace: f2,
          children: a2,
          childIndex: 0,
          context: b2,
          footer: ""
        }), "";
      case D:
        throw Error(p(294));
      case ia:
        throw Error(p(343));
    }
    if (typeof c === "object" && c !== null)
      switch (c.$$typeof) {
        case ba:
          P = {};
          var d = c.render(a2.props, a2.ref);
          d = Da(c.render, a2.props, d, a2.ref);
          d = Z(d);
          this.stack.push({
            type: null,
            domNamespace: f2,
            children: d,
            childIndex: 0,
            context: b2,
            footer: ""
          });
          return "";
        case da:
          return a2 = [m.createElement(c.type, l({
            ref: a2.ref
          }, a2.props))], this.stack.push({
            type: null,
            domNamespace: f2,
            children: a2,
            childIndex: 0,
            context: b2,
            footer: ""
          }), "";
        case B:
          return c = Z(a2.props.children), f2 = {
            type: a2,
            domNamespace: f2,
            children: c,
            childIndex: 0,
            context: b2,
            footer: ""
          }, this.pushProvider(a2), this.stack.push(f2), "";
        case aa:
          c = a2.type;
          d = a2.props;
          var g2 = this.threadID;
          I(c, g2);
          c = Z(d.children(c[g2]));
          this.stack.push({
            type: a2,
            domNamespace: f2,
            children: c,
            childIndex: 0,
            context: b2,
            footer: ""
          });
          return "";
        case ha:
          throw Error(p(338));
        case ea:
          return c = a2.type, d = c._init, c = d(c._payload), a2 = [m.createElement(c, l({
            ref: a2.ref
          }, a2.props))], this.stack.push({
            type: null,
            domNamespace: f2,
            children: a2,
            childIndex: 0,
            context: b2,
            footer: ""
          }), "";
      }
    throw Error(p(130, c == null ? c : typeof c, ""));
  };
  b.renderDOM = function(a2, b2, f2) {
    var c = a2.type.toLowerCase();
    if (!Va.hasOwnProperty(c)) {
      if (!Ua.test(c))
        throw Error(p(65, c));
      Va[c] = true;
    }
    var d = a2.props;
    if (c === "input")
      d = l({
        type: void 0
      }, d, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: d.value != null ? d.value : d.defaultValue,
        checked: d.checked != null ? d.checked : d.defaultChecked
      });
    else if (c === "textarea") {
      var g2 = d.value;
      if (g2 == null) {
        g2 = d.defaultValue;
        var e = d.children;
        if (e != null) {
          if (g2 != null)
            throw Error(p(92));
          if (Array.isArray(e)) {
            if (!(1 >= e.length))
              throw Error(p(93));
            e = e[0];
          }
          g2 = "" + e;
        }
        g2 == null && (g2 = "");
      }
      d = l({}, d, {
        value: void 0,
        children: "" + g2
      });
    } else if (c === "select")
      this.currentSelectValue = d.value != null ? d.value : d.defaultValue, d = l({}, d, {
        value: void 0
      });
    else if (c === "option") {
      e = this.currentSelectValue;
      var L = Xa(d.children);
      if (e != null) {
        var G = d.value != null ? d.value + "" : L;
        g2 = false;
        if (Array.isArray(e))
          for (var C = 0; C < e.length; C++) {
            if ("" + e[C] === G) {
              g2 = true;
              break;
            }
          }
        else
          g2 = "" + e === G;
        d = l({
          selected: void 0,
          children: void 0
        }, d, {
          selected: g2,
          children: L
        });
      }
    }
    if (g2 = d) {
      if (Oa[c] && (g2.children != null || g2.dangerouslySetInnerHTML != null))
        throw Error(p(137, c));
      if (g2.dangerouslySetInnerHTML != null) {
        if (g2.children != null)
          throw Error(p(60));
        if (!(typeof g2.dangerouslySetInnerHTML === "object" && "__html" in g2.dangerouslySetInnerHTML))
          throw Error(p(61));
      }
      if (g2.style != null && typeof g2.style !== "object")
        throw Error(p(62));
    }
    g2 = d;
    e = this.makeStaticMarkup;
    L = this.stack.length === 1;
    G = "<" + a2.type;
    b:
      if (c.indexOf("-") === -1)
        C = typeof g2.is === "string";
      else
        switch (c) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            C = false;
            break b;
          default:
            C = true;
        }
    for (w in g2)
      if (Ya.call(g2, w)) {
        var n2 = g2[w];
        if (n2 != null) {
          if (w === "style") {
            var k = void 0, v = "", H = "";
            for (k in n2)
              if (n2.hasOwnProperty(k)) {
                var x = k.indexOf("--") === 0, y = n2[k];
                if (y != null) {
                  if (x)
                    var A = k;
                  else if (A = k, Wa.hasOwnProperty(A))
                    A = Wa[A];
                  else {
                    var cb = A.replace(Qa, "-$1").toLowerCase().replace(Ra, "-ms-");
                    A = Wa[A] = cb;
                  }
                  v += H + A + ":";
                  H = k;
                  x = y == null || typeof y === "boolean" || y === "" ? "" : x || typeof y !== "number" || y === 0 || Y.hasOwnProperty(H) && Y[H] ? ("" + y).trim() : y + "px";
                  v += x;
                  H = ";";
                }
              }
            n2 = v || null;
          }
          k = null;
          C ? Za.hasOwnProperty(w) || (k = w, k = sa(k) && n2 != null ? k + '="' + (O(n2) + '"') : "") : k = ya(w, n2);
          k && (G += " " + k);
        }
      }
    e || L && (G += ' data-reactroot=""');
    var w = G;
    g2 = "";
    Na.hasOwnProperty(c) ? w += "/>" : (w += ">", g2 = "</" + a2.type + ">");
    a: {
      e = d.dangerouslySetInnerHTML;
      if (e != null) {
        if (e.__html != null) {
          e = e.__html;
          break a;
        }
      } else if (e = d.children, typeof e === "string" || typeof e === "number") {
        e = O(e);
        break a;
      }
      e = null;
    }
    e != null ? (d = [], Ta.hasOwnProperty(c) && e.charAt(0) === "\n" && (w += "\n"), w += e) : d = Z(d.children);
    a2 = a2.type;
    f2 = f2 == null || f2 === "http://www.w3.org/1999/xhtml" ? Ma(a2) : f2 === "http://www.w3.org/2000/svg" && a2 === "foreignObject" ? "http://www.w3.org/1999/xhtml" : f2;
    this.stack.push({
      domNamespace: f2,
      type: c,
      children: d,
      childIndex: 0,
      context: b2,
      footer: g2
    });
    this.previousWasTextNode = false;
    return w;
  };
  return a;
}();
reactDomServer_browser_production_min.renderToNodeStream = function() {
  throw Error(p(207));
};
reactDomServer_browser_production_min.renderToStaticMarkup = function(a, b) {
  a = new bb(a, true, b);
  try {
    return a.read(Infinity);
  } finally {
    a.destroy();
  }
};
reactDomServer_browser_production_min.renderToStaticNodeStream = function() {
  throw Error(p(208));
};
reactDomServer_browser_production_min.renderToString = function(a, b) {
  a = new bb(a, false, b);
  try {
    return a.read(Infinity);
  } finally {
    a.destroy();
  }
};
reactDomServer_browser_production_min.version = "17.0.2";
var rangeSort = function(r1, r2) {
  if (r1.offset === r2.offset) {
    return r2.length - r1.length;
  }
  return r1.offset - r2.offset;
};
var ORDERED_LIST_TYPES = ["1", "a", "i"];
({
  unstyled: React$a.createElement("p", null),
  paragraph: React$a.createElement("p", null),
  "header-one": React$a.createElement("h1", null),
  "header-two": React$a.createElement("h2", null),
  "header-three": React$a.createElement("h3", null),
  "header-four": React$a.createElement("h4", null),
  "header-five": React$a.createElement("h5", null),
  "header-six": React$a.createElement("h6", null),
  "code-block": React$a.createElement("pre", null),
  blockquote: React$a.createElement("blockquote", null),
  "unordered-list-item": {
    element: React$a.createElement("li", null),
    nest: React$a.createElement("ul", null)
  },
  "ordered-list-item": {
    element: React$a.createElement("li", null),
    nest: function nest(depth) {
      var type = ORDERED_LIST_TYPES[depth % 3];
      return React$a.createElement("ol", {
        type
      });
    }
  },
  media: React$a.createElement("figure", null),
  atomic: React$a.createElement("figure", null)
});
var immutable = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    var SLICE$0 = Array.prototype.slice;
    function createClass(ctor, superClass) {
      if (superClass) {
        ctor.prototype = Object.create(superClass.prototype);
      }
      ctor.prototype.constructor = ctor;
    }
    function Iterable(value) {
      return isIterable(value) ? value : Seq2(value);
    }
    createClass(KeyedIterable, Iterable);
    function KeyedIterable(value) {
      return isKeyed2(value) ? value : KeyedSeq2(value);
    }
    createClass(IndexedIterable, Iterable);
    function IndexedIterable(value) {
      return isIndexed2(value) ? value : IndexedSeq2(value);
    }
    createClass(SetIterable, Iterable);
    function SetIterable(value) {
      return isIterable(value) && !isAssociative2(value) ? value : SetSeq2(value);
    }
    function isIterable(maybeIterable) {
      return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
    }
    function isKeyed2(maybeKeyed) {
      return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
    }
    function isIndexed2(maybeIndexed) {
      return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
    }
    function isAssociative2(maybeAssociative) {
      return isKeyed2(maybeAssociative) || isIndexed2(maybeAssociative);
    }
    function isOrdered2(maybeOrdered) {
      return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
    }
    Iterable.isIterable = isIterable;
    Iterable.isKeyed = isKeyed2;
    Iterable.isIndexed = isIndexed2;
    Iterable.isAssociative = isAssociative2;
    Iterable.isOrdered = isOrdered2;
    Iterable.Keyed = KeyedIterable;
    Iterable.Indexed = IndexedIterable;
    Iterable.Set = SetIterable;
    var IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
    var IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
    var IS_INDEXED_SENTINEL = "@@__IMMUTABLE_INDEXED__@@";
    var IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
    var DELETE2 = "delete";
    var SHIFT2 = 5;
    var SIZE2 = 1 << SHIFT2;
    var MASK2 = SIZE2 - 1;
    var NOT_SET2 = {};
    var CHANGE_LENGTH = {
      value: false
    };
    var DID_ALTER = {
      value: false
    };
    function MakeRef2(ref) {
      ref.value = false;
      return ref;
    }
    function SetRef2(ref) {
      ref && (ref.value = true);
    }
    function OwnerID2() {
    }
    function arrCopy2(arr, offset) {
      offset = offset || 0;
      var len = Math.max(0, arr.length - offset);
      var newArr = new Array(len);
      for (var ii = 0; ii < len; ii++) {
        newArr[ii] = arr[ii + offset];
      }
      return newArr;
    }
    function ensureSize2(iter) {
      if (iter.size === void 0) {
        iter.size = iter.__iterate(returnTrue3);
      }
      return iter.size;
    }
    function wrapIndex2(iter, index) {
      if (typeof index !== "number") {
        var uint32Index = index >>> 0;
        if ("" + uint32Index !== index || uint32Index === 4294967295) {
          return NaN;
        }
        index = uint32Index;
      }
      return index < 0 ? ensureSize2(iter) + index : index;
    }
    function returnTrue3() {
      return true;
    }
    function wholeSlice2(begin, end, size) {
      return (begin === 0 || size !== void 0 && begin <= -size) && (end === void 0 || size !== void 0 && end >= size);
    }
    function resolveBegin2(begin, size) {
      return resolveIndex2(begin, size, 0);
    }
    function resolveEnd2(end, size) {
      return resolveIndex2(end, size, size);
    }
    function resolveIndex2(index, size, defaultIndex) {
      return index === void 0 ? defaultIndex : index < 0 ? Math.max(0, size + index) : size === void 0 ? index : Math.min(size, index);
    }
    var ITERATE_KEYS2 = 0;
    var ITERATE_VALUES2 = 1;
    var ITERATE_ENTRIES2 = 2;
    var REAL_ITERATOR_SYMBOL2 = typeof Symbol === "function" && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL2 = "@@iterator";
    var ITERATOR_SYMBOL2 = REAL_ITERATOR_SYMBOL2 || FAUX_ITERATOR_SYMBOL2;
    function Iterator3(next) {
      this.next = next;
    }
    Iterator3.prototype.toString = function() {
      return "[Iterator]";
    };
    Iterator3.KEYS = ITERATE_KEYS2;
    Iterator3.VALUES = ITERATE_VALUES2;
    Iterator3.ENTRIES = ITERATE_ENTRIES2;
    Iterator3.prototype.inspect = Iterator3.prototype.toSource = function() {
      return this.toString();
    };
    Iterator3.prototype[ITERATOR_SYMBOL2] = function() {
      return this;
    };
    function iteratorValue2(type, k, v, iteratorResult) {
      var value = type === 0 ? k : type === 1 ? v : [k, v];
      iteratorResult ? iteratorResult.value = value : iteratorResult = {
        value,
        done: false
      };
      return iteratorResult;
    }
    function iteratorDone2() {
      return {
        value: void 0,
        done: true
      };
    }
    function hasIterator2(maybeIterable) {
      return !!getIteratorFn2(maybeIterable);
    }
    function isIterator2(maybeIterator) {
      return maybeIterator && typeof maybeIterator.next === "function";
    }
    function getIterator2(iterable) {
      var iteratorFn = getIteratorFn2(iterable);
      return iteratorFn && iteratorFn.call(iterable);
    }
    function getIteratorFn2(iterable) {
      var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL2 && iterable[REAL_ITERATOR_SYMBOL2] || iterable[FAUX_ITERATOR_SYMBOL2]);
      if (typeof iteratorFn === "function") {
        return iteratorFn;
      }
    }
    function isArrayLike2(value) {
      return value && typeof value.length === "number";
    }
    createClass(Seq2, Iterable);
    function Seq2(value) {
      return value === null || value === void 0 ? emptySequence2() : isIterable(value) ? value.toSeq() : seqFromValue2(value);
    }
    Seq2.of = function() {
      return Seq2(arguments);
    };
    Seq2.prototype.toSeq = function() {
      return this;
    };
    Seq2.prototype.toString = function() {
      return this.__toString("Seq {", "}");
    };
    Seq2.prototype.cacheResult = function() {
      if (!this._cache && this.__iterateUncached) {
        this._cache = this.entrySeq().toArray();
        this.size = this._cache.length;
      }
      return this;
    };
    Seq2.prototype.__iterate = function(fn, reverse3) {
      return seqIterate(this, fn, reverse3, true);
    };
    Seq2.prototype.__iterator = function(type, reverse3) {
      return seqIterator(this, type, reverse3, true);
    };
    createClass(KeyedSeq2, Seq2);
    function KeyedSeq2(value) {
      return value === null || value === void 0 ? emptySequence2().toKeyedSeq() : isIterable(value) ? isKeyed2(value) ? value.toSeq() : value.fromEntrySeq() : keyedSeqFromValue2(value);
    }
    KeyedSeq2.prototype.toKeyedSeq = function() {
      return this;
    };
    createClass(IndexedSeq2, Seq2);
    function IndexedSeq2(value) {
      return value === null || value === void 0 ? emptySequence2() : !isIterable(value) ? indexedSeqFromValue2(value) : isKeyed2(value) ? value.entrySeq() : value.toIndexedSeq();
    }
    IndexedSeq2.of = function() {
      return IndexedSeq2(arguments);
    };
    IndexedSeq2.prototype.toIndexedSeq = function() {
      return this;
    };
    IndexedSeq2.prototype.toString = function() {
      return this.__toString("Seq [", "]");
    };
    IndexedSeq2.prototype.__iterate = function(fn, reverse3) {
      return seqIterate(this, fn, reverse3, false);
    };
    IndexedSeq2.prototype.__iterator = function(type, reverse3) {
      return seqIterator(this, type, reverse3, false);
    };
    createClass(SetSeq2, Seq2);
    function SetSeq2(value) {
      return (value === null || value === void 0 ? emptySequence2() : !isIterable(value) ? indexedSeqFromValue2(value) : isKeyed2(value) ? value.entrySeq() : value).toSetSeq();
    }
    SetSeq2.of = function() {
      return SetSeq2(arguments);
    };
    SetSeq2.prototype.toSetSeq = function() {
      return this;
    };
    Seq2.isSeq = isSeq2;
    Seq2.Keyed = KeyedSeq2;
    Seq2.Set = SetSeq2;
    Seq2.Indexed = IndexedSeq2;
    var IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
    Seq2.prototype[IS_SEQ_SENTINEL] = true;
    createClass(ArraySeq2, IndexedSeq2);
    function ArraySeq2(array) {
      this._array = array;
      this.size = array.length;
    }
    ArraySeq2.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._array[wrapIndex2(this, index)] : notSetValue;
    };
    ArraySeq2.prototype.__iterate = function(fn, reverse3) {
      var array = this._array;
      var maxIndex = array.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(array[reverse3 ? maxIndex - ii : ii], ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };
    ArraySeq2.prototype.__iterator = function(type, reverse3) {
      var array = this._array;
      var maxIndex = array.length - 1;
      var ii = 0;
      return new Iterator3(function() {
        return ii > maxIndex ? iteratorDone2() : iteratorValue2(type, ii, array[reverse3 ? maxIndex - ii++ : ii++]);
      });
    };
    createClass(ObjectSeq2, KeyedSeq2);
    function ObjectSeq2(object) {
      var keys3 = Object.keys(object);
      this._object = object;
      this._keys = keys3;
      this.size = keys3.length;
    }
    ObjectSeq2.prototype.get = function(key, notSetValue) {
      if (notSetValue !== void 0 && !this.has(key)) {
        return notSetValue;
      }
      return this._object[key];
    };
    ObjectSeq2.prototype.has = function(key) {
      return this._object.hasOwnProperty(key);
    };
    ObjectSeq2.prototype.__iterate = function(fn, reverse3) {
      var object = this._object;
      var keys3 = this._keys;
      var maxIndex = keys3.length - 1;
      for (var ii = 0; ii <= maxIndex; ii++) {
        var key = keys3[reverse3 ? maxIndex - ii : ii];
        if (fn(object[key], key, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };
    ObjectSeq2.prototype.__iterator = function(type, reverse3) {
      var object = this._object;
      var keys3 = this._keys;
      var maxIndex = keys3.length - 1;
      var ii = 0;
      return new Iterator3(function() {
        var key = keys3[reverse3 ? maxIndex - ii : ii];
        return ii++ > maxIndex ? iteratorDone2() : iteratorValue2(type, key, object[key]);
      });
    };
    ObjectSeq2.prototype[IS_ORDERED_SENTINEL] = true;
    createClass(IterableSeq, IndexedSeq2);
    function IterableSeq(iterable) {
      this._iterable = iterable;
      this.size = iterable.length || iterable.size;
    }
    IterableSeq.prototype.__iterateUncached = function(fn, reverse3) {
      if (reverse3) {
        return this.cacheResult().__iterate(fn, reverse3);
      }
      var iterable = this._iterable;
      var iterator = getIterator2(iterable);
      var iterations = 0;
      if (isIterator2(iterator)) {
        var step;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
      }
      return iterations;
    };
    IterableSeq.prototype.__iteratorUncached = function(type, reverse3) {
      if (reverse3) {
        return this.cacheResult().__iterator(type, reverse3);
      }
      var iterable = this._iterable;
      var iterator = getIterator2(iterable);
      if (!isIterator2(iterator)) {
        return new Iterator3(iteratorDone2);
      }
      var iterations = 0;
      return new Iterator3(function() {
        var step = iterator.next();
        return step.done ? step : iteratorValue2(type, iterations++, step.value);
      });
    };
    createClass(IteratorSeq, IndexedSeq2);
    function IteratorSeq(iterator) {
      this._iterator = iterator;
      this._iteratorCache = [];
    }
    IteratorSeq.prototype.__iterateUncached = function(fn, reverse3) {
      if (reverse3) {
        return this.cacheResult().__iterate(fn, reverse3);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      while (iterations < cache.length) {
        if (fn(cache[iterations], iterations++, this) === false) {
          return iterations;
        }
      }
      var step;
      while (!(step = iterator.next()).done) {
        var val = step.value;
        cache[iterations] = val;
        if (fn(val, iterations++, this) === false) {
          break;
        }
      }
      return iterations;
    };
    IteratorSeq.prototype.__iteratorUncached = function(type, reverse3) {
      if (reverse3) {
        return this.cacheResult().__iterator(type, reverse3);
      }
      var iterator = this._iterator;
      var cache = this._iteratorCache;
      var iterations = 0;
      return new Iterator3(function() {
        if (iterations >= cache.length) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          cache[iterations] = step.value;
        }
        return iteratorValue2(type, iterations, cache[iterations++]);
      });
    };
    function isSeq2(maybeSeq) {
      return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
    }
    var EMPTY_SEQ2;
    function emptySequence2() {
      return EMPTY_SEQ2 || (EMPTY_SEQ2 = new ArraySeq2([]));
    }
    function keyedSeqFromValue2(value) {
      var seq = Array.isArray(value) ? new ArraySeq2(value).fromEntrySeq() : isIterator2(value) ? new IteratorSeq(value).fromEntrySeq() : hasIterator2(value) ? new IterableSeq(value).fromEntrySeq() : typeof value === "object" ? new ObjectSeq2(value) : void 0;
      if (!seq) {
        throw new TypeError("Expected Array or iterable object of [k, v] entries, or keyed object: " + value);
      }
      return seq;
    }
    function indexedSeqFromValue2(value) {
      var seq = maybeIndexedSeqFromValue2(value);
      if (!seq) {
        throw new TypeError("Expected Array or iterable object of values: " + value);
      }
      return seq;
    }
    function seqFromValue2(value) {
      var seq = maybeIndexedSeqFromValue2(value) || typeof value === "object" && new ObjectSeq2(value);
      if (!seq) {
        throw new TypeError("Expected Array or iterable object of values, or keyed object: " + value);
      }
      return seq;
    }
    function maybeIndexedSeqFromValue2(value) {
      return isArrayLike2(value) ? new ArraySeq2(value) : isIterator2(value) ? new IteratorSeq(value) : hasIterator2(value) ? new IterableSeq(value) : void 0;
    }
    function seqIterate(seq, fn, reverse3, useKeys) {
      var cache = seq._cache;
      if (cache) {
        var maxIndex = cache.length - 1;
        for (var ii = 0; ii <= maxIndex; ii++) {
          var entry = cache[reverse3 ? maxIndex - ii : ii];
          if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
            return ii + 1;
          }
        }
        return ii;
      }
      return seq.__iterateUncached(fn, reverse3);
    }
    function seqIterator(seq, type, reverse3, useKeys) {
      var cache = seq._cache;
      if (cache) {
        var maxIndex = cache.length - 1;
        var ii = 0;
        return new Iterator3(function() {
          var entry = cache[reverse3 ? maxIndex - ii : ii];
          return ii++ > maxIndex ? iteratorDone2() : iteratorValue2(type, useKeys ? entry[0] : ii - 1, entry[1]);
        });
      }
      return seq.__iteratorUncached(type, reverse3);
    }
    function fromJS2(json, converter2) {
      return converter2 ? fromJSWith(converter2, json, "", {
        "": json
      }) : fromJSDefault(json);
    }
    function fromJSWith(converter2, json, key, parentJSON) {
      if (Array.isArray(json)) {
        return converter2.call(parentJSON, key, IndexedSeq2(json).map(function(v, k) {
          return fromJSWith(converter2, v, k, json);
        }));
      }
      if (isPlainObj(json)) {
        return converter2.call(parentJSON, key, KeyedSeq2(json).map(function(v, k) {
          return fromJSWith(converter2, v, k, json);
        }));
      }
      return json;
    }
    function fromJSDefault(json) {
      if (Array.isArray(json)) {
        return IndexedSeq2(json).map(fromJSDefault).toList();
      }
      if (isPlainObj(json)) {
        return KeyedSeq2(json).map(fromJSDefault).toMap();
      }
      return json;
    }
    function isPlainObj(value) {
      return value && (value.constructor === Object || value.constructor === void 0);
    }
    function is2(valueA, valueB) {
      if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
        return true;
      }
      if (!valueA || !valueB) {
        return false;
      }
      if (typeof valueA.valueOf === "function" && typeof valueB.valueOf === "function") {
        valueA = valueA.valueOf();
        valueB = valueB.valueOf();
        if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
          return true;
        }
        if (!valueA || !valueB) {
          return false;
        }
      }
      if (typeof valueA.equals === "function" && typeof valueB.equals === "function" && valueA.equals(valueB)) {
        return true;
      }
      return false;
    }
    function deepEqual2(a, b) {
      if (a === b) {
        return true;
      }
      if (!isIterable(b) || a.size !== void 0 && b.size !== void 0 && a.size !== b.size || a.__hash !== void 0 && b.__hash !== void 0 && a.__hash !== b.__hash || isKeyed2(a) !== isKeyed2(b) || isIndexed2(a) !== isIndexed2(b) || isOrdered2(a) !== isOrdered2(b)) {
        return false;
      }
      if (a.size === 0 && b.size === 0) {
        return true;
      }
      var notAssociative = !isAssociative2(a);
      if (isOrdered2(a)) {
        var entries2 = a.entries();
        return b.every(function(v, k) {
          var entry = entries2.next().value;
          return entry && is2(entry[1], v) && (notAssociative || is2(entry[0], k));
        }) && entries2.next().done;
      }
      var flipped = false;
      if (a.size === void 0) {
        if (b.size === void 0) {
          if (typeof a.cacheResult === "function") {
            a.cacheResult();
          }
        } else {
          flipped = true;
          var _ = a;
          a = b;
          b = _;
        }
      }
      var allEqual = true;
      var bSize = b.__iterate(function(v, k) {
        if (notAssociative ? !a.has(v) : flipped ? !is2(v, a.get(k, NOT_SET2)) : !is2(a.get(k, NOT_SET2), v)) {
          allEqual = false;
          return false;
        }
      });
      return allEqual && a.size === bSize;
    }
    createClass(Repeat2, IndexedSeq2);
    function Repeat2(value, times) {
      if (!(this instanceof Repeat2)) {
        return new Repeat2(value, times);
      }
      this._value = value;
      this.size = times === void 0 ? Infinity : Math.max(0, times);
      if (this.size === 0) {
        if (EMPTY_REPEAT) {
          return EMPTY_REPEAT;
        }
        EMPTY_REPEAT = this;
      }
    }
    Repeat2.prototype.toString = function() {
      if (this.size === 0) {
        return "Repeat []";
      }
      return "Repeat [ " + this._value + " " + this.size + " times ]";
    };
    Repeat2.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._value : notSetValue;
    };
    Repeat2.prototype.includes = function(searchValue) {
      return is2(this._value, searchValue);
    };
    Repeat2.prototype.slice = function(begin, end) {
      var size = this.size;
      return wholeSlice2(begin, end, size) ? this : new Repeat2(this._value, resolveEnd2(end, size) - resolveBegin2(begin, size));
    };
    Repeat2.prototype.reverse = function() {
      return this;
    };
    Repeat2.prototype.indexOf = function(searchValue) {
      if (is2(this._value, searchValue)) {
        return 0;
      }
      return -1;
    };
    Repeat2.prototype.lastIndexOf = function(searchValue) {
      if (is2(this._value, searchValue)) {
        return this.size;
      }
      return -1;
    };
    Repeat2.prototype.__iterate = function(fn, reverse3) {
      for (var ii = 0; ii < this.size; ii++) {
        if (fn(this._value, ii, this) === false) {
          return ii + 1;
        }
      }
      return ii;
    };
    Repeat2.prototype.__iterator = function(type, reverse3) {
      var this$0 = this;
      var ii = 0;
      return new Iterator3(function() {
        return ii < this$0.size ? iteratorValue2(type, ii++, this$0._value) : iteratorDone2();
      });
    };
    Repeat2.prototype.equals = function(other) {
      return other instanceof Repeat2 ? is2(this._value, other._value) : deepEqual2(other);
    };
    var EMPTY_REPEAT;
    function invariant2(condition, error) {
      if (!condition)
        throw new Error(error);
    }
    createClass(Range2, IndexedSeq2);
    function Range2(start, end, step) {
      if (!(this instanceof Range2)) {
        return new Range2(start, end, step);
      }
      invariant2(step !== 0, "Cannot step a Range by 0");
      start = start || 0;
      if (end === void 0) {
        end = Infinity;
      }
      step = step === void 0 ? 1 : Math.abs(step);
      if (end < start) {
        step = -step;
      }
      this._start = start;
      this._end = end;
      this._step = step;
      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
      if (this.size === 0) {
        if (EMPTY_RANGE2) {
          return EMPTY_RANGE2;
        }
        EMPTY_RANGE2 = this;
      }
    }
    Range2.prototype.toString = function() {
      if (this.size === 0) {
        return "Range []";
      }
      return "Range [ " + this._start + "..." + this._end + (this._step > 1 ? " by " + this._step : "") + " ]";
    };
    Range2.prototype.get = function(index, notSetValue) {
      return this.has(index) ? this._start + wrapIndex2(this, index) * this._step : notSetValue;
    };
    Range2.prototype.includes = function(searchValue) {
      var possibleIndex = (searchValue - this._start) / this._step;
      return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
    };
    Range2.prototype.slice = function(begin, end) {
      if (wholeSlice2(begin, end, this.size)) {
        return this;
      }
      begin = resolveBegin2(begin, this.size);
      end = resolveEnd2(end, this.size);
      if (end <= begin) {
        return new Range2(0, 0);
      }
      return new Range2(this.get(begin, this._end), this.get(end, this._end), this._step);
    };
    Range2.prototype.indexOf = function(searchValue) {
      var offsetValue = searchValue - this._start;
      if (offsetValue % this._step === 0) {
        var index = offsetValue / this._step;
        if (index >= 0 && index < this.size) {
          return index;
        }
      }
      return -1;
    };
    Range2.prototype.lastIndexOf = function(searchValue) {
      return this.indexOf(searchValue);
    };
    Range2.prototype.__iterate = function(fn, reverse3) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse3 ? this._start + maxIndex * step : this._start;
      for (var ii = 0; ii <= maxIndex; ii++) {
        if (fn(value, ii, this) === false) {
          return ii + 1;
        }
        value += reverse3 ? -step : step;
      }
      return ii;
    };
    Range2.prototype.__iterator = function(type, reverse3) {
      var maxIndex = this.size - 1;
      var step = this._step;
      var value = reverse3 ? this._start + maxIndex * step : this._start;
      var ii = 0;
      return new Iterator3(function() {
        var v = value;
        value += reverse3 ? -step : step;
        return ii > maxIndex ? iteratorDone2() : iteratorValue2(type, ii++, v);
      });
    };
    Range2.prototype.equals = function(other) {
      return other instanceof Range2 ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual2(this, other);
    };
    var EMPTY_RANGE2;
    createClass(Collection3, Iterable);
    function Collection3() {
      throw TypeError("Abstract");
    }
    createClass(KeyedCollection2, Collection3);
    function KeyedCollection2() {
    }
    createClass(IndexedCollection2, Collection3);
    function IndexedCollection2() {
    }
    createClass(SetCollection2, Collection3);
    function SetCollection2() {
    }
    Collection3.Keyed = KeyedCollection2;
    Collection3.Indexed = IndexedCollection2;
    Collection3.Set = SetCollection2;
    var imul3 = typeof Math.imul === "function" && Math.imul(4294967295, 2) === -2 ? Math.imul : function imul4(a, b) {
      a = a | 0;
      b = b | 0;
      var c = a & 65535;
      var d = b & 65535;
      return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0;
    };
    function smi2(i32) {
      return i32 >>> 1 & 1073741824 | i32 & 3221225471;
    }
    function hash2(o) {
      if (o === false || o === null || o === void 0) {
        return 0;
      }
      if (typeof o.valueOf === "function") {
        o = o.valueOf();
        if (o === false || o === null || o === void 0) {
          return 0;
        }
      }
      if (o === true) {
        return 1;
      }
      var type = typeof o;
      if (type === "number") {
        var h = o | 0;
        if (h !== o) {
          h ^= o * 4294967295;
        }
        while (o > 4294967295) {
          o /= 4294967295;
          h ^= o;
        }
        return smi2(h);
      }
      if (type === "string") {
        return o.length > STRING_HASH_CACHE_MIN_STRLEN2 ? cachedHashString2(o) : hashString2(o);
      }
      if (typeof o.hashCode === "function") {
        return o.hashCode();
      }
      if (type === "object") {
        return hashJSObj2(o);
      }
      if (typeof o.toString === "function") {
        return hashString2(o.toString());
      }
      throw new Error("Value type " + type + " cannot be hashed.");
    }
    function cachedHashString2(string) {
      var hash3 = stringHashCache2[string];
      if (hash3 === void 0) {
        hash3 = hashString2(string);
        if (STRING_HASH_CACHE_SIZE2 === STRING_HASH_CACHE_MAX_SIZE2) {
          STRING_HASH_CACHE_SIZE2 = 0;
          stringHashCache2 = {};
        }
        STRING_HASH_CACHE_SIZE2++;
        stringHashCache2[string] = hash3;
      }
      return hash3;
    }
    function hashString2(string) {
      var hash3 = 0;
      for (var ii = 0; ii < string.length; ii++) {
        hash3 = 31 * hash3 + string.charCodeAt(ii) | 0;
      }
      return smi2(hash3);
    }
    function hashJSObj2(obj) {
      var hash3;
      if (usingWeakMap2) {
        hash3 = weakMap2.get(obj);
        if (hash3 !== void 0) {
          return hash3;
        }
      }
      hash3 = obj[UID_HASH_KEY2];
      if (hash3 !== void 0) {
        return hash3;
      }
      if (!canDefineProperty2) {
        hash3 = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY2];
        if (hash3 !== void 0) {
          return hash3;
        }
        hash3 = getIENodeHash2(obj);
        if (hash3 !== void 0) {
          return hash3;
        }
      }
      hash3 = ++objHashUID;
      if (objHashUID & 1073741824) {
        objHashUID = 0;
      }
      if (usingWeakMap2) {
        weakMap2.set(obj, hash3);
      } else if (isExtensible2 !== void 0 && isExtensible2(obj) === false) {
        throw new Error("Non-extensible objects are not allowed as keys.");
      } else if (canDefineProperty2) {
        Object.defineProperty(obj, UID_HASH_KEY2, {
          "enumerable": false,
          "configurable": false,
          "writable": false,
          "value": hash3
        });
      } else if (obj.propertyIsEnumerable !== void 0 && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
        obj.propertyIsEnumerable = function() {
          return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
        };
        obj.propertyIsEnumerable[UID_HASH_KEY2] = hash3;
      } else if (obj.nodeType !== void 0) {
        obj[UID_HASH_KEY2] = hash3;
      } else {
        throw new Error("Unable to set a non-enumerable property on object.");
      }
      return hash3;
    }
    var isExtensible2 = Object.isExtensible;
    var canDefineProperty2 = function() {
      try {
        Object.defineProperty({}, "@", {});
        return true;
      } catch (e) {
        return false;
      }
    }();
    function getIENodeHash2(node) {
      if (node && node.nodeType > 0) {
        switch (node.nodeType) {
          case 1:
            return node.uniqueID;
          case 9:
            return node.documentElement && node.documentElement.uniqueID;
        }
      }
    }
    var usingWeakMap2 = typeof WeakMap === "function";
    var weakMap2;
    if (usingWeakMap2) {
      weakMap2 = new WeakMap();
    }
    var objHashUID = 0;
    var UID_HASH_KEY2 = "__immutablehash__";
    if (typeof Symbol === "function") {
      UID_HASH_KEY2 = Symbol(UID_HASH_KEY2);
    }
    var STRING_HASH_CACHE_MIN_STRLEN2 = 16;
    var STRING_HASH_CACHE_MAX_SIZE2 = 255;
    var STRING_HASH_CACHE_SIZE2 = 0;
    var stringHashCache2 = {};
    function assertNotInfinite2(size) {
      invariant2(size !== Infinity, "Cannot perform this action with an infinite size.");
    }
    createClass(Map2, KeyedCollection2);
    function Map2(value) {
      return value === null || value === void 0 ? emptyMap2() : isMap2(value) && !isOrdered2(value) ? value : emptyMap2().withMutations(function(map2) {
        var iter = KeyedIterable(value);
        assertNotInfinite2(iter.size);
        iter.forEach(function(v, k) {
          return map2.set(k, v);
        });
      });
    }
    Map2.prototype.toString = function() {
      return this.__toString("Map {", "}");
    };
    Map2.prototype.get = function(k, notSetValue) {
      return this._root ? this._root.get(0, void 0, k, notSetValue) : notSetValue;
    };
    Map2.prototype.set = function(k, v) {
      return updateMap2(this, k, v);
    };
    Map2.prototype.setIn = function(keyPath, v) {
      return this.updateIn(keyPath, NOT_SET2, function() {
        return v;
      });
    };
    Map2.prototype.remove = function(k) {
      return updateMap2(this, k, NOT_SET2);
    };
    Map2.prototype.deleteIn = function(keyPath) {
      return this.updateIn(keyPath, function() {
        return NOT_SET2;
      });
    };
    Map2.prototype.update = function(k, notSetValue, updater) {
      return arguments.length === 1 ? k(this) : this.updateIn([k], notSetValue, updater);
    };
    Map2.prototype.updateIn = function(keyPath, notSetValue, updater) {
      if (!updater) {
        updater = notSetValue;
        notSetValue = void 0;
      }
      var updatedValue = updateInDeepMap(this, forceIterator(keyPath), notSetValue, updater);
      return updatedValue === NOT_SET2 ? void 0 : updatedValue;
    };
    Map2.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._root = null;
        this.__hash = void 0;
        this.__altered = true;
        return this;
      }
      return emptyMap2();
    };
    Map2.prototype.merge = function() {
      return mergeIntoMapWith(this, void 0, arguments);
    };
    Map2.prototype.mergeWith = function(merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, merger, iters);
    };
    Map2.prototype.mergeIn = function(keyPath) {
      var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(keyPath, emptyMap2(), function(m2) {
        return typeof m2.merge === "function" ? m2.merge.apply(m2, iters) : iters[iters.length - 1];
      });
    };
    Map2.prototype.mergeDeep = function() {
      return mergeIntoMapWith(this, deepMerger, arguments);
    };
    Map2.prototype.mergeDeepWith = function(merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoMapWith(this, deepMergerWith2(merger), iters);
    };
    Map2.prototype.mergeDeepIn = function(keyPath) {
      var iters = SLICE$0.call(arguments, 1);
      return this.updateIn(keyPath, emptyMap2(), function(m2) {
        return typeof m2.mergeDeep === "function" ? m2.mergeDeep.apply(m2, iters) : iters[iters.length - 1];
      });
    };
    Map2.prototype.sort = function(comparator) {
      return OrderedMap2(sortFactory2(this, comparator));
    };
    Map2.prototype.sortBy = function(mapper, comparator) {
      return OrderedMap2(sortFactory2(this, comparator, mapper));
    };
    Map2.prototype.withMutations = function(fn) {
      var mutable = this.asMutable();
      fn(mutable);
      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
    };
    Map2.prototype.asMutable = function() {
      return this.__ownerID ? this : this.__ensureOwner(new OwnerID2());
    };
    Map2.prototype.asImmutable = function() {
      return this.__ensureOwner();
    };
    Map2.prototype.wasAltered = function() {
      return this.__altered;
    };
    Map2.prototype.__iterator = function(type, reverse3) {
      return new MapIterator2(this, type, reverse3);
    };
    Map2.prototype.__iterate = function(fn, reverse3) {
      var this$0 = this;
      var iterations = 0;
      this._root && this._root.iterate(function(entry) {
        iterations++;
        return fn(entry[1], entry[0], this$0);
      }, reverse3);
      return iterations;
    };
    Map2.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeMap2(this.size, this._root, ownerID, this.__hash);
    };
    function isMap2(maybeMap3) {
      return !!(maybeMap3 && maybeMap3[IS_MAP_SENTINEL]);
    }
    Map2.isMap = isMap2;
    var IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
    var MapPrototype2 = Map2.prototype;
    MapPrototype2[IS_MAP_SENTINEL] = true;
    MapPrototype2[DELETE2] = MapPrototype2.remove;
    MapPrototype2.removeIn = MapPrototype2.deleteIn;
    function ArrayMapNode3(ownerID, entries2) {
      this.ownerID = ownerID;
      this.entries = entries2;
    }
    ArrayMapNode3.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries2 = this.entries;
      for (var ii = 0, len = entries2.length; ii < len; ii++) {
        if (is2(key, entries2[ii][0])) {
          return entries2[ii][1];
        }
      }
      return notSetValue;
    };
    ArrayMapNode3.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET2;
      var entries2 = this.entries;
      var idx = 0;
      for (var len = entries2.length; idx < len; idx++) {
        if (is2(key, entries2[idx][0])) {
          break;
        }
      }
      var exists = idx < len;
      if (exists ? entries2[idx][1] === value : removed) {
        return this;
      }
      SetRef2(didAlter);
      (removed || !exists) && SetRef2(didChangeSize);
      if (removed && entries2.length === 1) {
        return;
      }
      if (!exists && !removed && entries2.length >= MAX_ARRAY_MAP_SIZE2) {
        return createNodes2(ownerID, entries2, key, value);
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries2 : arrCopy2(entries2);
      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }
      if (isEditable) {
        this.entries = newEntries;
        return this;
      }
      return new ArrayMapNode3(ownerID, newEntries);
    };
    function BitmapIndexedNode3(ownerID, bitmap, nodes) {
      this.ownerID = ownerID;
      this.bitmap = bitmap;
      this.nodes = nodes;
    }
    BitmapIndexedNode3.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === void 0) {
        keyHash = hash2(key);
      }
      var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK2);
      var bitmap = this.bitmap;
      return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount2(bitmap & bit - 1)].get(shift + SHIFT2, keyHash, key, notSetValue);
    };
    BitmapIndexedNode3.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === void 0) {
        keyHash = hash2(key);
      }
      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK2;
      var bit = 1 << keyHashFrag;
      var bitmap = this.bitmap;
      var exists = (bitmap & bit) !== 0;
      if (!exists && value === NOT_SET2) {
        return this;
      }
      var idx = popCount2(bitmap & bit - 1);
      var nodes = this.nodes;
      var node = exists ? nodes[idx] : void 0;
      var newNode = updateNode2(node, ownerID, shift + SHIFT2, keyHash, key, value, didChangeSize, didAlter);
      if (newNode === node) {
        return this;
      }
      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE2) {
        return expandNodes2(ownerID, nodes, bitmap, keyHashFrag, newNode);
      }
      if (exists && !newNode && nodes.length === 2 && isLeafNode2(nodes[idx ^ 1])) {
        return nodes[idx ^ 1];
      }
      if (exists && newNode && nodes.length === 1 && isLeafNode2(newNode)) {
        return newNode;
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
      var newNodes = exists ? newNode ? setIn2(nodes, idx, newNode, isEditable) : spliceOut2(nodes, idx, isEditable) : spliceIn2(nodes, idx, newNode, isEditable);
      if (isEditable) {
        this.bitmap = newBitmap;
        this.nodes = newNodes;
        return this;
      }
      return new BitmapIndexedNode3(ownerID, newBitmap, newNodes);
    };
    function HashArrayMapNode3(ownerID, count2, nodes) {
      this.ownerID = ownerID;
      this.count = count2;
      this.nodes = nodes;
    }
    HashArrayMapNode3.prototype.get = function(shift, keyHash, key, notSetValue) {
      if (keyHash === void 0) {
        keyHash = hash2(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK2;
      var node = this.nodes[idx];
      return node ? node.get(shift + SHIFT2, keyHash, key, notSetValue) : notSetValue;
    };
    HashArrayMapNode3.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === void 0) {
        keyHash = hash2(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK2;
      var removed = value === NOT_SET2;
      var nodes = this.nodes;
      var node = nodes[idx];
      if (removed && !node) {
        return this;
      }
      var newNode = updateNode2(node, ownerID, shift + SHIFT2, keyHash, key, value, didChangeSize, didAlter);
      if (newNode === node) {
        return this;
      }
      var newCount = this.count;
      if (!node) {
        newCount++;
      } else if (!newNode) {
        newCount--;
        if (newCount < MIN_HASH_ARRAY_MAP_SIZE2) {
          return packNodes2(ownerID, nodes, newCount, idx);
        }
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newNodes = setIn2(nodes, idx, newNode, isEditable);
      if (isEditable) {
        this.count = newCount;
        this.nodes = newNodes;
        return this;
      }
      return new HashArrayMapNode3(ownerID, newCount, newNodes);
    };
    function HashCollisionNode3(ownerID, keyHash, entries2) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entries = entries2;
    }
    HashCollisionNode3.prototype.get = function(shift, keyHash, key, notSetValue) {
      var entries2 = this.entries;
      for (var ii = 0, len = entries2.length; ii < len; ii++) {
        if (is2(key, entries2[ii][0])) {
          return entries2[ii][1];
        }
      }
      return notSetValue;
    };
    HashCollisionNode3.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (keyHash === void 0) {
        keyHash = hash2(key);
      }
      var removed = value === NOT_SET2;
      if (keyHash !== this.keyHash) {
        if (removed) {
          return this;
        }
        SetRef2(didAlter);
        SetRef2(didChangeSize);
        return mergeIntoNode2(this, ownerID, shift, keyHash, [key, value]);
      }
      var entries2 = this.entries;
      var idx = 0;
      for (var len = entries2.length; idx < len; idx++) {
        if (is2(key, entries2[idx][0])) {
          break;
        }
      }
      var exists = idx < len;
      if (exists ? entries2[idx][1] === value : removed) {
        return this;
      }
      SetRef2(didAlter);
      (removed || !exists) && SetRef2(didChangeSize);
      if (removed && len === 2) {
        return new ValueNode3(ownerID, this.keyHash, entries2[idx ^ 1]);
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries2 : arrCopy2(entries2);
      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
        } else {
          newEntries[idx] = [key, value];
        }
      } else {
        newEntries.push([key, value]);
      }
      if (isEditable) {
        this.entries = newEntries;
        return this;
      }
      return new HashCollisionNode3(ownerID, this.keyHash, newEntries);
    };
    function ValueNode3(ownerID, keyHash, entry) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entry = entry;
    }
    ValueNode3.prototype.get = function(shift, keyHash, key, notSetValue) {
      return is2(key, this.entry[0]) ? this.entry[1] : notSetValue;
    };
    ValueNode3.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      var removed = value === NOT_SET2;
      var keyMatch = is2(key, this.entry[0]);
      if (keyMatch ? value === this.entry[1] : removed) {
        return this;
      }
      SetRef2(didAlter);
      if (removed) {
        SetRef2(didChangeSize);
        return;
      }
      if (keyMatch) {
        if (ownerID && ownerID === this.ownerID) {
          this.entry[1] = value;
          return this;
        }
        return new ValueNode3(ownerID, this.keyHash, [key, value]);
      }
      SetRef2(didChangeSize);
      return mergeIntoNode2(this, ownerID, shift, hash2(key), [key, value]);
    };
    ArrayMapNode3.prototype.iterate = HashCollisionNode3.prototype.iterate = function(fn, reverse3) {
      var entries2 = this.entries;
      for (var ii = 0, maxIndex = entries2.length - 1; ii <= maxIndex; ii++) {
        if (fn(entries2[reverse3 ? maxIndex - ii : ii]) === false) {
          return false;
        }
      }
    };
    BitmapIndexedNode3.prototype.iterate = HashArrayMapNode3.prototype.iterate = function(fn, reverse3) {
      var nodes = this.nodes;
      for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
        var node = nodes[reverse3 ? maxIndex - ii : ii];
        if (node && node.iterate(fn, reverse3) === false) {
          return false;
        }
      }
    };
    ValueNode3.prototype.iterate = function(fn, reverse3) {
      return fn(this.entry);
    };
    createClass(MapIterator2, Iterator3);
    function MapIterator2(map2, type, reverse3) {
      this._type = type;
      this._reverse = reverse3;
      this._stack = map2._root && mapIteratorFrame2(map2._root);
    }
    MapIterator2.prototype.next = function() {
      var type = this._type;
      var stack = this._stack;
      while (stack) {
        var node = stack.node;
        var index = stack.index++;
        var maxIndex;
        if (node.entry) {
          if (index === 0) {
            return mapIteratorValue2(type, node.entry);
          }
        } else if (node.entries) {
          maxIndex = node.entries.length - 1;
          if (index <= maxIndex) {
            return mapIteratorValue2(type, node.entries[this._reverse ? maxIndex - index : index]);
          }
        } else {
          maxIndex = node.nodes.length - 1;
          if (index <= maxIndex) {
            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
            if (subNode) {
              if (subNode.entry) {
                return mapIteratorValue2(type, subNode.entry);
              }
              stack = this._stack = mapIteratorFrame2(subNode, stack);
            }
            continue;
          }
        }
        stack = this._stack = this._stack.__prev;
      }
      return iteratorDone2();
    };
    function mapIteratorValue2(type, entry) {
      return iteratorValue2(type, entry[0], entry[1]);
    }
    function mapIteratorFrame2(node, prev) {
      return {
        node,
        index: 0,
        __prev: prev
      };
    }
    function makeMap2(size, root2, ownerID, hash3) {
      var map2 = Object.create(MapPrototype2);
      map2.size = size;
      map2._root = root2;
      map2.__ownerID = ownerID;
      map2.__hash = hash3;
      map2.__altered = false;
      return map2;
    }
    var EMPTY_MAP2;
    function emptyMap2() {
      return EMPTY_MAP2 || (EMPTY_MAP2 = makeMap2(0));
    }
    function updateMap2(map2, k, v) {
      var newRoot;
      var newSize;
      if (!map2._root) {
        if (v === NOT_SET2) {
          return map2;
        }
        newSize = 1;
        newRoot = new ArrayMapNode3(map2.__ownerID, [[k, v]]);
      } else {
        var didChangeSize = MakeRef2(CHANGE_LENGTH);
        var didAlter = MakeRef2(DID_ALTER);
        newRoot = updateNode2(map2._root, map2.__ownerID, 0, void 0, k, v, didChangeSize, didAlter);
        if (!didAlter.value) {
          return map2;
        }
        newSize = map2.size + (didChangeSize.value ? v === NOT_SET2 ? -1 : 1 : 0);
      }
      if (map2.__ownerID) {
        map2.size = newSize;
        map2._root = newRoot;
        map2.__hash = void 0;
        map2.__altered = true;
        return map2;
      }
      return newRoot ? makeMap2(newSize, newRoot) : emptyMap2();
    }
    function updateNode2(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
      if (!node) {
        if (value === NOT_SET2) {
          return node;
        }
        SetRef2(didAlter);
        SetRef2(didChangeSize);
        return new ValueNode3(ownerID, keyHash, [key, value]);
      }
      return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
    }
    function isLeafNode2(node) {
      return node.constructor === ValueNode3 || node.constructor === HashCollisionNode3;
    }
    function mergeIntoNode2(node, ownerID, shift, keyHash, entry) {
      if (node.keyHash === keyHash) {
        return new HashCollisionNode3(ownerID, keyHash, [node.entry, entry]);
      }
      var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK2;
      var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK2;
      var newNode;
      var nodes = idx1 === idx2 ? [mergeIntoNode2(node, ownerID, shift + SHIFT2, keyHash, entry)] : (newNode = new ValueNode3(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
      return new BitmapIndexedNode3(ownerID, 1 << idx1 | 1 << idx2, nodes);
    }
    function createNodes2(ownerID, entries2, key, value) {
      if (!ownerID) {
        ownerID = new OwnerID2();
      }
      var node = new ValueNode3(ownerID, hash2(key), [key, value]);
      for (var ii = 0; ii < entries2.length; ii++) {
        var entry = entries2[ii];
        node = node.update(ownerID, 0, void 0, entry[0], entry[1]);
      }
      return node;
    }
    function packNodes2(ownerID, nodes, count2, excluding) {
      var bitmap = 0;
      var packedII = 0;
      var packedNodes = new Array(count2);
      for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
        var node = nodes[ii];
        if (node !== void 0 && ii !== excluding) {
          bitmap |= bit;
          packedNodes[packedII++] = node;
        }
      }
      return new BitmapIndexedNode3(ownerID, bitmap, packedNodes);
    }
    function expandNodes2(ownerID, nodes, bitmap, including, node) {
      var count2 = 0;
      var expandedNodes = new Array(SIZE2);
      for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
        expandedNodes[ii] = bitmap & 1 ? nodes[count2++] : void 0;
      }
      expandedNodes[including] = node;
      return new HashArrayMapNode3(ownerID, count2 + 1, expandedNodes);
    }
    function mergeIntoMapWith(map2, merger, iterables) {
      var iters = [];
      for (var ii = 0; ii < iterables.length; ii++) {
        var value = iterables[ii];
        var iter = KeyedIterable(value);
        if (!isIterable(value)) {
          iter = iter.map(function(v) {
            return fromJS2(v);
          });
        }
        iters.push(iter);
      }
      return mergeIntoCollectionWith(map2, merger, iters);
    }
    function deepMerger(existing, value, key) {
      return existing && existing.mergeDeep && isIterable(value) ? existing.mergeDeep(value) : is2(existing, value) ? existing : value;
    }
    function deepMergerWith2(merger) {
      return function(existing, value, key) {
        if (existing && existing.mergeDeepWith && isIterable(value)) {
          return existing.mergeDeepWith(merger, value);
        }
        var nextValue = merger(existing, value, key);
        return is2(existing, nextValue) ? existing : nextValue;
      };
    }
    function mergeIntoCollectionWith(collection, merger, iters) {
      iters = iters.filter(function(x) {
        return x.size !== 0;
      });
      if (iters.length === 0) {
        return collection;
      }
      if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
        return collection.constructor(iters[0]);
      }
      return collection.withMutations(function(collection2) {
        var mergeIntoMap = merger ? function(value, key) {
          collection2.update(key, NOT_SET2, function(existing) {
            return existing === NOT_SET2 ? value : merger(existing, value, key);
          });
        } : function(value, key) {
          collection2.set(key, value);
        };
        for (var ii = 0; ii < iters.length; ii++) {
          iters[ii].forEach(mergeIntoMap);
        }
      });
    }
    function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
      var isNotSet = existing === NOT_SET2;
      var step = keyPathIter.next();
      if (step.done) {
        var existingValue = isNotSet ? notSetValue : existing;
        var newValue = updater(existingValue);
        return newValue === existingValue ? existing : newValue;
      }
      invariant2(isNotSet || existing && existing.set, "invalid keyPath");
      var key = step.value;
      var nextExisting = isNotSet ? NOT_SET2 : existing.get(key, NOT_SET2);
      var nextUpdated = updateInDeepMap(nextExisting, keyPathIter, notSetValue, updater);
      return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET2 ? existing.remove(key) : (isNotSet ? emptyMap2() : existing).set(key, nextUpdated);
    }
    function popCount2(x) {
      x = x - (x >> 1 & 1431655765);
      x = (x & 858993459) + (x >> 2 & 858993459);
      x = x + (x >> 4) & 252645135;
      x = x + (x >> 8);
      x = x + (x >> 16);
      return x & 127;
    }
    function setIn2(array, idx, val, canEdit) {
      var newArray = canEdit ? array : arrCopy2(array);
      newArray[idx] = val;
      return newArray;
    }
    function spliceIn2(array, idx, val, canEdit) {
      var newLen = array.length + 1;
      if (canEdit && idx + 1 === newLen) {
        array[idx] = val;
        return array;
      }
      var newArray = new Array(newLen);
      var after = 0;
      for (var ii = 0; ii < newLen; ii++) {
        if (ii === idx) {
          newArray[ii] = val;
          after = -1;
        } else {
          newArray[ii] = array[ii + after];
        }
      }
      return newArray;
    }
    function spliceOut2(array, idx, canEdit) {
      var newLen = array.length - 1;
      if (canEdit && idx === newLen) {
        array.pop();
        return array;
      }
      var newArray = new Array(newLen);
      var after = 0;
      for (var ii = 0; ii < newLen; ii++) {
        if (ii === idx) {
          after = 1;
        }
        newArray[ii] = array[ii + after];
      }
      return newArray;
    }
    var MAX_ARRAY_MAP_SIZE2 = SIZE2 / 4;
    var MAX_BITMAP_INDEXED_SIZE2 = SIZE2 / 2;
    var MIN_HASH_ARRAY_MAP_SIZE2 = SIZE2 / 4;
    createClass(List2, IndexedCollection2);
    function List2(value) {
      var empty = emptyList2();
      if (value === null || value === void 0) {
        return empty;
      }
      if (isList2(value)) {
        return value;
      }
      var iter = IndexedIterable(value);
      var size = iter.size;
      if (size === 0) {
        return empty;
      }
      assertNotInfinite2(size);
      if (size > 0 && size < SIZE2) {
        return makeList2(0, size, SHIFT2, null, new VNode3(iter.toArray()));
      }
      return empty.withMutations(function(list) {
        list.setSize(size);
        iter.forEach(function(v, i) {
          return list.set(i, v);
        });
      });
    }
    List2.of = function() {
      return this(arguments);
    };
    List2.prototype.toString = function() {
      return this.__toString("List [", "]");
    };
    List2.prototype.get = function(index, notSetValue) {
      index = wrapIndex2(this, index);
      if (index >= 0 && index < this.size) {
        index += this._origin;
        var node = listNodeFor2(this, index);
        return node && node.array[index & MASK2];
      }
      return notSetValue;
    };
    List2.prototype.set = function(index, value) {
      return updateList2(this, index, value);
    };
    List2.prototype.remove = function(index) {
      return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
    };
    List2.prototype.insert = function(index, value) {
      return this.splice(index, 0, value);
    };
    List2.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = this._origin = this._capacity = 0;
        this._level = SHIFT2;
        this._root = this._tail = null;
        this.__hash = void 0;
        this.__altered = true;
        return this;
      }
      return emptyList2();
    };
    List2.prototype.push = function() {
      var values2 = arguments;
      var oldSize = this.size;
      return this.withMutations(function(list) {
        setListBounds2(list, 0, oldSize + values2.length);
        for (var ii = 0; ii < values2.length; ii++) {
          list.set(oldSize + ii, values2[ii]);
        }
      });
    };
    List2.prototype.pop = function() {
      return setListBounds2(this, 0, -1);
    };
    List2.prototype.unshift = function() {
      var values2 = arguments;
      return this.withMutations(function(list) {
        setListBounds2(list, -values2.length);
        for (var ii = 0; ii < values2.length; ii++) {
          list.set(ii, values2[ii]);
        }
      });
    };
    List2.prototype.shift = function() {
      return setListBounds2(this, 1);
    };
    List2.prototype.merge = function() {
      return mergeIntoListWith(this, void 0, arguments);
    };
    List2.prototype.mergeWith = function(merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, merger, iters);
    };
    List2.prototype.mergeDeep = function() {
      return mergeIntoListWith(this, deepMerger, arguments);
    };
    List2.prototype.mergeDeepWith = function(merger) {
      var iters = SLICE$0.call(arguments, 1);
      return mergeIntoListWith(this, deepMergerWith2(merger), iters);
    };
    List2.prototype.setSize = function(size) {
      return setListBounds2(this, 0, size);
    };
    List2.prototype.slice = function(begin, end) {
      var size = this.size;
      if (wholeSlice2(begin, end, size)) {
        return this;
      }
      return setListBounds2(this, resolveBegin2(begin, size), resolveEnd2(end, size));
    };
    List2.prototype.__iterator = function(type, reverse3) {
      var index = 0;
      var values2 = iterateList2(this, reverse3);
      return new Iterator3(function() {
        var value = values2();
        return value === DONE2 ? iteratorDone2() : iteratorValue2(type, index++, value);
      });
    };
    List2.prototype.__iterate = function(fn, reverse3) {
      var index = 0;
      var values2 = iterateList2(this, reverse3);
      var value;
      while ((value = values2()) !== DONE2) {
        if (fn(value, index++, this) === false) {
          break;
        }
      }
      return index;
    };
    List2.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        return this;
      }
      return makeList2(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
    };
    function isList2(maybeList) {
      return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
    }
    List2.isList = isList2;
    var IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
    var ListPrototype2 = List2.prototype;
    ListPrototype2[IS_LIST_SENTINEL] = true;
    ListPrototype2[DELETE2] = ListPrototype2.remove;
    ListPrototype2.setIn = MapPrototype2.setIn;
    ListPrototype2.deleteIn = ListPrototype2.removeIn = MapPrototype2.removeIn;
    ListPrototype2.update = MapPrototype2.update;
    ListPrototype2.updateIn = MapPrototype2.updateIn;
    ListPrototype2.mergeIn = MapPrototype2.mergeIn;
    ListPrototype2.mergeDeepIn = MapPrototype2.mergeDeepIn;
    ListPrototype2.withMutations = MapPrototype2.withMutations;
    ListPrototype2.asMutable = MapPrototype2.asMutable;
    ListPrototype2.asImmutable = MapPrototype2.asImmutable;
    ListPrototype2.wasAltered = MapPrototype2.wasAltered;
    function VNode3(array, ownerID) {
      this.array = array;
      this.ownerID = ownerID;
    }
    VNode3.prototype.removeBefore = function(ownerID, level, index) {
      if (index === level ? 1 << level : this.array.length === 0) {
        return this;
      }
      var originIndex = index >>> level & MASK2;
      if (originIndex >= this.array.length) {
        return new VNode3([], ownerID);
      }
      var removingFirst = originIndex === 0;
      var newChild;
      if (level > 0) {
        var oldChild = this.array[originIndex];
        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT2, index);
        if (newChild === oldChild && removingFirst) {
          return this;
        }
      }
      if (removingFirst && !newChild) {
        return this;
      }
      var editable = editableVNode2(this, ownerID);
      if (!removingFirst) {
        for (var ii = 0; ii < originIndex; ii++) {
          editable.array[ii] = void 0;
        }
      }
      if (newChild) {
        editable.array[originIndex] = newChild;
      }
      return editable;
    };
    VNode3.prototype.removeAfter = function(ownerID, level, index) {
      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
        return this;
      }
      var sizeIndex = index - 1 >>> level & MASK2;
      if (sizeIndex >= this.array.length) {
        return this;
      }
      var newChild;
      if (level > 0) {
        var oldChild = this.array[sizeIndex];
        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT2, index);
        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
          return this;
        }
      }
      var editable = editableVNode2(this, ownerID);
      editable.array.splice(sizeIndex + 1);
      if (newChild) {
        editable.array[sizeIndex] = newChild;
      }
      return editable;
    };
    var DONE2 = {};
    function iterateList2(list, reverse3) {
      var left = list._origin;
      var right = list._capacity;
      var tailPos = getTailOffset2(right);
      var tail = list._tail;
      return iterateNodeOrLeaf(list._root, list._level, 0);
      function iterateNodeOrLeaf(node, level, offset) {
        return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
      }
      function iterateLeaf(node, offset) {
        var array = offset === tailPos ? tail && tail.array : node && node.array;
        var from = offset > left ? 0 : left - offset;
        var to = right - offset;
        if (to > SIZE2) {
          to = SIZE2;
        }
        return function() {
          if (from === to) {
            return DONE2;
          }
          var idx = reverse3 ? --to : from++;
          return array && array[idx];
        };
      }
      function iterateNode(node, level, offset) {
        var values2;
        var array = node && node.array;
        var from = offset > left ? 0 : left - offset >> level;
        var to = (right - offset >> level) + 1;
        if (to > SIZE2) {
          to = SIZE2;
        }
        return function() {
          do {
            if (values2) {
              var value = values2();
              if (value !== DONE2) {
                return value;
              }
              values2 = null;
            }
            if (from === to) {
              return DONE2;
            }
            var idx = reverse3 ? --to : from++;
            values2 = iterateNodeOrLeaf(array && array[idx], level - SHIFT2, offset + (idx << level));
          } while (true);
        };
      }
    }
    function makeList2(origin, capacity, level, root2, tail, ownerID, hash3) {
      var list = Object.create(ListPrototype2);
      list.size = capacity - origin;
      list._origin = origin;
      list._capacity = capacity;
      list._level = level;
      list._root = root2;
      list._tail = tail;
      list.__ownerID = ownerID;
      list.__hash = hash3;
      list.__altered = false;
      return list;
    }
    var EMPTY_LIST2;
    function emptyList2() {
      return EMPTY_LIST2 || (EMPTY_LIST2 = makeList2(0, 0, SHIFT2));
    }
    function updateList2(list, index, value) {
      index = wrapIndex2(list, index);
      if (index !== index) {
        return list;
      }
      if (index >= list.size || index < 0) {
        return list.withMutations(function(list2) {
          index < 0 ? setListBounds2(list2, index).set(0, value) : setListBounds2(list2, 0, index + 1).set(index, value);
        });
      }
      index += list._origin;
      var newTail = list._tail;
      var newRoot = list._root;
      var didAlter = MakeRef2(DID_ALTER);
      if (index >= getTailOffset2(list._capacity)) {
        newTail = updateVNode2(newTail, list.__ownerID, 0, index, value, didAlter);
      } else {
        newRoot = updateVNode2(newRoot, list.__ownerID, list._level, index, value, didAlter);
      }
      if (!didAlter.value) {
        return list;
      }
      if (list.__ownerID) {
        list._root = newRoot;
        list._tail = newTail;
        list.__hash = void 0;
        list.__altered = true;
        return list;
      }
      return makeList2(list._origin, list._capacity, list._level, newRoot, newTail);
    }
    function updateVNode2(node, ownerID, level, index, value, didAlter) {
      var idx = index >>> level & MASK2;
      var nodeHas = node && idx < node.array.length;
      if (!nodeHas && value === void 0) {
        return node;
      }
      var newNode;
      if (level > 0) {
        var lowerNode = node && node.array[idx];
        var newLowerNode = updateVNode2(lowerNode, ownerID, level - SHIFT2, index, value, didAlter);
        if (newLowerNode === lowerNode) {
          return node;
        }
        newNode = editableVNode2(node, ownerID);
        newNode.array[idx] = newLowerNode;
        return newNode;
      }
      if (nodeHas && node.array[idx] === value) {
        return node;
      }
      SetRef2(didAlter);
      newNode = editableVNode2(node, ownerID);
      if (value === void 0 && idx === newNode.array.length - 1) {
        newNode.array.pop();
      } else {
        newNode.array[idx] = value;
      }
      return newNode;
    }
    function editableVNode2(node, ownerID) {
      if (ownerID && node && ownerID === node.ownerID) {
        return node;
      }
      return new VNode3(node ? node.array.slice() : [], ownerID);
    }
    function listNodeFor2(list, rawIndex) {
      if (rawIndex >= getTailOffset2(list._capacity)) {
        return list._tail;
      }
      if (rawIndex < 1 << list._level + SHIFT2) {
        var node = list._root;
        var level = list._level;
        while (node && level > 0) {
          node = node.array[rawIndex >>> level & MASK2];
          level -= SHIFT2;
        }
        return node;
      }
    }
    function setListBounds2(list, begin, end) {
      if (begin !== void 0) {
        begin = begin | 0;
      }
      if (end !== void 0) {
        end = end | 0;
      }
      var owner = list.__ownerID || new OwnerID2();
      var oldOrigin = list._origin;
      var oldCapacity = list._capacity;
      var newOrigin = oldOrigin + begin;
      var newCapacity = end === void 0 ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
      if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
        return list;
      }
      if (newOrigin >= newCapacity) {
        return list.clear();
      }
      var newLevel = list._level;
      var newRoot = list._root;
      var offsetShift = 0;
      while (newOrigin + offsetShift < 0) {
        newRoot = new VNode3(newRoot && newRoot.array.length ? [void 0, newRoot] : [], owner);
        newLevel += SHIFT2;
        offsetShift += 1 << newLevel;
      }
      if (offsetShift) {
        newOrigin += offsetShift;
        oldOrigin += offsetShift;
        newCapacity += offsetShift;
        oldCapacity += offsetShift;
      }
      var oldTailOffset = getTailOffset2(oldCapacity);
      var newTailOffset = getTailOffset2(newCapacity);
      while (newTailOffset >= 1 << newLevel + SHIFT2) {
        newRoot = new VNode3(newRoot && newRoot.array.length ? [newRoot] : [], owner);
        newLevel += SHIFT2;
      }
      var oldTail = list._tail;
      var newTail = newTailOffset < oldTailOffset ? listNodeFor2(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode3([], owner) : oldTail;
      if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
        newRoot = editableVNode2(newRoot, owner);
        var node = newRoot;
        for (var level = newLevel; level > SHIFT2; level -= SHIFT2) {
          var idx = oldTailOffset >>> level & MASK2;
          node = node.array[idx] = editableVNode2(node.array[idx], owner);
        }
        node.array[oldTailOffset >>> SHIFT2 & MASK2] = oldTail;
      }
      if (newCapacity < oldCapacity) {
        newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
      }
      if (newOrigin >= newTailOffset) {
        newOrigin -= newTailOffset;
        newCapacity -= newTailOffset;
        newLevel = SHIFT2;
        newRoot = null;
        newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
      } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
        offsetShift = 0;
        while (newRoot) {
          var beginIndex = newOrigin >>> newLevel & MASK2;
          if (beginIndex !== newTailOffset >>> newLevel & MASK2) {
            break;
          }
          if (beginIndex) {
            offsetShift += (1 << newLevel) * beginIndex;
          }
          newLevel -= SHIFT2;
          newRoot = newRoot.array[beginIndex];
        }
        if (newRoot && newOrigin > oldOrigin) {
          newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
        }
        if (newRoot && newTailOffset < oldTailOffset) {
          newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
        }
        if (offsetShift) {
          newOrigin -= offsetShift;
          newCapacity -= offsetShift;
        }
      }
      if (list.__ownerID) {
        list.size = newCapacity - newOrigin;
        list._origin = newOrigin;
        list._capacity = newCapacity;
        list._level = newLevel;
        list._root = newRoot;
        list._tail = newTail;
        list.__hash = void 0;
        list.__altered = true;
        return list;
      }
      return makeList2(newOrigin, newCapacity, newLevel, newRoot, newTail);
    }
    function mergeIntoListWith(list, merger, iterables) {
      var iters = [];
      var maxSize = 0;
      for (var ii = 0; ii < iterables.length; ii++) {
        var value = iterables[ii];
        var iter = IndexedIterable(value);
        if (iter.size > maxSize) {
          maxSize = iter.size;
        }
        if (!isIterable(value)) {
          iter = iter.map(function(v) {
            return fromJS2(v);
          });
        }
        iters.push(iter);
      }
      if (maxSize > list.size) {
        list = list.setSize(maxSize);
      }
      return mergeIntoCollectionWith(list, merger, iters);
    }
    function getTailOffset2(size) {
      return size < SIZE2 ? 0 : size - 1 >>> SHIFT2 << SHIFT2;
    }
    createClass(OrderedMap2, Map2);
    function OrderedMap2(value) {
      return value === null || value === void 0 ? emptyOrderedMap2() : isOrderedMap2(value) ? value : emptyOrderedMap2().withMutations(function(map2) {
        var iter = KeyedIterable(value);
        assertNotInfinite2(iter.size);
        iter.forEach(function(v, k) {
          return map2.set(k, v);
        });
      });
    }
    OrderedMap2.of = function() {
      return this(arguments);
    };
    OrderedMap2.prototype.toString = function() {
      return this.__toString("OrderedMap {", "}");
    };
    OrderedMap2.prototype.get = function(k, notSetValue) {
      var index = this._map.get(k);
      return index !== void 0 ? this._list.get(index)[1] : notSetValue;
    };
    OrderedMap2.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._map.clear();
        this._list.clear();
        return this;
      }
      return emptyOrderedMap2();
    };
    OrderedMap2.prototype.set = function(k, v) {
      return updateOrderedMap2(this, k, v);
    };
    OrderedMap2.prototype.remove = function(k) {
      return updateOrderedMap2(this, k, NOT_SET2);
    };
    OrderedMap2.prototype.wasAltered = function() {
      return this._map.wasAltered() || this._list.wasAltered();
    };
    OrderedMap2.prototype.__iterate = function(fn, reverse3) {
      var this$0 = this;
      return this._list.__iterate(function(entry) {
        return entry && fn(entry[1], entry[0], this$0);
      }, reverse3);
    };
    OrderedMap2.prototype.__iterator = function(type, reverse3) {
      return this._list.fromEntrySeq().__iterator(type, reverse3);
    };
    OrderedMap2.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      var newList = this._list.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        this._list = newList;
        return this;
      }
      return makeOrderedMap2(newMap, newList, ownerID, this.__hash);
    };
    function isOrderedMap2(maybeOrderedMap) {
      return isMap2(maybeOrderedMap) && isOrdered2(maybeOrderedMap);
    }
    OrderedMap2.isOrderedMap = isOrderedMap2;
    OrderedMap2.prototype[IS_ORDERED_SENTINEL] = true;
    OrderedMap2.prototype[DELETE2] = OrderedMap2.prototype.remove;
    function makeOrderedMap2(map2, list, ownerID, hash3) {
      var omap = Object.create(OrderedMap2.prototype);
      omap.size = map2 ? map2.size : 0;
      omap._map = map2;
      omap._list = list;
      omap.__ownerID = ownerID;
      omap.__hash = hash3;
      return omap;
    }
    var EMPTY_ORDERED_MAP2;
    function emptyOrderedMap2() {
      return EMPTY_ORDERED_MAP2 || (EMPTY_ORDERED_MAP2 = makeOrderedMap2(emptyMap2(), emptyList2()));
    }
    function updateOrderedMap2(omap, k, v) {
      var map2 = omap._map;
      var list = omap._list;
      var i = map2.get(k);
      var has4 = i !== void 0;
      var newMap;
      var newList;
      if (v === NOT_SET2) {
        if (!has4) {
          return omap;
        }
        if (list.size >= SIZE2 && list.size >= map2.size * 2) {
          newList = list.filter(function(entry, idx) {
            return entry !== void 0 && i !== idx;
          });
          newMap = newList.toKeyedSeq().map(function(entry) {
            return entry[0];
          }).flip().toMap();
          if (omap.__ownerID) {
            newMap.__ownerID = newList.__ownerID = omap.__ownerID;
          }
        } else {
          newMap = map2.remove(k);
          newList = i === list.size - 1 ? list.pop() : list.set(i, void 0);
        }
      } else {
        if (has4) {
          if (v === list.get(i)[1]) {
            return omap;
          }
          newMap = map2;
          newList = list.set(i, [k, v]);
        } else {
          newMap = map2.set(k, list.size);
          newList = list.set(list.size, [k, v]);
        }
      }
      if (omap.__ownerID) {
        omap.size = newMap.size;
        omap._map = newMap;
        omap._list = newList;
        omap.__hash = void 0;
        return omap;
      }
      return makeOrderedMap2(newMap, newList);
    }
    createClass(ToKeyedSequence2, KeyedSeq2);
    function ToKeyedSequence2(indexed, useKeys) {
      this._iter = indexed;
      this._useKeys = useKeys;
      this.size = indexed.size;
    }
    ToKeyedSequence2.prototype.get = function(key, notSetValue) {
      return this._iter.get(key, notSetValue);
    };
    ToKeyedSequence2.prototype.has = function(key) {
      return this._iter.has(key);
    };
    ToKeyedSequence2.prototype.valueSeq = function() {
      return this._iter.valueSeq();
    };
    ToKeyedSequence2.prototype.reverse = function() {
      var this$0 = this;
      var reversedSequence = reverseFactory2(this, true);
      if (!this._useKeys) {
        reversedSequence.valueSeq = function() {
          return this$0._iter.toSeq().reverse();
        };
      }
      return reversedSequence;
    };
    ToKeyedSequence2.prototype.map = function(mapper, context) {
      var this$0 = this;
      var mappedSequence = mapFactory2(this, mapper, context);
      if (!this._useKeys) {
        mappedSequence.valueSeq = function() {
          return this$0._iter.toSeq().map(mapper, context);
        };
      }
      return mappedSequence;
    };
    ToKeyedSequence2.prototype.__iterate = function(fn, reverse3) {
      var this$0 = this;
      var ii;
      return this._iter.__iterate(this._useKeys ? function(v, k) {
        return fn(v, k, this$0);
      } : (ii = reverse3 ? resolveSize(this) : 0, function(v) {
        return fn(v, reverse3 ? --ii : ii++, this$0);
      }), reverse3);
    };
    ToKeyedSequence2.prototype.__iterator = function(type, reverse3) {
      if (this._useKeys) {
        return this._iter.__iterator(type, reverse3);
      }
      var iterator = this._iter.__iterator(ITERATE_VALUES2, reverse3);
      var ii = reverse3 ? resolveSize(this) : 0;
      return new Iterator3(function() {
        var step = iterator.next();
        return step.done ? step : iteratorValue2(type, reverse3 ? --ii : ii++, step.value, step);
      });
    };
    ToKeyedSequence2.prototype[IS_ORDERED_SENTINEL] = true;
    createClass(ToIndexedSequence2, IndexedSeq2);
    function ToIndexedSequence2(iter) {
      this._iter = iter;
      this.size = iter.size;
    }
    ToIndexedSequence2.prototype.includes = function(value) {
      return this._iter.includes(value);
    };
    ToIndexedSequence2.prototype.__iterate = function(fn, reverse3) {
      var this$0 = this;
      var iterations = 0;
      return this._iter.__iterate(function(v) {
        return fn(v, iterations++, this$0);
      }, reverse3);
    };
    ToIndexedSequence2.prototype.__iterator = function(type, reverse3) {
      var iterator = this._iter.__iterator(ITERATE_VALUES2, reverse3);
      var iterations = 0;
      return new Iterator3(function() {
        var step = iterator.next();
        return step.done ? step : iteratorValue2(type, iterations++, step.value, step);
      });
    };
    createClass(ToSetSequence2, SetSeq2);
    function ToSetSequence2(iter) {
      this._iter = iter;
      this.size = iter.size;
    }
    ToSetSequence2.prototype.has = function(key) {
      return this._iter.includes(key);
    };
    ToSetSequence2.prototype.__iterate = function(fn, reverse3) {
      var this$0 = this;
      return this._iter.__iterate(function(v) {
        return fn(v, v, this$0);
      }, reverse3);
    };
    ToSetSequence2.prototype.__iterator = function(type, reverse3) {
      var iterator = this._iter.__iterator(ITERATE_VALUES2, reverse3);
      return new Iterator3(function() {
        var step = iterator.next();
        return step.done ? step : iteratorValue2(type, step.value, step.value, step);
      });
    };
    createClass(FromEntriesSequence2, KeyedSeq2);
    function FromEntriesSequence2(entries2) {
      this._iter = entries2;
      this.size = entries2.size;
    }
    FromEntriesSequence2.prototype.entrySeq = function() {
      return this._iter.toSeq();
    };
    FromEntriesSequence2.prototype.__iterate = function(fn, reverse3) {
      var this$0 = this;
      return this._iter.__iterate(function(entry) {
        if (entry) {
          validateEntry2(entry);
          var indexedIterable = isIterable(entry);
          return fn(indexedIterable ? entry.get(1) : entry[1], indexedIterable ? entry.get(0) : entry[0], this$0);
        }
      }, reverse3);
    };
    FromEntriesSequence2.prototype.__iterator = function(type, reverse3) {
      var iterator = this._iter.__iterator(ITERATE_VALUES2, reverse3);
      return new Iterator3(function() {
        while (true) {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          if (entry) {
            validateEntry2(entry);
            var indexedIterable = isIterable(entry);
            return iteratorValue2(type, indexedIterable ? entry.get(0) : entry[0], indexedIterable ? entry.get(1) : entry[1], step);
          }
        }
      });
    };
    ToIndexedSequence2.prototype.cacheResult = ToKeyedSequence2.prototype.cacheResult = ToSetSequence2.prototype.cacheResult = FromEntriesSequence2.prototype.cacheResult = cacheResultThrough2;
    function flipFactory2(iterable) {
      var flipSequence = makeSequence2(iterable);
      flipSequence._iter = iterable;
      flipSequence.size = iterable.size;
      flipSequence.flip = function() {
        return iterable;
      };
      flipSequence.reverse = function() {
        var reversedSequence = iterable.reverse.apply(this);
        reversedSequence.flip = function() {
          return iterable.reverse();
        };
        return reversedSequence;
      };
      flipSequence.has = function(key) {
        return iterable.includes(key);
      };
      flipSequence.includes = function(key) {
        return iterable.has(key);
      };
      flipSequence.cacheResult = cacheResultThrough2;
      flipSequence.__iterateUncached = function(fn, reverse3) {
        var this$0 = this;
        return iterable.__iterate(function(v, k) {
          return fn(k, v, this$0) !== false;
        }, reverse3);
      };
      flipSequence.__iteratorUncached = function(type, reverse3) {
        if (type === ITERATE_ENTRIES2) {
          var iterator = iterable.__iterator(type, reverse3);
          return new Iterator3(function() {
            var step = iterator.next();
            if (!step.done) {
              var k = step.value[0];
              step.value[0] = step.value[1];
              step.value[1] = k;
            }
            return step;
          });
        }
        return iterable.__iterator(type === ITERATE_VALUES2 ? ITERATE_KEYS2 : ITERATE_VALUES2, reverse3);
      };
      return flipSequence;
    }
    function mapFactory2(iterable, mapper, context) {
      var mappedSequence = makeSequence2(iterable);
      mappedSequence.size = iterable.size;
      mappedSequence.has = function(key) {
        return iterable.has(key);
      };
      mappedSequence.get = function(key, notSetValue) {
        var v = iterable.get(key, NOT_SET2);
        return v === NOT_SET2 ? notSetValue : mapper.call(context, v, key, iterable);
      };
      mappedSequence.__iterateUncached = function(fn, reverse3) {
        var this$0 = this;
        return iterable.__iterate(function(v, k, c) {
          return fn(mapper.call(context, v, k, c), k, this$0) !== false;
        }, reverse3);
      };
      mappedSequence.__iteratorUncached = function(type, reverse3) {
        var iterator = iterable.__iterator(ITERATE_ENTRIES2, reverse3);
        return new Iterator3(function() {
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var key = entry[0];
          return iteratorValue2(type, key, mapper.call(context, entry[1], key, iterable), step);
        });
      };
      return mappedSequence;
    }
    function reverseFactory2(iterable, useKeys) {
      var reversedSequence = makeSequence2(iterable);
      reversedSequence._iter = iterable;
      reversedSequence.size = iterable.size;
      reversedSequence.reverse = function() {
        return iterable;
      };
      if (iterable.flip) {
        reversedSequence.flip = function() {
          var flipSequence = flipFactory2(iterable);
          flipSequence.reverse = function() {
            return iterable.flip();
          };
          return flipSequence;
        };
      }
      reversedSequence.get = function(key, notSetValue) {
        return iterable.get(useKeys ? key : -1 - key, notSetValue);
      };
      reversedSequence.has = function(key) {
        return iterable.has(useKeys ? key : -1 - key);
      };
      reversedSequence.includes = function(value) {
        return iterable.includes(value);
      };
      reversedSequence.cacheResult = cacheResultThrough2;
      reversedSequence.__iterate = function(fn, reverse3) {
        var this$0 = this;
        return iterable.__iterate(function(v, k) {
          return fn(v, k, this$0);
        }, !reverse3);
      };
      reversedSequence.__iterator = function(type, reverse3) {
        return iterable.__iterator(type, !reverse3);
      };
      return reversedSequence;
    }
    function filterFactory2(iterable, predicate, context, useKeys) {
      var filterSequence = makeSequence2(iterable);
      if (useKeys) {
        filterSequence.has = function(key) {
          var v = iterable.get(key, NOT_SET2);
          return v !== NOT_SET2 && !!predicate.call(context, v, key, iterable);
        };
        filterSequence.get = function(key, notSetValue) {
          var v = iterable.get(key, NOT_SET2);
          return v !== NOT_SET2 && predicate.call(context, v, key, iterable) ? v : notSetValue;
        };
      }
      filterSequence.__iterateUncached = function(fn, reverse3) {
        var this$0 = this;
        var iterations = 0;
        iterable.__iterate(function(v, k, c) {
          if (predicate.call(context, v, k, c)) {
            iterations++;
            return fn(v, useKeys ? k : iterations - 1, this$0);
          }
        }, reverse3);
        return iterations;
      };
      filterSequence.__iteratorUncached = function(type, reverse3) {
        var iterator = iterable.__iterator(ITERATE_ENTRIES2, reverse3);
        var iterations = 0;
        return new Iterator3(function() {
          while (true) {
            var step = iterator.next();
            if (step.done) {
              return step;
            }
            var entry = step.value;
            var key = entry[0];
            var value = entry[1];
            if (predicate.call(context, value, key, iterable)) {
              return iteratorValue2(type, useKeys ? key : iterations++, value, step);
            }
          }
        });
      };
      return filterSequence;
    }
    function countByFactory2(iterable, grouper, context) {
      var groups = Map2().asMutable();
      iterable.__iterate(function(v, k) {
        groups.update(grouper.call(context, v, k, iterable), 0, function(a) {
          return a + 1;
        });
      });
      return groups.asImmutable();
    }
    function groupByFactory2(iterable, grouper, context) {
      var isKeyedIter = isKeyed2(iterable);
      var groups = (isOrdered2(iterable) ? OrderedMap2() : Map2()).asMutable();
      iterable.__iterate(function(v, k) {
        groups.update(grouper.call(context, v, k, iterable), function(a) {
          return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;
        });
      });
      var coerce = iterableClass(iterable);
      return groups.map(function(arr) {
        return reify2(iterable, coerce(arr));
      });
    }
    function sliceFactory2(iterable, begin, end, useKeys) {
      var originalSize = iterable.size;
      if (begin !== void 0) {
        begin = begin | 0;
      }
      if (end !== void 0) {
        end = end | 0;
      }
      if (wholeSlice2(begin, end, originalSize)) {
        return iterable;
      }
      var resolvedBegin = resolveBegin2(begin, originalSize);
      var resolvedEnd = resolveEnd2(end, originalSize);
      if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
        return sliceFactory2(iterable.toSeq().cacheResult(), begin, end, useKeys);
      }
      var resolvedSize = resolvedEnd - resolvedBegin;
      var sliceSize;
      if (resolvedSize === resolvedSize) {
        sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
      }
      var sliceSeq = makeSequence2(iterable);
      sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || void 0;
      if (!useKeys && isSeq2(iterable) && sliceSize >= 0) {
        sliceSeq.get = function(index, notSetValue) {
          index = wrapIndex2(this, index);
          return index >= 0 && index < sliceSize ? iterable.get(index + resolvedBegin, notSetValue) : notSetValue;
        };
      }
      sliceSeq.__iterateUncached = function(fn, reverse3) {
        var this$0 = this;
        if (sliceSize === 0) {
          return 0;
        }
        if (reverse3) {
          return this.cacheResult().__iterate(fn, reverse3);
        }
        var skipped = 0;
        var isSkipping = true;
        var iterations = 0;
        iterable.__iterate(function(v, k) {
          if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
            iterations++;
            return fn(v, useKeys ? k : iterations - 1, this$0) !== false && iterations !== sliceSize;
          }
        });
        return iterations;
      };
      sliceSeq.__iteratorUncached = function(type, reverse3) {
        if (sliceSize !== 0 && reverse3) {
          return this.cacheResult().__iterator(type, reverse3);
        }
        var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse3);
        var skipped = 0;
        var iterations = 0;
        return new Iterator3(function() {
          while (skipped++ < resolvedBegin) {
            iterator.next();
          }
          if (++iterations > sliceSize) {
            return iteratorDone2();
          }
          var step = iterator.next();
          if (useKeys || type === ITERATE_VALUES2) {
            return step;
          } else if (type === ITERATE_KEYS2) {
            return iteratorValue2(type, iterations - 1, void 0, step);
          } else {
            return iteratorValue2(type, iterations - 1, step.value[1], step);
          }
        });
      };
      return sliceSeq;
    }
    function takeWhileFactory2(iterable, predicate, context) {
      var takeSequence = makeSequence2(iterable);
      takeSequence.__iterateUncached = function(fn, reverse3) {
        var this$0 = this;
        if (reverse3) {
          return this.cacheResult().__iterate(fn, reverse3);
        }
        var iterations = 0;
        iterable.__iterate(function(v, k, c) {
          return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0);
        });
        return iterations;
      };
      takeSequence.__iteratorUncached = function(type, reverse3) {
        var this$0 = this;
        if (reverse3) {
          return this.cacheResult().__iterator(type, reverse3);
        }
        var iterator = iterable.__iterator(ITERATE_ENTRIES2, reverse3);
        var iterating = true;
        return new Iterator3(function() {
          if (!iterating) {
            return iteratorDone2();
          }
          var step = iterator.next();
          if (step.done) {
            return step;
          }
          var entry = step.value;
          var k = entry[0];
          var v = entry[1];
          if (!predicate.call(context, v, k, this$0)) {
            iterating = false;
            return iteratorDone2();
          }
          return type === ITERATE_ENTRIES2 ? step : iteratorValue2(type, k, v, step);
        });
      };
      return takeSequence;
    }
    function skipWhileFactory2(iterable, predicate, context, useKeys) {
      var skipSequence = makeSequence2(iterable);
      skipSequence.__iterateUncached = function(fn, reverse3) {
        var this$0 = this;
        if (reverse3) {
          return this.cacheResult().__iterate(fn, reverse3);
        }
        var isSkipping = true;
        var iterations = 0;
        iterable.__iterate(function(v, k, c) {
          if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
            iterations++;
            return fn(v, useKeys ? k : iterations - 1, this$0);
          }
        });
        return iterations;
      };
      skipSequence.__iteratorUncached = function(type, reverse3) {
        var this$0 = this;
        if (reverse3) {
          return this.cacheResult().__iterator(type, reverse3);
        }
        var iterator = iterable.__iterator(ITERATE_ENTRIES2, reverse3);
        var skipping = true;
        var iterations = 0;
        return new Iterator3(function() {
          var step, k, v;
          do {
            step = iterator.next();
            if (step.done) {
              if (useKeys || type === ITERATE_VALUES2) {
                return step;
              } else if (type === ITERATE_KEYS2) {
                return iteratorValue2(type, iterations++, void 0, step);
              } else {
                return iteratorValue2(type, iterations++, step.value[1], step);
              }
            }
            var entry = step.value;
            k = entry[0];
            v = entry[1];
            skipping && (skipping = predicate.call(context, v, k, this$0));
          } while (skipping);
          return type === ITERATE_ENTRIES2 ? step : iteratorValue2(type, k, v, step);
        });
      };
      return skipSequence;
    }
    function concatFactory2(iterable, values2) {
      var isKeyedIterable = isKeyed2(iterable);
      var iters = [iterable].concat(values2).map(function(v) {
        if (!isIterable(v)) {
          v = isKeyedIterable ? keyedSeqFromValue2(v) : indexedSeqFromValue2(Array.isArray(v) ? v : [v]);
        } else if (isKeyedIterable) {
          v = KeyedIterable(v);
        }
        return v;
      }).filter(function(v) {
        return v.size !== 0;
      });
      if (iters.length === 0) {
        return iterable;
      }
      if (iters.length === 1) {
        var singleton = iters[0];
        if (singleton === iterable || isKeyedIterable && isKeyed2(singleton) || isIndexed2(iterable) && isIndexed2(singleton)) {
          return singleton;
        }
      }
      var concatSeq = new ArraySeq2(iters);
      if (isKeyedIterable) {
        concatSeq = concatSeq.toKeyedSeq();
      } else if (!isIndexed2(iterable)) {
        concatSeq = concatSeq.toSetSeq();
      }
      concatSeq = concatSeq.flatten(true);
      concatSeq.size = iters.reduce(function(sum, seq) {
        if (sum !== void 0) {
          var size = seq.size;
          if (size !== void 0) {
            return sum + size;
          }
        }
      }, 0);
      return concatSeq;
    }
    function flattenFactory2(iterable, depth, useKeys) {
      var flatSequence = makeSequence2(iterable);
      flatSequence.__iterateUncached = function(fn, reverse3) {
        var iterations = 0;
        var stopped = false;
        function flatDeep(iter, currentDepth) {
          var this$0 = this;
          iter.__iterate(function(v, k) {
            if ((!depth || currentDepth < depth) && isIterable(v)) {
              flatDeep(v, currentDepth + 1);
            } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
              stopped = true;
            }
            return !stopped;
          }, reverse3);
        }
        flatDeep(iterable, 0);
        return iterations;
      };
      flatSequence.__iteratorUncached = function(type, reverse3) {
        var iterator = iterable.__iterator(type, reverse3);
        var stack = [];
        var iterations = 0;
        return new Iterator3(function() {
          while (iterator) {
            var step = iterator.next();
            if (step.done !== false) {
              iterator = stack.pop();
              continue;
            }
            var v = step.value;
            if (type === ITERATE_ENTRIES2) {
              v = v[1];
            }
            if ((!depth || stack.length < depth) && isIterable(v)) {
              stack.push(iterator);
              iterator = v.__iterator(type, reverse3);
            } else {
              return useKeys ? step : iteratorValue2(type, iterations++, v, step);
            }
          }
          return iteratorDone2();
        });
      };
      return flatSequence;
    }
    function flatMapFactory2(iterable, mapper, context) {
      var coerce = iterableClass(iterable);
      return iterable.toSeq().map(function(v, k) {
        return coerce(mapper.call(context, v, k, iterable));
      }).flatten(true);
    }
    function interposeFactory2(iterable, separator) {
      var interposedSequence = makeSequence2(iterable);
      interposedSequence.size = iterable.size && iterable.size * 2 - 1;
      interposedSequence.__iterateUncached = function(fn, reverse3) {
        var this$0 = this;
        var iterations = 0;
        iterable.__iterate(function(v, k) {
          return (!iterations || fn(separator, iterations++, this$0) !== false) && fn(v, iterations++, this$0) !== false;
        }, reverse3);
        return iterations;
      };
      interposedSequence.__iteratorUncached = function(type, reverse3) {
        var iterator = iterable.__iterator(ITERATE_VALUES2, reverse3);
        var iterations = 0;
        var step;
        return new Iterator3(function() {
          if (!step || iterations % 2) {
            step = iterator.next();
            if (step.done) {
              return step;
            }
          }
          return iterations % 2 ? iteratorValue2(type, iterations++, separator) : iteratorValue2(type, iterations++, step.value, step);
        });
      };
      return interposedSequence;
    }
    function sortFactory2(iterable, comparator, mapper) {
      if (!comparator) {
        comparator = defaultComparator2;
      }
      var isKeyedIterable = isKeyed2(iterable);
      var index = 0;
      var entries2 = iterable.toSeq().map(function(v, k) {
        return [k, v, index++, mapper ? mapper(v, k, iterable) : v];
      }).toArray();
      entries2.sort(function(a, b) {
        return comparator(a[3], b[3]) || a[2] - b[2];
      }).forEach(isKeyedIterable ? function(v, i) {
        entries2[i].length = 2;
      } : function(v, i) {
        entries2[i] = v[1];
      });
      return isKeyedIterable ? KeyedSeq2(entries2) : isIndexed2(iterable) ? IndexedSeq2(entries2) : SetSeq2(entries2);
    }
    function maxFactory2(iterable, comparator, mapper) {
      if (!comparator) {
        comparator = defaultComparator2;
      }
      if (mapper) {
        var entry = iterable.toSeq().map(function(v, k) {
          return [v, mapper(v, k, iterable)];
        }).reduce(function(a, b) {
          return maxCompare2(comparator, a[1], b[1]) ? b : a;
        });
        return entry && entry[0];
      } else {
        return iterable.reduce(function(a, b) {
          return maxCompare2(comparator, a, b) ? b : a;
        });
      }
    }
    function maxCompare2(comparator, a, b) {
      var comp = comparator(b, a);
      return comp === 0 && b !== a && (b === void 0 || b === null || b !== b) || comp > 0;
    }
    function zipWithFactory2(keyIter, zipper, iters) {
      var zipSequence = makeSequence2(keyIter);
      zipSequence.size = new ArraySeq2(iters).map(function(i) {
        return i.size;
      }).min();
      zipSequence.__iterate = function(fn, reverse3) {
        var iterator = this.__iterator(ITERATE_VALUES2, reverse3);
        var step;
        var iterations = 0;
        while (!(step = iterator.next()).done) {
          if (fn(step.value, iterations++, this) === false) {
            break;
          }
        }
        return iterations;
      };
      zipSequence.__iteratorUncached = function(type, reverse3) {
        var iterators = iters.map(function(i) {
          return i = Iterable(i), getIterator2(reverse3 ? i.reverse() : i);
        });
        var iterations = 0;
        var isDone = false;
        return new Iterator3(function() {
          var steps;
          if (!isDone) {
            steps = iterators.map(function(i) {
              return i.next();
            });
            isDone = steps.some(function(s) {
              return s.done;
            });
          }
          if (isDone) {
            return iteratorDone2();
          }
          return iteratorValue2(type, iterations++, zipper.apply(null, steps.map(function(s) {
            return s.value;
          })));
        });
      };
      return zipSequence;
    }
    function reify2(iter, seq) {
      return isSeq2(iter) ? seq : iter.constructor(seq);
    }
    function validateEntry2(entry) {
      if (entry !== Object(entry)) {
        throw new TypeError("Expected [K, V] tuple: " + entry);
      }
    }
    function resolveSize(iter) {
      assertNotInfinite2(iter.size);
      return ensureSize2(iter);
    }
    function iterableClass(iterable) {
      return isKeyed2(iterable) ? KeyedIterable : isIndexed2(iterable) ? IndexedIterable : SetIterable;
    }
    function makeSequence2(iterable) {
      return Object.create((isKeyed2(iterable) ? KeyedSeq2 : isIndexed2(iterable) ? IndexedSeq2 : SetSeq2).prototype);
    }
    function cacheResultThrough2() {
      if (this._iter.cacheResult) {
        this._iter.cacheResult();
        this.size = this._iter.size;
        return this;
      } else {
        return Seq2.prototype.cacheResult.call(this);
      }
    }
    function defaultComparator2(a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
    }
    function forceIterator(keyPath) {
      var iter = getIterator2(keyPath);
      if (!iter) {
        if (!isArrayLike2(keyPath)) {
          throw new TypeError("Expected iterable or array-like: " + keyPath);
        }
        iter = getIterator2(Iterable(keyPath));
      }
      return iter;
    }
    createClass(Record2, KeyedCollection2);
    function Record2(defaultValues, name) {
      var hasInitialized;
      var RecordType = function Record3(values2) {
        if (values2 instanceof RecordType) {
          return values2;
        }
        if (!(this instanceof RecordType)) {
          return new RecordType(values2);
        }
        if (!hasInitialized) {
          hasInitialized = true;
          var keys3 = Object.keys(defaultValues);
          setProps(RecordTypePrototype, keys3);
          RecordTypePrototype.size = keys3.length;
          RecordTypePrototype._name = name;
          RecordTypePrototype._keys = keys3;
          RecordTypePrototype._defaultValues = defaultValues;
        }
        this._map = Map2(values2);
      };
      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
      RecordTypePrototype.constructor = RecordType;
      return RecordType;
    }
    Record2.prototype.toString = function() {
      return this.__toString(recordName(this) + " {", "}");
    };
    Record2.prototype.has = function(k) {
      return this._defaultValues.hasOwnProperty(k);
    };
    Record2.prototype.get = function(k, notSetValue) {
      if (!this.has(k)) {
        return notSetValue;
      }
      var defaultVal = this._defaultValues[k];
      return this._map ? this._map.get(k, defaultVal) : defaultVal;
    };
    Record2.prototype.clear = function() {
      if (this.__ownerID) {
        this._map && this._map.clear();
        return this;
      }
      var RecordType = this.constructor;
      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap2()));
    };
    Record2.prototype.set = function(k, v) {
      if (!this.has(k)) {
        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
      }
      var newMap = this._map && this._map.set(k, v);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };
    Record2.prototype.remove = function(k) {
      if (!this.has(k)) {
        return this;
      }
      var newMap = this._map && this._map.remove(k);
      if (this.__ownerID || newMap === this._map) {
        return this;
      }
      return makeRecord(this, newMap);
    };
    Record2.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };
    Record2.prototype.__iterator = function(type, reverse3) {
      var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k) {
        return this$0.get(k);
      }).__iterator(type, reverse3);
    };
    Record2.prototype.__iterate = function(fn, reverse3) {
      var this$0 = this;
      return KeyedIterable(this._defaultValues).map(function(_, k) {
        return this$0.get(k);
      }).__iterate(fn, reverse3);
    };
    Record2.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map && this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return makeRecord(this, newMap, ownerID);
    };
    var RecordPrototype = Record2.prototype;
    RecordPrototype[DELETE2] = RecordPrototype.remove;
    RecordPrototype.deleteIn = RecordPrototype.removeIn = MapPrototype2.removeIn;
    RecordPrototype.merge = MapPrototype2.merge;
    RecordPrototype.mergeWith = MapPrototype2.mergeWith;
    RecordPrototype.mergeIn = MapPrototype2.mergeIn;
    RecordPrototype.mergeDeep = MapPrototype2.mergeDeep;
    RecordPrototype.mergeDeepWith = MapPrototype2.mergeDeepWith;
    RecordPrototype.mergeDeepIn = MapPrototype2.mergeDeepIn;
    RecordPrototype.setIn = MapPrototype2.setIn;
    RecordPrototype.update = MapPrototype2.update;
    RecordPrototype.updateIn = MapPrototype2.updateIn;
    RecordPrototype.withMutations = MapPrototype2.withMutations;
    RecordPrototype.asMutable = MapPrototype2.asMutable;
    RecordPrototype.asImmutable = MapPrototype2.asImmutable;
    function makeRecord(likeRecord, map2, ownerID) {
      var record = Object.create(Object.getPrototypeOf(likeRecord));
      record._map = map2;
      record.__ownerID = ownerID;
      return record;
    }
    function recordName(record) {
      return record._name || record.constructor.name || "Record";
    }
    function setProps(prototype, names) {
      try {
        names.forEach(setProp.bind(void 0, prototype));
      } catch (error) {
      }
    }
    function setProp(prototype, name) {
      Object.defineProperty(prototype, name, {
        get: function() {
          return this.get(name);
        },
        set: function(value) {
          invariant2(this.__ownerID, "Cannot set on an immutable record.");
          this.set(name, value);
        }
      });
    }
    createClass(Set2, SetCollection2);
    function Set2(value) {
      return value === null || value === void 0 ? emptySet2() : isSet2(value) && !isOrdered2(value) ? value : emptySet2().withMutations(function(set3) {
        var iter = SetIterable(value);
        assertNotInfinite2(iter.size);
        iter.forEach(function(v) {
          return set3.add(v);
        });
      });
    }
    Set2.of = function() {
      return this(arguments);
    };
    Set2.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };
    Set2.prototype.toString = function() {
      return this.__toString("Set {", "}");
    };
    Set2.prototype.has = function(value) {
      return this._map.has(value);
    };
    Set2.prototype.add = function(value) {
      return updateSet2(this, this._map.set(value, true));
    };
    Set2.prototype.remove = function(value) {
      return updateSet2(this, this._map.remove(value));
    };
    Set2.prototype.clear = function() {
      return updateSet2(this, this._map.clear());
    };
    Set2.prototype.union = function() {
      var iters = SLICE$0.call(arguments, 0);
      iters = iters.filter(function(x) {
        return x.size !== 0;
      });
      if (iters.length === 0) {
        return this;
      }
      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
        return this.constructor(iters[0]);
      }
      return this.withMutations(function(set3) {
        for (var ii = 0; ii < iters.length; ii++) {
          SetIterable(iters[ii]).forEach(function(value) {
            return set3.add(value);
          });
        }
      });
    };
    Set2.prototype.intersect = function() {
      var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter) {
        return SetIterable(iter);
      });
      var originalSet = this;
      return this.withMutations(function(set3) {
        originalSet.forEach(function(value) {
          if (!iters.every(function(iter) {
            return iter.includes(value);
          })) {
            set3.remove(value);
          }
        });
      });
    };
    Set2.prototype.subtract = function() {
      var iters = SLICE$0.call(arguments, 0);
      if (iters.length === 0) {
        return this;
      }
      iters = iters.map(function(iter) {
        return SetIterable(iter);
      });
      var originalSet = this;
      return this.withMutations(function(set3) {
        originalSet.forEach(function(value) {
          if (iters.some(function(iter) {
            return iter.includes(value);
          })) {
            set3.remove(value);
          }
        });
      });
    };
    Set2.prototype.merge = function() {
      return this.union.apply(this, arguments);
    };
    Set2.prototype.mergeWith = function(merger) {
      var iters = SLICE$0.call(arguments, 1);
      return this.union.apply(this, iters);
    };
    Set2.prototype.sort = function(comparator) {
      return OrderedSet2(sortFactory2(this, comparator));
    };
    Set2.prototype.sortBy = function(mapper, comparator) {
      return OrderedSet2(sortFactory2(this, comparator, mapper));
    };
    Set2.prototype.wasAltered = function() {
      return this._map.wasAltered();
    };
    Set2.prototype.__iterate = function(fn, reverse3) {
      var this$0 = this;
      return this._map.__iterate(function(_, k) {
        return fn(k, k, this$0);
      }, reverse3);
    };
    Set2.prototype.__iterator = function(type, reverse3) {
      return this._map.map(function(_, k) {
        return k;
      }).__iterator(type, reverse3);
    };
    Set2.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newMap = this._map.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._map = newMap;
        return this;
      }
      return this.__make(newMap, ownerID);
    };
    function isSet2(maybeSet) {
      return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
    }
    Set2.isSet = isSet2;
    var IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
    var SetPrototype2 = Set2.prototype;
    SetPrototype2[IS_SET_SENTINEL] = true;
    SetPrototype2[DELETE2] = SetPrototype2.remove;
    SetPrototype2.mergeDeep = SetPrototype2.merge;
    SetPrototype2.mergeDeepWith = SetPrototype2.mergeWith;
    SetPrototype2.withMutations = MapPrototype2.withMutations;
    SetPrototype2.asMutable = MapPrototype2.asMutable;
    SetPrototype2.asImmutable = MapPrototype2.asImmutable;
    SetPrototype2.__empty = emptySet2;
    SetPrototype2.__make = makeSet2;
    function updateSet2(set3, newMap) {
      if (set3.__ownerID) {
        set3.size = newMap.size;
        set3._map = newMap;
        return set3;
      }
      return newMap === set3._map ? set3 : newMap.size === 0 ? set3.__empty() : set3.__make(newMap);
    }
    function makeSet2(map2, ownerID) {
      var set3 = Object.create(SetPrototype2);
      set3.size = map2 ? map2.size : 0;
      set3._map = map2;
      set3.__ownerID = ownerID;
      return set3;
    }
    var EMPTY_SET2;
    function emptySet2() {
      return EMPTY_SET2 || (EMPTY_SET2 = makeSet2(emptyMap2()));
    }
    createClass(OrderedSet2, Set2);
    function OrderedSet2(value) {
      return value === null || value === void 0 ? emptyOrderedSet2() : isOrderedSet2(value) ? value : emptyOrderedSet2().withMutations(function(set3) {
        var iter = SetIterable(value);
        assertNotInfinite2(iter.size);
        iter.forEach(function(v) {
          return set3.add(v);
        });
      });
    }
    OrderedSet2.of = function() {
      return this(arguments);
    };
    OrderedSet2.fromKeys = function(value) {
      return this(KeyedIterable(value).keySeq());
    };
    OrderedSet2.prototype.toString = function() {
      return this.__toString("OrderedSet {", "}");
    };
    function isOrderedSet2(maybeOrderedSet) {
      return isSet2(maybeOrderedSet) && isOrdered2(maybeOrderedSet);
    }
    OrderedSet2.isOrderedSet = isOrderedSet2;
    var OrderedSetPrototype2 = OrderedSet2.prototype;
    OrderedSetPrototype2[IS_ORDERED_SENTINEL] = true;
    OrderedSetPrototype2.__empty = emptyOrderedSet2;
    OrderedSetPrototype2.__make = makeOrderedSet2;
    function makeOrderedSet2(map2, ownerID) {
      var set3 = Object.create(OrderedSetPrototype2);
      set3.size = map2 ? map2.size : 0;
      set3._map = map2;
      set3.__ownerID = ownerID;
      return set3;
    }
    var EMPTY_ORDERED_SET2;
    function emptyOrderedSet2() {
      return EMPTY_ORDERED_SET2 || (EMPTY_ORDERED_SET2 = makeOrderedSet2(emptyOrderedMap2()));
    }
    createClass(Stack2, IndexedCollection2);
    function Stack2(value) {
      return value === null || value === void 0 ? emptyStack2() : isStack2(value) ? value : emptyStack2().unshiftAll(value);
    }
    Stack2.of = function() {
      return this(arguments);
    };
    Stack2.prototype.toString = function() {
      return this.__toString("Stack [", "]");
    };
    Stack2.prototype.get = function(index, notSetValue) {
      var head = this._head;
      index = wrapIndex2(this, index);
      while (head && index--) {
        head = head.next;
      }
      return head ? head.value : notSetValue;
    };
    Stack2.prototype.peek = function() {
      return this._head && this._head.value;
    };
    Stack2.prototype.push = function() {
      if (arguments.length === 0) {
        return this;
      }
      var newSize = this.size + arguments.length;
      var head = this._head;
      for (var ii = arguments.length - 1; ii >= 0; ii--) {
        head = {
          value: arguments[ii],
          next: head
        };
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = void 0;
        this.__altered = true;
        return this;
      }
      return makeStack2(newSize, head);
    };
    Stack2.prototype.pushAll = function(iter) {
      iter = IndexedIterable(iter);
      if (iter.size === 0) {
        return this;
      }
      assertNotInfinite2(iter.size);
      var newSize = this.size;
      var head = this._head;
      iter.reverse().forEach(function(value) {
        newSize++;
        head = {
          value,
          next: head
        };
      });
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = void 0;
        this.__altered = true;
        return this;
      }
      return makeStack2(newSize, head);
    };
    Stack2.prototype.pop = function() {
      return this.slice(1);
    };
    Stack2.prototype.unshift = function() {
      return this.push.apply(this, arguments);
    };
    Stack2.prototype.unshiftAll = function(iter) {
      return this.pushAll(iter);
    };
    Stack2.prototype.shift = function() {
      return this.pop.apply(this, arguments);
    };
    Stack2.prototype.clear = function() {
      if (this.size === 0) {
        return this;
      }
      if (this.__ownerID) {
        this.size = 0;
        this._head = void 0;
        this.__hash = void 0;
        this.__altered = true;
        return this;
      }
      return emptyStack2();
    };
    Stack2.prototype.slice = function(begin, end) {
      if (wholeSlice2(begin, end, this.size)) {
        return this;
      }
      var resolvedBegin = resolveBegin2(begin, this.size);
      var resolvedEnd = resolveEnd2(end, this.size);
      if (resolvedEnd !== this.size) {
        return IndexedCollection2.prototype.slice.call(this, begin, end);
      }
      var newSize = this.size - resolvedBegin;
      var head = this._head;
      while (resolvedBegin--) {
        head = head.next;
      }
      if (this.__ownerID) {
        this.size = newSize;
        this._head = head;
        this.__hash = void 0;
        this.__altered = true;
        return this;
      }
      return makeStack2(newSize, head);
    };
    Stack2.prototype.__ensureOwner = function(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      if (!ownerID) {
        this.__ownerID = ownerID;
        this.__altered = false;
        return this;
      }
      return makeStack2(this.size, this._head, ownerID, this.__hash);
    };
    Stack2.prototype.__iterate = function(fn, reverse3) {
      if (reverse3) {
        return this.reverse().__iterate(fn);
      }
      var iterations = 0;
      var node = this._head;
      while (node) {
        if (fn(node.value, iterations++, this) === false) {
          break;
        }
        node = node.next;
      }
      return iterations;
    };
    Stack2.prototype.__iterator = function(type, reverse3) {
      if (reverse3) {
        return this.reverse().__iterator(type);
      }
      var iterations = 0;
      var node = this._head;
      return new Iterator3(function() {
        if (node) {
          var value = node.value;
          node = node.next;
          return iteratorValue2(type, iterations++, value);
        }
        return iteratorDone2();
      });
    };
    function isStack2(maybeStack) {
      return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
    }
    Stack2.isStack = isStack2;
    var IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
    var StackPrototype2 = Stack2.prototype;
    StackPrototype2[IS_STACK_SENTINEL] = true;
    StackPrototype2.withMutations = MapPrototype2.withMutations;
    StackPrototype2.asMutable = MapPrototype2.asMutable;
    StackPrototype2.asImmutable = MapPrototype2.asImmutable;
    StackPrototype2.wasAltered = MapPrototype2.wasAltered;
    function makeStack2(size, head, ownerID, hash3) {
      var map2 = Object.create(StackPrototype2);
      map2.size = size;
      map2._head = head;
      map2.__ownerID = ownerID;
      map2.__hash = hash3;
      map2.__altered = false;
      return map2;
    }
    var EMPTY_STACK2;
    function emptyStack2() {
      return EMPTY_STACK2 || (EMPTY_STACK2 = makeStack2(0));
    }
    function mixin2(ctor, methods) {
      var keyCopier = function(key) {
        ctor.prototype[key] = methods[key];
      };
      Object.keys(methods).forEach(keyCopier);
      Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
      return ctor;
    }
    Iterable.Iterator = Iterator3;
    mixin2(Iterable, {
      toArray: function() {
        assertNotInfinite2(this.size);
        var array = new Array(this.size || 0);
        this.valueSeq().__iterate(function(v, i) {
          array[i] = v;
        });
        return array;
      },
      toIndexedSeq: function() {
        return new ToIndexedSequence2(this);
      },
      toJS: function() {
        return this.toSeq().map(function(value) {
          return value && typeof value.toJS === "function" ? value.toJS() : value;
        }).__toJS();
      },
      toJSON: function() {
        return this.toSeq().map(function(value) {
          return value && typeof value.toJSON === "function" ? value.toJSON() : value;
        }).__toJS();
      },
      toKeyedSeq: function() {
        return new ToKeyedSequence2(this, true);
      },
      toMap: function() {
        return Map2(this.toKeyedSeq());
      },
      toObject: function() {
        assertNotInfinite2(this.size);
        var object = {};
        this.__iterate(function(v, k) {
          object[k] = v;
        });
        return object;
      },
      toOrderedMap: function() {
        return OrderedMap2(this.toKeyedSeq());
      },
      toOrderedSet: function() {
        return OrderedSet2(isKeyed2(this) ? this.valueSeq() : this);
      },
      toSet: function() {
        return Set2(isKeyed2(this) ? this.valueSeq() : this);
      },
      toSetSeq: function() {
        return new ToSetSequence2(this);
      },
      toSeq: function() {
        return isIndexed2(this) ? this.toIndexedSeq() : isKeyed2(this) ? this.toKeyedSeq() : this.toSetSeq();
      },
      toStack: function() {
        return Stack2(isKeyed2(this) ? this.valueSeq() : this);
      },
      toList: function() {
        return List2(isKeyed2(this) ? this.valueSeq() : this);
      },
      toString: function() {
        return "[Iterable]";
      },
      __toString: function(head, tail) {
        if (this.size === 0) {
          return head + tail;
        }
        return head + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + tail;
      },
      concat: function() {
        var values2 = SLICE$0.call(arguments, 0);
        return reify2(this, concatFactory2(this, values2));
      },
      includes: function(searchValue) {
        return this.some(function(value) {
          return is2(value, searchValue);
        });
      },
      entries: function() {
        return this.__iterator(ITERATE_ENTRIES2);
      },
      every: function(predicate, context) {
        assertNotInfinite2(this.size);
        var returnValue = true;
        this.__iterate(function(v, k, c) {
          if (!predicate.call(context, v, k, c)) {
            returnValue = false;
            return false;
          }
        });
        return returnValue;
      },
      filter: function(predicate, context) {
        return reify2(this, filterFactory2(this, predicate, context, true));
      },
      find: function(predicate, context, notSetValue) {
        var entry = this.findEntry(predicate, context);
        return entry ? entry[1] : notSetValue;
      },
      findEntry: function(predicate, context) {
        var found;
        this.__iterate(function(v, k, c) {
          if (predicate.call(context, v, k, c)) {
            found = [k, v];
            return false;
          }
        });
        return found;
      },
      findLastEntry: function(predicate, context) {
        return this.toSeq().reverse().findEntry(predicate, context);
      },
      forEach: function(sideEffect, context) {
        assertNotInfinite2(this.size);
        return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
      },
      join: function(separator) {
        assertNotInfinite2(this.size);
        separator = separator !== void 0 ? "" + separator : ",";
        var joined = "";
        var isFirst = true;
        this.__iterate(function(v) {
          isFirst ? isFirst = false : joined += separator;
          joined += v !== null && v !== void 0 ? v.toString() : "";
        });
        return joined;
      },
      keys: function() {
        return this.__iterator(ITERATE_KEYS2);
      },
      map: function(mapper, context) {
        return reify2(this, mapFactory2(this, mapper, context));
      },
      reduce: function(reducer2, initialReduction, context) {
        assertNotInfinite2(this.size);
        var reduction;
        var useFirst;
        if (arguments.length < 2) {
          useFirst = true;
        } else {
          reduction = initialReduction;
        }
        this.__iterate(function(v, k, c) {
          if (useFirst) {
            useFirst = false;
            reduction = v;
          } else {
            reduction = reducer2.call(context, reduction, v, k, c);
          }
        });
        return reduction;
      },
      reduceRight: function(reducer2, initialReduction, context) {
        var reversed = this.toKeyedSeq().reverse();
        return reversed.reduce.apply(reversed, arguments);
      },
      reverse: function() {
        return reify2(this, reverseFactory2(this, true));
      },
      slice: function(begin, end) {
        return reify2(this, sliceFactory2(this, begin, end, true));
      },
      some: function(predicate, context) {
        return !this.every(not2(predicate), context);
      },
      sort: function(comparator) {
        return reify2(this, sortFactory2(this, comparator));
      },
      values: function() {
        return this.__iterator(ITERATE_VALUES2);
      },
      butLast: function() {
        return this.slice(0, -1);
      },
      isEmpty: function() {
        return this.size !== void 0 ? this.size === 0 : !this.some(function() {
          return true;
        });
      },
      count: function(predicate, context) {
        return ensureSize2(predicate ? this.toSeq().filter(predicate, context) : this);
      },
      countBy: function(grouper, context) {
        return countByFactory2(this, grouper, context);
      },
      equals: function(other) {
        return deepEqual2(this, other);
      },
      entrySeq: function() {
        var iterable = this;
        if (iterable._cache) {
          return new ArraySeq2(iterable._cache);
        }
        var entriesSequence = iterable.toSeq().map(entryMapper2).toIndexedSeq();
        entriesSequence.fromEntrySeq = function() {
          return iterable.toSeq();
        };
        return entriesSequence;
      },
      filterNot: function(predicate, context) {
        return this.filter(not2(predicate), context);
      },
      findLast: function(predicate, context, notSetValue) {
        return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
      },
      first: function() {
        return this.find(returnTrue3);
      },
      flatMap: function(mapper, context) {
        return reify2(this, flatMapFactory2(this, mapper, context));
      },
      flatten: function(depth) {
        return reify2(this, flattenFactory2(this, depth, true));
      },
      fromEntrySeq: function() {
        return new FromEntriesSequence2(this);
      },
      get: function(searchKey, notSetValue) {
        return this.find(function(_, key) {
          return is2(key, searchKey);
        }, void 0, notSetValue);
      },
      getIn: function(searchKeyPath, notSetValue) {
        var nested = this;
        var iter = forceIterator(searchKeyPath);
        var step;
        while (!(step = iter.next()).done) {
          var key = step.value;
          nested = nested && nested.get ? nested.get(key, NOT_SET2) : NOT_SET2;
          if (nested === NOT_SET2) {
            return notSetValue;
          }
        }
        return nested;
      },
      groupBy: function(grouper, context) {
        return groupByFactory2(this, grouper, context);
      },
      has: function(searchKey) {
        return this.get(searchKey, NOT_SET2) !== NOT_SET2;
      },
      hasIn: function(searchKeyPath) {
        return this.getIn(searchKeyPath, NOT_SET2) !== NOT_SET2;
      },
      isSubset: function(iter) {
        iter = typeof iter.includes === "function" ? iter : Iterable(iter);
        return this.every(function(value) {
          return iter.includes(value);
        });
      },
      isSuperset: function(iter) {
        iter = typeof iter.isSubset === "function" ? iter : Iterable(iter);
        return iter.isSubset(this);
      },
      keySeq: function() {
        return this.toSeq().map(keyMapper2).toIndexedSeq();
      },
      last: function() {
        return this.toSeq().reverse().first();
      },
      max: function(comparator) {
        return maxFactory2(this, comparator);
      },
      maxBy: function(mapper, comparator) {
        return maxFactory2(this, comparator, mapper);
      },
      min: function(comparator) {
        return maxFactory2(this, comparator ? neg2(comparator) : defaultNegComparator2);
      },
      minBy: function(mapper, comparator) {
        return maxFactory2(this, comparator ? neg2(comparator) : defaultNegComparator2, mapper);
      },
      rest: function() {
        return this.slice(1);
      },
      skip: function(amount) {
        return this.slice(Math.max(0, amount));
      },
      skipLast: function(amount) {
        return reify2(this, this.toSeq().reverse().skip(amount).reverse());
      },
      skipWhile: function(predicate, context) {
        return reify2(this, skipWhileFactory2(this, predicate, context, true));
      },
      skipUntil: function(predicate, context) {
        return this.skipWhile(not2(predicate), context);
      },
      sortBy: function(mapper, comparator) {
        return reify2(this, sortFactory2(this, comparator, mapper));
      },
      take: function(amount) {
        return this.slice(0, Math.max(0, amount));
      },
      takeLast: function(amount) {
        return reify2(this, this.toSeq().reverse().take(amount).reverse());
      },
      takeWhile: function(predicate, context) {
        return reify2(this, takeWhileFactory2(this, predicate, context));
      },
      takeUntil: function(predicate, context) {
        return this.takeWhile(not2(predicate), context);
      },
      valueSeq: function() {
        return this.toIndexedSeq();
      },
      hashCode: function() {
        return this.__hash || (this.__hash = hashIterable(this));
      }
    });
    var IterablePrototype = Iterable.prototype;
    IterablePrototype[IS_ITERABLE_SENTINEL] = true;
    IterablePrototype[ITERATOR_SYMBOL2] = IterablePrototype.values;
    IterablePrototype.__toJS = IterablePrototype.toArray;
    IterablePrototype.__toStringMapper = quoteString2;
    IterablePrototype.inspect = IterablePrototype.toSource = function() {
      return this.toString();
    };
    IterablePrototype.chain = IterablePrototype.flatMap;
    IterablePrototype.contains = IterablePrototype.includes;
    (function() {
      try {
        Object.defineProperty(IterablePrototype, "length", {
          get: function() {
            if (!Iterable.noLengthWarning) {
              var stack;
              try {
                throw new Error();
              } catch (error) {
                stack = error.stack;
              }
              if (stack.indexOf("_wrapObject") === -1) {
                console && console.warn && console.warn("iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version. " + stack);
                return this.size;
              }
            }
          }
        });
      } catch (e) {
      }
    })();
    mixin2(KeyedIterable, {
      flip: function() {
        return reify2(this, flipFactory2(this));
      },
      findKey: function(predicate, context) {
        var entry = this.findEntry(predicate, context);
        return entry && entry[0];
      },
      findLastKey: function(predicate, context) {
        return this.toSeq().reverse().findKey(predicate, context);
      },
      keyOf: function(searchValue) {
        return this.findKey(function(value) {
          return is2(value, searchValue);
        });
      },
      lastKeyOf: function(searchValue) {
        return this.findLastKey(function(value) {
          return is2(value, searchValue);
        });
      },
      mapEntries: function(mapper, context) {
        var this$0 = this;
        var iterations = 0;
        return reify2(this, this.toSeq().map(function(v, k) {
          return mapper.call(context, [k, v], iterations++, this$0);
        }).fromEntrySeq());
      },
      mapKeys: function(mapper, context) {
        var this$0 = this;
        return reify2(this, this.toSeq().flip().map(function(k, v) {
          return mapper.call(context, k, v, this$0);
        }).flip());
      }
    });
    var KeyedIterablePrototype = KeyedIterable.prototype;
    KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
    KeyedIterablePrototype[ITERATOR_SYMBOL2] = IterablePrototype.entries;
    KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
    KeyedIterablePrototype.__toStringMapper = function(v, k) {
      return JSON.stringify(k) + ": " + quoteString2(v);
    };
    mixin2(IndexedIterable, {
      toKeyedSeq: function() {
        return new ToKeyedSequence2(this, false);
      },
      filter: function(predicate, context) {
        return reify2(this, filterFactory2(this, predicate, context, false));
      },
      findIndex: function(predicate, context) {
        var entry = this.findEntry(predicate, context);
        return entry ? entry[0] : -1;
      },
      indexOf: function(searchValue) {
        var key = this.toKeyedSeq().keyOf(searchValue);
        return key === void 0 ? -1 : key;
      },
      lastIndexOf: function(searchValue) {
        var key = this.toKeyedSeq().reverse().keyOf(searchValue);
        return key === void 0 ? -1 : key;
      },
      reverse: function() {
        return reify2(this, reverseFactory2(this, false));
      },
      slice: function(begin, end) {
        return reify2(this, sliceFactory2(this, begin, end, false));
      },
      splice: function(index, removeNum) {
        var numArgs = arguments.length;
        removeNum = Math.max(removeNum | 0, 0);
        if (numArgs === 0 || numArgs === 2 && !removeNum) {
          return this;
        }
        index = resolveBegin2(index, index < 0 ? this.count() : this.size);
        var spliced = this.slice(0, index);
        return reify2(this, numArgs === 1 ? spliced : spliced.concat(arrCopy2(arguments, 2), this.slice(index + removeNum)));
      },
      findLastIndex: function(predicate, context) {
        var key = this.toKeyedSeq().findLastKey(predicate, context);
        return key === void 0 ? -1 : key;
      },
      first: function() {
        return this.get(0);
      },
      flatten: function(depth) {
        return reify2(this, flattenFactory2(this, depth, false));
      },
      get: function(index, notSetValue) {
        index = wrapIndex2(this, index);
        return index < 0 || this.size === Infinity || this.size !== void 0 && index > this.size ? notSetValue : this.find(function(_, key) {
          return key === index;
        }, void 0, notSetValue);
      },
      has: function(index) {
        index = wrapIndex2(this, index);
        return index >= 0 && (this.size !== void 0 ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
      },
      interpose: function(separator) {
        return reify2(this, interposeFactory2(this, separator));
      },
      interleave: function() {
        var iterables = [this].concat(arrCopy2(arguments));
        var zipped = zipWithFactory2(this.toSeq(), IndexedSeq2.of, iterables);
        var interleaved = zipped.flatten(true);
        if (zipped.size) {
          interleaved.size = zipped.size * iterables.length;
        }
        return reify2(this, interleaved);
      },
      last: function() {
        return this.get(-1);
      },
      skipWhile: function(predicate, context) {
        return reify2(this, skipWhileFactory2(this, predicate, context, false));
      },
      zip: function() {
        var iterables = [this].concat(arrCopy2(arguments));
        return reify2(this, zipWithFactory2(this, defaultZipper2, iterables));
      },
      zipWith: function(zipper) {
        var iterables = arrCopy2(arguments);
        iterables[0] = this;
        return reify2(this, zipWithFactory2(this, zipper, iterables));
      }
    });
    IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
    IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
    mixin2(SetIterable, {
      get: function(value, notSetValue) {
        return this.has(value) ? value : notSetValue;
      },
      includes: function(value) {
        return this.has(value);
      },
      keySeq: function() {
        return this.valueSeq();
      }
    });
    SetIterable.prototype.has = IterablePrototype.includes;
    mixin2(KeyedSeq2, KeyedIterable.prototype);
    mixin2(IndexedSeq2, IndexedIterable.prototype);
    mixin2(SetSeq2, SetIterable.prototype);
    mixin2(KeyedCollection2, KeyedIterable.prototype);
    mixin2(IndexedCollection2, IndexedIterable.prototype);
    mixin2(SetCollection2, SetIterable.prototype);
    function keyMapper2(v, k) {
      return k;
    }
    function entryMapper2(v, k) {
      return [k, v];
    }
    function not2(predicate) {
      return function() {
        return !predicate.apply(this, arguments);
      };
    }
    function neg2(predicate) {
      return function() {
        return -predicate.apply(this, arguments);
      };
    }
    function quoteString2(value) {
      return typeof value === "string" ? JSON.stringify(value) : value;
    }
    function defaultZipper2() {
      return arrCopy2(arguments);
    }
    function defaultNegComparator2(a, b) {
      return a < b ? 1 : a > b ? -1 : 0;
    }
    function hashIterable(iterable) {
      if (iterable.size === Infinity) {
        return 0;
      }
      var ordered = isOrdered2(iterable);
      var keyed = isKeyed2(iterable);
      var h = ordered ? 1 : 0;
      var size = iterable.__iterate(keyed ? ordered ? function(v, k) {
        h = 31 * h + hashMerge2(hash2(v), hash2(k)) | 0;
      } : function(v, k) {
        h = h + hashMerge2(hash2(v), hash2(k)) | 0;
      } : ordered ? function(v) {
        h = 31 * h + hash2(v) | 0;
      } : function(v) {
        h = h + hash2(v) | 0;
      });
      return murmurHashOfSize2(size, h);
    }
    function murmurHashOfSize2(size, h) {
      h = imul3(h, 3432918353);
      h = imul3(h << 15 | h >>> -15, 461845907);
      h = imul3(h << 13 | h >>> -13, 5);
      h = (h + 3864292196 | 0) ^ size;
      h = imul3(h ^ h >>> 16, 2246822507);
      h = imul3(h ^ h >>> 13, 3266489909);
      h = smi2(h ^ h >>> 16);
      return h;
    }
    function hashMerge2(a, b) {
      return a ^ b + 2654435769 + (a << 6) + (a >> 2) | 0;
    }
    var Immutable2 = {
      Iterable,
      Seq: Seq2,
      Collection: Collection3,
      Map: Map2,
      OrderedMap: OrderedMap2,
      List: List2,
      Stack: Stack2,
      Set: Set2,
      OrderedSet: OrderedSet2,
      Record: Record2,
      Range: Range2,
      Repeat: Repeat2,
      is: is2,
      fromJS: fromJS2
    };
    return Immutable2;
  });
})(immutable);
var fallback = function fallback2(html) {
  var doc = document.implementation.createHTMLDocument("");
  doc.documentElement.innerHTML = html;
  return doc;
};
function parseHTML(html) {
  var doc;
  if (typeof DOMParser !== "undefined") {
    var parser2 = new DOMParser();
    doc = parser2.parseFromString(html, "text/html");
    if (doc === null || doc.body === null) {
      doc = fallback(html);
    }
  } else {
    doc = fallback(html);
  }
  return doc.body;
}
var NBSP = "&nbsp;";
var SPACE = " ";
var MAX_DEPTH = 4;
var REGEX_CR = new RegExp("\r", "g");
var REGEX_LF = new RegExp("\n", "g");
var REGEX_NBSP = new RegExp(NBSP, "g");
var REGEX_BLOCK_DELIMITER = new RegExp("\r", "g");
var blockTags = ["p", "h1", "h2", "h3", "h4", "h5", "h6", "li", "blockquote", "pre"];
var inlineTags = {
  b: "BOLD",
  code: "CODE",
  del: "STRIKETHROUGH",
  em: "ITALIC",
  i: "ITALIC",
  s: "STRIKETHROUGH",
  strike: "STRIKETHROUGH",
  strong: "BOLD",
  u: "UNDERLINE"
};
var handleMiddleware = function handleMiddleware2(maybeMiddleware, base) {
  if (maybeMiddleware && maybeMiddleware.__isMiddleware === true) {
    return maybeMiddleware(base);
  }
  return maybeMiddleware;
};
var defaultHTMLToBlock = function defaultHTMLToBlock2(nodeName, node, lastList) {
  return void 0;
};
var defaultHTMLToStyle = function defaultHTMLToStyle2(nodeName, node, currentStyle) {
  return currentStyle;
};
var defaultHTMLToEntity = function defaultHTMLToEntity2(nodeName, node) {
  return void 0;
};
var defaultTextToEntity = function defaultTextToEntity2(text) {
  return [];
};
var nullthrows2 = function nullthrows3(x) {
  if (x != null) {
    return x;
  }
  throw new Error("Got unexpected null or undefined");
};
var sanitizeDraftText = function sanitizeDraftText2(input) {
  return input.replace(REGEX_BLOCK_DELIMITER, "");
};
function getEmptyChunk() {
  return {
    text: "",
    inlines: [],
    entities: [],
    blocks: []
  };
}
function getWhitespaceChunk(inEntity) {
  var entities = new Array(1);
  if (inEntity) {
    entities[0] = inEntity;
  }
  return {
    text: SPACE,
    inlines: [immutable.exports.OrderedSet()],
    entities,
    blocks: []
  };
}
function getSoftNewlineChunk(block, depth) {
  var flat = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var data = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : immutable.exports.Map();
  if (flat === true) {
    return {
      text: "\r",
      inlines: [immutable.exports.OrderedSet()],
      entities: new Array(1),
      blocks: [{
        type: block,
        data,
        depth: Math.max(0, Math.min(MAX_DEPTH, depth))
      }],
      isNewline: true
    };
  }
  return {
    text: "\n",
    inlines: [immutable.exports.OrderedSet()],
    entities: new Array(1),
    blocks: []
  };
}
function getBlockDividerChunk(block, depth) {
  var data = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : immutable.exports.Map();
  return {
    text: "\r",
    inlines: [immutable.exports.OrderedSet()],
    entities: new Array(1),
    blocks: [{
      type: block,
      data,
      depth: Math.max(0, Math.min(MAX_DEPTH, depth))
    }]
  };
}
function getBlockTypeForTag(tag, lastList) {
  switch (tag) {
    case "h1":
      return "header-one";
    case "h2":
      return "header-two";
    case "h3":
      return "header-three";
    case "h4":
      return "header-four";
    case "h5":
      return "header-five";
    case "h6":
      return "header-six";
    case "li":
      if (lastList === "ol") {
        return "ordered-list-item";
      }
      return "unordered-list-item";
    case "blockquote":
      return "blockquote";
    case "pre":
      return "code-block";
    case "div":
    case "p":
      return "unstyled";
    default:
      return null;
  }
}
function baseCheckBlockType(nodeName, node, lastList) {
  return getBlockTypeForTag(nodeName, lastList);
}
function processInlineTag(tag, node, currentStyle) {
  var styleToCheck = inlineTags[tag];
  if (styleToCheck) {
    currentStyle = currentStyle.add(styleToCheck).toOrderedSet();
  } else if (node instanceof HTMLElement) {
    var htmlElement = node;
    currentStyle = currentStyle.withMutations(function(style) {
      if (htmlElement.style.fontWeight === "bold") {
        style.add("BOLD");
      }
      if (htmlElement.style.fontStyle === "italic") {
        style.add("ITALIC");
      }
      if (htmlElement.style.textDecoration === "underline") {
        style.add("UNDERLINE");
      }
      if (htmlElement.style.textDecoration === "line-through") {
        style.add("STRIKETHROUGH");
      }
    }).toOrderedSet();
  }
  return currentStyle;
}
function baseProcessInlineTag(tag, node) {
  var inlineStyles = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : immutable.exports.OrderedSet();
  return processInlineTag(tag, node, inlineStyles);
}
function joinChunks(A, B2) {
  var flat = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var firstInB = B2.text.slice(0, 1);
  var lastInA = A.text.slice(-1);
  var adjacentDividers = lastInA === "\r" && firstInB === "\r";
  var isJoiningBlocks = A.text !== "\r" && B2.text !== "\r";
  var addingNewlineToEmptyBlock = A.text === "\r" && !A.isNewline && B2.isNewline;
  if (adjacentDividers && (isJoiningBlocks || addingNewlineToEmptyBlock)) {
    A.text = A.text.slice(0, -1);
    A.inlines.pop();
    A.entities.pop();
    A.blocks.pop();
  }
  if (A.text.slice(-1) === "\r" && flat === true) {
    if (B2.text === SPACE || B2.text === "\n") {
      return A;
    } else if (firstInB === SPACE || firstInB === "\n") {
      B2.text = B2.text.slice(1);
      B2.inlines.shift();
      B2.entities.shift();
    }
  }
  var isNewline2 = A.text.length === 0 && B2.isNewline;
  return {
    text: A.text + B2.text,
    inlines: A.inlines.concat(B2.inlines),
    entities: A.entities.concat(B2.entities),
    blocks: A.blocks.concat(B2.blocks),
    isNewline: isNewline2
  };
}
function containsSemanticBlockMarkup(html) {
  return blockTags.some(function(tag) {
    return html.indexOf("<".concat(tag)) !== -1;
  });
}
function genFragment(node, inlineStyle, lastList, inBlock, fragmentBlockTags, depth, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity2, mergeEntityData, replaceEntityData, options, inEntity) {
  var nodeName = node.nodeName.toLowerCase();
  var newBlock = false;
  var nextBlockType = "unstyled";
  if (nodeName === "#text") {
    var text = node.textContent;
    if (text.trim() === "" && inBlock === null) {
      return getEmptyChunk();
    }
    if (text.trim() === "" && inBlock !== "code-block") {
      return getWhitespaceChunk(inEntity);
    }
    if (inBlock !== "code-block") {
      text = text.replace(REGEX_LF, SPACE);
    }
    var entities = Array(text.length).fill(inEntity);
    var offsetChange = 0;
    var textEntities = checkEntityText(text, createEntity, getEntity2, mergeEntityData, replaceEntityData).sort(rangeSort);
    textEntities.forEach(function(_ref) {
      var entity = _ref.entity, offset = _ref.offset, length = _ref.length, result = _ref.result;
      var adjustedOffset = offset + offsetChange;
      if (result === null || result === void 0) {
        result = text.substr(adjustedOffset, length);
      }
      var textArray = text.split("");
      textArray.splice.bind(textArray, adjustedOffset, length).apply(textArray, result.split(""));
      text = textArray.join("");
      entities.splice.bind(entities, adjustedOffset, length).apply(entities, Array(result.length).fill(entity));
      offsetChange += result.length - length;
    });
    return {
      text,
      inlines: Array(text.length).fill(inlineStyle),
      entities,
      blocks: []
    };
  }
  if (nodeName === "br") {
    var _blockType = inBlock;
    if (_blockType === null) {
      return getSoftNewlineChunk("unstyled", depth, true);
    }
    return getSoftNewlineChunk(_blockType || "unstyled", depth, options.flat);
  }
  var chunk = getEmptyChunk();
  var newChunk = null;
  inlineStyle = processInlineTag(nodeName, node, inlineStyle);
  inlineStyle = processCustomInlineStyles(nodeName, node, inlineStyle);
  if (nodeName === "ul" || nodeName === "ol") {
    if (lastList) {
      depth += 1;
    }
    lastList = nodeName;
    inBlock = null;
  }
  var blockInfo = checkBlockType(nodeName, node, lastList, inBlock);
  var blockType;
  var blockDataMap;
  if (blockInfo === false) {
    return getEmptyChunk();
  }
  blockInfo = blockInfo || {};
  if (typeof blockInfo === "string") {
    blockType = blockInfo;
    blockDataMap = immutable.exports.Map();
  } else {
    blockType = typeof blockInfo === "string" ? blockInfo : blockInfo.type;
    blockDataMap = blockInfo.data ? immutable.exports.Map(blockInfo.data) : immutable.exports.Map();
  }
  if (!inBlock && (fragmentBlockTags.indexOf(nodeName) !== -1 || blockType)) {
    chunk = getBlockDividerChunk(blockType || getBlockTypeForTag(nodeName, lastList), depth, blockDataMap);
    inBlock = blockType || getBlockTypeForTag(nodeName, lastList);
    newBlock = true;
  } else if (lastList && (inBlock === "ordered-list-item" || inBlock === "unordered-list-item") && nodeName === "li") {
    var listItemBlockType = getBlockTypeForTag(nodeName, lastList);
    chunk = getBlockDividerChunk(listItemBlockType, depth);
    inBlock = listItemBlockType;
    newBlock = true;
    nextBlockType = lastList === "ul" ? "unordered-list-item" : "ordered-list-item";
  } else if (inBlock && inBlock !== "atomic" && blockType === "atomic") {
    inBlock = blockType;
    newBlock = true;
    chunk = getSoftNewlineChunk(blockType, depth, true, blockDataMap);
  }
  var child = node.firstChild;
  if (child == null && inEntity && (blockType === "atomic" || inBlock === "atomic")) {
    child = document.createTextNode("a");
  }
  if (child != null) {
    nodeName = child.nodeName.toLowerCase();
  }
  var entityId = null;
  while (child) {
    entityId = checkEntityNode(nodeName, child, createEntity, getEntity2, mergeEntityData, replaceEntityData);
    newChunk = genFragment(child, inlineStyle, lastList, inBlock, fragmentBlockTags, depth, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity2, mergeEntityData, replaceEntityData, options, entityId || inEntity);
    chunk = joinChunks(chunk, newChunk, options.flat);
    var sibling = child.nextSibling;
    if (sibling && fragmentBlockTags.indexOf(nodeName) >= 0 && inBlock) {
      var newBlockInfo = checkBlockType(nodeName, child, lastList, inBlock);
      var newBlockType = void 0;
      var newBlockData = void 0;
      if (newBlockInfo !== false) {
        newBlockInfo = newBlockInfo || {};
        if (typeof newBlockInfo === "string") {
          newBlockType = newBlockInfo;
          newBlockData = immutable.exports.Map();
        } else {
          newBlockType = newBlockInfo.type || getBlockTypeForTag(nodeName, lastList);
          newBlockData = newBlockInfo.data ? immutable.exports.Map(newBlockInfo.data) : immutable.exports.Map();
        }
        chunk = joinChunks(chunk, getSoftNewlineChunk(newBlockType, depth, options.flat, newBlockData), options.flat);
      }
    }
    if (sibling) {
      nodeName = sibling.nodeName.toLowerCase();
    }
    child = sibling;
  }
  if (newBlock) {
    chunk = joinChunks(chunk, getBlockDividerChunk(nextBlockType, depth, immutable.exports.Map()), options.flat);
  }
  return chunk;
}
function getChunkForHTML(html, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity2, mergeEntityData, replaceEntityData, options, DOMBuilder) {
  html = html.trim().replace(REGEX_CR, "").replace(REGEX_NBSP, SPACE);
  var safeBody = DOMBuilder(html);
  if (!safeBody) {
    return null;
  }
  var workingBlocks = containsSemanticBlockMarkup(html) ? blockTags.concat(["div"]) : ["div"];
  var chunk = genFragment(safeBody, immutable.exports.OrderedSet(), "ul", null, workingBlocks, -1, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity2, mergeEntityData, replaceEntityData, options);
  if (chunk.text.indexOf("\r") === 0) {
    chunk = {
      text: chunk.text.slice(1),
      inlines: chunk.inlines.slice(1),
      entities: chunk.entities.slice(1),
      blocks: chunk.blocks
    };
  }
  if (chunk.text.slice(-1) === "\r") {
    chunk.text = chunk.text.slice(0, -1);
    chunk.inlines = chunk.inlines.slice(0, -1);
    chunk.entities = chunk.entities.slice(0, -1);
    chunk.blocks.pop();
  }
  if (chunk.blocks.length === 0) {
    chunk.blocks.push({
      type: "unstyled",
      data: immutable.exports.Map(),
      depth: 0
    });
  }
  if (chunk.text.split("\r").length === chunk.blocks.length + 1) {
    chunk.blocks.unshift({
      type: "unstyled",
      data: immutable.exports.Map(),
      depth: 0
    });
  }
  return chunk;
}
function convertFromHTMLtoContentBlocks(html, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity2, mergeEntityData, replaceEntityData, options, DOMBuilder, generateKey) {
  var chunk = getChunkForHTML(html, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity2, mergeEntityData, replaceEntityData, options, DOMBuilder);
  if (chunk == null) {
    return [];
  }
  var start = 0;
  return chunk.text.split("\r").map(function(textBlock, blockIndex) {
    textBlock = sanitizeDraftText(textBlock);
    var end = start + textBlock.length;
    var inlines = nullthrows2(chunk).inlines.slice(start, end);
    var entities = nullthrows2(chunk).entities.slice(start, end);
    var characterList = immutable.exports.List(inlines.map(function(style, entityIndex) {
      var data = {
        style,
        entity: null
      };
      if (entities[entityIndex]) {
        data.entity = entities[entityIndex];
      }
      return Draft.CharacterMetadata.create(data);
    }));
    start = end + 1;
    return new Draft.ContentBlock({
      key: generateKey(),
      type: nullthrows2(chunk).blocks[blockIndex].type,
      data: nullthrows2(chunk).blocks[blockIndex].data,
      depth: nullthrows2(chunk).blocks[blockIndex].depth,
      text: textBlock,
      characterList
    });
  });
}
var convertFromHTML = function convertFromHTML2(_ref2) {
  var _ref2$htmlToStyle = _ref2.htmlToStyle, htmlToStyle = _ref2$htmlToStyle === void 0 ? defaultHTMLToStyle : _ref2$htmlToStyle, _ref2$htmlToEntity = _ref2.htmlToEntity, htmlToEntity = _ref2$htmlToEntity === void 0 ? defaultHTMLToEntity : _ref2$htmlToEntity, _ref2$textToEntity = _ref2.textToEntity, textToEntity = _ref2$textToEntity === void 0 ? defaultTextToEntity : _ref2$textToEntity, _ref2$htmlToBlock = _ref2.htmlToBlock, htmlToBlock = _ref2$htmlToBlock === void 0 ? defaultHTMLToBlock : _ref2$htmlToBlock;
  return function(html) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      flat: false
    };
    var DOMBuilder = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : parseHTML;
    var generateKey = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Draft.genKey;
    var contentState = Draft.ContentState.createFromText("");
    var createEntityWithContentState = function createEntityWithContentState2() {
      if (contentState.createEntity) {
        var _contentState;
        contentState = (_contentState = contentState).createEntity.apply(_contentState, arguments);
        return contentState.getLastCreatedEntityKey();
      }
      return Draft.Entity.create.apply(Draft.Entity, arguments);
    };
    var getEntityWithContentState = function getEntityWithContentState2() {
      if (contentState.getEntity) {
        var _contentState2;
        return (_contentState2 = contentState).getEntity.apply(_contentState2, arguments);
      }
      return Draft.Entity.get.apply(Draft.Entity, arguments);
    };
    var mergeEntityDataWithContentState = function mergeEntityDataWithContentState2() {
      if (contentState.mergeEntityData) {
        var _contentState3;
        contentState = (_contentState3 = contentState).mergeEntityData.apply(_contentState3, arguments);
        return;
      }
      Draft.Entity.mergeData.apply(Draft.Entity, arguments);
    };
    var replaceEntityDataWithContentState = function replaceEntityDataWithContentState2() {
      if (contentState.replaceEntityData) {
        var _contentState4;
        contentState = (_contentState4 = contentState).replaceEntityData.apply(_contentState4, arguments);
        return;
      }
      Draft.Entity.replaceData.apply(Draft.Entity, arguments);
    };
    var contentBlocks = convertFromHTMLtoContentBlocks(html, handleMiddleware(htmlToStyle, baseProcessInlineTag), handleMiddleware(htmlToEntity, defaultHTMLToEntity), handleMiddleware(textToEntity, defaultTextToEntity), handleMiddleware(htmlToBlock, baseCheckBlockType), createEntityWithContentState, getEntityWithContentState, mergeEntityDataWithContentState, replaceEntityDataWithContentState, options, DOMBuilder, generateKey);
    var blockMap = Draft.BlockMapBuilder.createFromArray(contentBlocks);
    var firstBlockKey = contentBlocks[0].getKey();
    return contentState.merge({
      blockMap,
      selectionBefore: Draft.SelectionState.createEmpty(firstBlockKey),
      selectionAfter: Draft.SelectionState.createEmpty(firstBlockKey)
    });
  };
};
var convertFromHTML$1 = function() {
  if (arguments.length >= 1 && typeof (arguments.length <= 0 ? void 0 : arguments[0]) === "string") {
    return convertFromHTML({}).apply(void 0, arguments);
  }
  return convertFromHTML.apply(void 0, arguments);
};
const Link$2 = (props) => {
  const {
    url
  } = props.contentState.getEntity(props.entityKey).getData();
  return /* @__PURE__ */ jsx("a", {
    href: url,
    className: "k-u-link k-u-link-primary1",
    target: "_blank",
    rel: "nofollow noopener noreferrer",
    children: props.children
  });
};
const linkStrategy$2 = (contentBlock, callback, contentState) => {
  contentBlock.findEntityRanges((character) => {
    const entityKey = character.getEntity();
    return entityKey !== null && contentState.getEntity(entityKey).getType() === "LINK";
  }, callback);
};
var linkDecorator = {
  strategy: linkStrategy$2,
  component: Link$2
};
function arrayIncludesWith$1(array, value, comparator) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}
var _arrayIncludesWith = arrayIncludesWith$1;
var Set$1 = _Set, noop = noop_1, setToArray$1 = _setToArray;
var INFINITY = 1 / 0;
var createSet$1 = !(Set$1 && 1 / setToArray$1(new Set$1([, -0]))[1] == INFINITY) ? noop : function(values2) {
  return new Set$1(values2);
};
var _createSet = createSet$1;
var SetCache = _SetCache, arrayIncludes = _arrayIncludes, arrayIncludesWith = _arrayIncludesWith, cacheHas = _cacheHas, createSet = _createSet, setToArray = _setToArray;
var LARGE_ARRAY_SIZE = 200;
function baseUniq$1(array, iteratee2, comparator) {
  var index = -1, includes3 = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes3 = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set3 = iteratee2 ? null : createSet(array);
    if (set3) {
      return setToArray(set3);
    }
    isCommon = false;
    includes3 = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee2 ? [] : result;
  }
  outer:
    while (++index < length) {
      var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee2) {
          seen.push(computed);
        }
        result.push(value);
      } else if (!includes3(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
var _baseUniq = baseUniq$1;
var baseUniq = _baseUniq;
function uniq$1(array) {
  return array && array.length ? baseUniq(array) : [];
}
var uniq_1 = uniq$1;
var convert$2 = convert_1, func$2 = convert$2("uniq", uniq_1, _falseOptions);
func$2.placeholder = placeholder;
var uniq = func$2;
const isGif = (url) => /(.gif)$/gim.test(url);
const isSvg = (url) => /(.svg)$/gim.test(url);
const ALLOWED_EXTENSIONS = ["jpg", "jpeg", "png", "webp"];
const isServerAllowed = (path, config) => {
  const server = path.replace(/https?:\/\/([0-9a-z.:]+)\/\S+/gi, "$1");
  return (config == null ? void 0 : config.allowedServers.indexOf(server)) > -1;
};
const assetUrl = (assetPath) => {
  return encodeURIComponent(encodeURIComponent(assetPath));
};
const urlBuilder = (path, {
  width = 0,
  height = 0,
  filters = [],
  upscale = true
}, config) => {
  if (isSvg(path) || isGif(path) || !ENABLE_RESPONSIVE_IMAGES) {
    return path;
  }
  const imageUrl = assetUrl(path);
  const server = config == null ? void 0 : config.host;
  const hostAndSize = `${server}/${width}x${height}`;
  if (!upscale) {
    filters.push("no_upscale:1");
  }
  let extension = "";
  filters.forEach((filter3) => {
    const [filterKey2, filterValue] = filter3.split(":");
    if (filterKey2 === "format" && ALLOWED_EXTENSIONS.includes(filterValue)) {
      extension = `.${filterValue}`;
    }
  });
  const chainedFilters = uniq(filters).join(",");
  if (!chainedFilters)
    return `${hostAndSize}/options:false/${imageUrl}`;
  return `${hostAndSize}/${chainedFilters}/${imageUrl}${extension}`;
};
const responsiveImageAttributes = (imagePath, {
  imageSizes,
  breakpoints,
  imageSizesInViewport,
  ratio = 0,
  upscale = true,
  format = "jpg",
  config
} = {}) => {
  if (!imagePath)
    return;
  if (isSvg(imagePath) || isGif(imagePath) || !ENABLE_RESPONSIVE_IMAGES || !isServerAllowed(imagePath, config)) {
    return {
      src: imagePath,
      srcSet: "",
      sizes: ""
    };
  }
  if (breakpoints.length !== imageSizesInViewport.length)
    return;
  const formatString = `format:${format}`;
  const filters = ["quality:90", formatString];
  const sortedImageSizes = [...imageSizes].sort((a, b) => b - a);
  const imageWidth = sortedImageSizes[0];
  const src2 = urlBuilder(imagePath, {
    width: imageWidth,
    height: Math.floor(imageWidth * ratio),
    filters,
    upscale
  }, config);
  const srcSet = imageSizes.reduce((sizeAcc, sizeCur) => {
    return sizeAcc.concat(`${urlBuilder(imagePath, {
      width: sizeCur,
      height: Math.floor(sizeCur * ratio),
      filters,
      upscale
    }, config)} ${sizeCur}w`);
  }, []).join(", ");
  const sizes = breakpoints.reduce((acc, cur, idx) => {
    return acc.concat(`(min-width: ${cur}px) calc(${imageSizesInViewport[idx]})`);
  }, [`calc(${imageSizesInViewport[0]})`]).reverse().join(", ");
  return {
    src: src2,
    srcSet,
    sizes
  };
};
const ONE_IN_XXS_CONTAINER = `100vw - ${CONTAINER_PADDING_THIN * 2}px`;
const ONE_IN_7_COLS = `(100vw - ${CONTAINER_PADDING * 2}px) * (7/12)`;
const ONE_IN_XL_7_COLS = `(${ScreenConfig.XL.min - CONTAINER_PADDING * 2}px) * (7/12))`;
const IMAGE_SIZES = [280, 335, 380, 785, 944];
function getNextClosestValue(array, value) {
  for (var i = 0; i < array.length; i++) {
    if (array[i] >= value) {
      return array[i];
    }
  }
}
const Image$1 = (props) => {
  const [{
    configResponsiveImageHandler
  }] = useContext(EditorContext);
  const {
    src: src2,
    alt,
    style,
    width,
    height,
    imageLink
  } = props.contentState.getEntity(props.entityKey).getData();
  const lazyComponentRef = useRef(null);
  const isLazyTriggered = useLazyObserver(lazyComponentRef);
  const defaultImage = `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 300'><path fill='%23caf4fe' d='M0 0h400v300H0z'/></svg>`;
  let responsiveImage = {
    src: src2,
    sizes: null,
    srcSet: null
  };
  if (isServerAllowed(src2, configResponsiveImageHandler)) {
    responsiveImage = style.width && style.height ? responsiveImageAttributes(src2, {
      imageSizes: [getNextClosestValue(IMAGE_SIZES, parseInt(style.width))],
      breakpoints: [0],
      imageSizesInViewport: [parseInt(style.width)],
      upscale: false,
      resolutions: 1,
      config: configResponsiveImageHandler
    }) : responsiveImageAttributes(src2, {
      imageSizes: IMAGE_SIZES,
      breakpoints: [0, 1080, 1440],
      imageSizesInViewport: [ONE_IN_XXS_CONTAINER, ONE_IN_7_COLS, ONE_IN_XL_7_COLS],
      upscale: false,
      config: configResponsiveImageHandler
    });
  }
  const image = /* @__PURE__ */ jsx("img", {
    src: isLazyTriggered ? responsiveImage.src : defaultImage,
    srcSet: isLazyTriggered ? responsiveImage.srcSet : "",
    sizes: responsiveImage.sizes,
    alt,
    width: width && height ? width : void 0,
    height: width && height ? height : void 0,
    style: {
      width: style["width"]
    }
  });
  if (imageLink) {
    return /* @__PURE__ */ jsx("a", {
      href: imageLink,
      className: "k-u-align-center",
      target: "_blank",
      rel: "nofollow noopener noreferrer",
      ref: lazyComponentRef,
      children: image
    });
  }
  return /* @__PURE__ */ jsx("div", {
    className: "k-u-align-center",
    ref: lazyComponentRef,
    children: image
  });
};
const imageStrategy$2 = (contentBlock, callback, contentState) => {
  contentBlock.findEntityRanges((character) => {
    const entityKey = character.getEntity();
    return entityKey !== null && contentState.getEntity(entityKey).getType() === "IMAGE";
  }, callback);
};
var responsiveImageDecorator = {
  strategy: imageStrategy$2,
  component: Image$1
};
const LazyLoader = (_a) => {
  var _b = _a, {
    children
  } = _b, others = __objRest(_b, [
    "children"
  ]);
  const [isVisible, setVisible] = useState(false);
  const lazyComponentRef = useRef(null);
  useEffect(() => {
    LazyObserver.observe(lazyComponentRef.current, () => setVisible(true));
    return () => LazyObserver.unobserve(lazyComponentRef.current);
  }, []);
  return /* @__PURE__ */ jsx("div", __spreadProps(__spreadValues({
    ref: lazyComponentRef
  }, others), {
    children: isVisible && children
  }));
};
const Media = (props) => {
  const {
    html
  } = props.contentState.getEntity(props.entityKey).getData();
  return /* @__PURE__ */ jsx(LazyLoader, {
    children: /* @__PURE__ */ jsx(ResponsiveIframeContainer, {
      ratio: 67.5,
      children: parseHtml(html, {
        sanitize: false
      })
    })
  });
};
const mediaStrategy = (contentBlock, callback, contentState) => {
  contentBlock.findEntityRanges((character) => {
    const entityKey = character.getEntity();
    return entityKey !== null && contentState.getEntity(entityKey).getType() === "MEDIA";
  }, callback);
};
var lazyMediaDecorator = {
  strategy: mediaStrategy,
  component: Media
};
const Image = (props) => {
  const {
    src: src2,
    alt,
    style,
    width,
    height,
    imageLink
  } = props.contentState.getEntity(props.entityKey).getData();
  const lazyComponentRef = useRef(null);
  const isLazyTriggered = useLazyObserver(lazyComponentRef);
  const defaultImage = `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 300'><path fill='%23caf4fe' d='M0 0h400v300H0z'/></svg>`;
  const image = /* @__PURE__ */ jsx("img", {
    src: isLazyTriggered ? src2 : defaultImage,
    alt,
    width: width && height ? width : void 0,
    height: width && height ? height : void 0,
    style: {
      width: style["width"]
    }
  });
  if (imageLink) {
    return /* @__PURE__ */ jsx("a", {
      href: imageLink,
      className: "k-u-align-center",
      target: "_blank",
      rel: "nofollow noopener noreferrer",
      ref: lazyComponentRef,
      children: image
    });
  }
  return /* @__PURE__ */ jsx("div", {
    className: "k-u-align-center",
    ref: lazyComponentRef,
    children: image
  });
};
const imageStrategy$1 = (contentBlock, callback, contentState) => {
  contentBlock.findEntityRanges((character) => {
    const entityKey = character.getEntity();
    return entityKey !== null && contentState.getEntity(entityKey).getType() === "IMAGE";
  }, callback);
};
var lazyImageDecorator = {
  strategy: imageStrategy$1,
  component: Image
};
const Separator = () => {
  return /* @__PURE__ */ jsx("hr", {});
};
const separatorStrategy = (contentBlock, callback, contentState) => {
  contentBlock.findEntityRanges((character) => {
    const entityKey = character.getEntity();
    return entityKey !== null && contentState.getEntity(entityKey).getType() === "SEPARATOR";
  }, callback);
};
var separatorDecorator = {
  strategy: separatorStrategy,
  component: Separator
};
const BlockQuote = (props) => {
  return props.children.length === 1 && props.children[0].props.text === " " ? null : /* @__PURE__ */ jsx("span", {
    children: props.children
  });
};
const blockQuoteStrategy = (contentBlock, callback, contentState) => {
  contentBlock.findEntityRanges((character) => {
    const entityKey = character.getEntity();
    return entityKey !== null && contentState.getEntity(entityKey).getType() === "BLOCKQUOTE";
  }, callback);
};
var quoteDecorator = {
  strategy: blockQuoteStrategy,
  component: BlockQuote
};
var baseIsEqual = _baseIsEqual;
function isEqual$1(value, other) {
  return baseIsEqual(value, other);
}
var isEqual_1 = isEqual$1;
var convert$1 = convert_1, func$1 = convert$1("isEqual", isEqual_1);
func$1.placeholder = placeholder;
var isEqual = func$1;
var FUNC_ERROR_TEXT = "Expected a function";
function negate$1(predicate) {
  if (typeof predicate != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return !predicate.call(this);
      case 1:
        return !predicate.call(this, args[0]);
      case 2:
        return !predicate.call(this, args[0], args[1]);
      case 3:
        return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}
var negate_1 = negate$1;
var assignValue = _assignValue, castPath$1 = _castPath, isIndex = _isIndex, isObject$1 = isObject_1, toKey = _toKey;
function baseSet$1(object, path, value, customizer) {
  if (!isObject$1(object)) {
    return object;
  }
  path = castPath$1(path, object);
  var index = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index < length) {
    var key = toKey(path[index]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject$1(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var _baseSet = baseSet$1;
var baseGet = _baseGet, baseSet = _baseSet, castPath = _castPath;
function basePickBy$1(object, paths, predicate) {
  var index = -1, length = paths.length, result = {};
  while (++index < length) {
    var path = paths[index], value = baseGet(object, path);
    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}
var _basePickBy = basePickBy$1;
var arrayMap = _arrayMap, baseIteratee$1 = _baseIteratee, basePickBy = _basePickBy, getAllKeysIn = _getAllKeysIn;
function pickBy$1(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap(getAllKeysIn(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee$1(predicate);
  return basePickBy(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}
var pickBy_1 = pickBy$1;
var baseIteratee = _baseIteratee, negate = negate_1, pickBy = pickBy_1;
function omitBy$1(object, predicate) {
  return pickBy(object, negate(baseIteratee(predicate)));
}
var omitBy_1 = omitBy$1;
var convert = convert_1, func = convert("omitBy", omitBy_1);
func.placeholder = placeholder;
var omitBy = func;
const getImageNode$1 = get$1("children[0]");
const isImageWrapper$1 = flow(get$1("children[0].nodeName"), isEqual("IMG"));
const isLinkWrapped$1 = flow(get$1("parentElement.nodeName"), isEqual("A"));
const filterEmptyStyleProps$1 = omitBy(isEmpty);
const performanceDecorators = new Draft.CompositeDecorator([linkDecorator, responsiveImageDecorator, lazyMediaDecorator, separatorDecorator, quoteDecorator]);
const lazyDecorators = new Draft.CompositeDecorator([linkDecorator, lazyImageDecorator, lazyMediaDecorator, separatorDecorator, quoteDecorator]);
const converter$1 = (html) => {
  return convertFromHTML$1({
    htmlToStyle: (nodeName, node, currentStyle) => {
      if (node.style && node.style["margin-left"] !== "") {
        return currentStyle.add("MARGIN_LEFT");
      }
      return currentStyle;
    },
    htmlToEntity: (nodeName, node, createEntity) => {
      if (nodeName === "a") {
        if (isImageWrapper$1(node)) {
          const imageNode = getImageNode$1(node);
          return createEntity("IMAGE", "IMMUTABLE", {
            src: imageNode.src,
            alt: imageNode.alt,
            width: imageNode.width,
            height: imageNode.height,
            style: filterEmptyStyleProps$1(imageNode.style),
            imageLink: node.href
          });
        }
        return createEntity("LINK", "MUTABLE", {
          url: node.href
        });
      }
      if (nodeName === "img" && !isLinkWrapped$1(node)) {
        return createEntity("IMAGE", "IMMUTABLE", {
          src: node.src,
          alt: node.alt,
          width: node.width,
          height: node.height,
          style: filterEmptyStyleProps$1(node.style)
        });
      }
      if (nodeName === "iframe") {
        return createEntity("MEDIA", "IMMUTABLE", {
          html: node.outerHTML
        });
      }
      if (nodeName === "hr") {
        return createEntity("SEPARATOR", "IMMUTABLE");
      }
      if (nodeName === "blockquote") {
        return createEntity("BLOCKQUOTE", "IMMUTABLE");
      }
    },
    htmlToBlock: (nodeName, node) => {
      if (["img", "iframe", "hr"].includes(nodeName) || isImageWrapper$1(node)) {
        return "atomic";
      }
      if (node.textContent === " ") {
        return "br";
      }
      if (nodeName === "p" && node.style["text-align"] !== void 0) {
        return {
          type: "paragraph",
          data: {
            textAlign: node.style["text-align"]
          }
        };
      }
      if (nodeName === "h2" && node.style["text-align"] !== void 0) {
        return {
          type: "header-two",
          data: {
            textAlign: node.style["text-align"]
          }
        };
      }
      if (nodeName === "h3" && node.style["text-align"] !== void 0) {
        return {
          type: "header-three",
          data: {
            textAlign: node.style["text-align"]
          }
        };
      }
      if (nodeName === "h4" && node.style["text-align"] !== void 0) {
        return {
          type: "header-four",
          data: {
            textAlign: node.style["text-align"]
          }
        };
      }
      if (nodeName === "p") {
        return "paragraph";
      }
    }
  })(html);
};
const getImageNode = get$1("children[0]");
const isImageWrapper = flow(get$1("children[0].nodeName"), isEqual("IMG"));
const isLinkWrapped = flow(get$1("parentElement.nodeName"), isEqual("A"));
const filterEmptyStyleProps = omitBy(isEmpty);
new Draft.CompositeDecorator([linkDecorator, responsiveImageDecorator, lazyMediaDecorator, separatorDecorator, quoteDecorator]);
new Draft.CompositeDecorator([linkDecorator, lazyImageDecorator, lazyMediaDecorator, separatorDecorator, quoteDecorator]);
const converter = (html) => {
  return convertFromHTML$1({
    htmlToStyle: (nodeName, node, currentStyle) => {
      if (node.style && node.style["margin-left"] !== "") {
        return currentStyle.add("MARGIN_LEFT");
      }
      return currentStyle;
    },
    htmlToEntity: (nodeName, node, createEntity) => {
      if (nodeName === "a") {
        if (isImageWrapper(node)) {
          const imageNode = getImageNode(node);
          return createEntity("IMAGE", "IMMUTABLE", {
            src: imageNode.src,
            alt: imageNode.alt,
            width: imageNode.width,
            height: imageNode.height,
            style: filterEmptyStyleProps(imageNode.style),
            imageLink: node.href
          });
        }
        return createEntity("LINK", "MUTABLE", {
          url: node.href
        });
      }
      if (nodeName === "img" && !isLinkWrapped(node)) {
        return createEntity("IMAGE", "IMMUTABLE", {
          src: node.src,
          alt: node.alt,
          width: node.width,
          height: node.height,
          style: filterEmptyStyleProps(node.style)
        });
      }
      if (nodeName === "iframe") {
        return createEntity("MEDIA", "IMMUTABLE", {
          html: node.outerHTML
        });
      }
      if (nodeName === "hr") {
        return createEntity("SEPARATOR", "IMMUTABLE");
      }
      if (nodeName === "blockquote") {
        return createEntity("BLOCKQUOTE", "IMMUTABLE");
      }
    },
    htmlToBlock: (nodeName, node) => {
      if (["img", "iframe", "hr"].includes(nodeName)) {
        return "atomic";
      }
      if (node.textContent === " ") {
        return "br";
      }
      if (nodeName === "p" && node.style["text-align"] !== void 0) {
        return {
          type: "paragraph",
          data: {
            textAlign: node.style["text-align"]
          }
        };
      }
      if (nodeName === "h2" && node.style["text-align"] !== void 0) {
        return {
          type: "header-two",
          data: {
            textAlign: node.style["text-align"]
          }
        };
      }
      if (nodeName === "h3" && node.style["text-align"] !== void 0) {
        return {
          type: "header-three",
          data: {
            textAlign: node.style["text-align"]
          }
        };
      }
      if (nodeName === "h4" && node.style["text-align"] !== void 0) {
        return {
          type: "header-four",
          data: {
            textAlign: node.style["text-align"]
          }
        };
      }
      if (nodeName === "p") {
        return "paragraph";
      }
    }
  })(html);
};
var classnames = { exports: {} };
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
(function(module) {
  (function() {
    var hasOwn2 = {}.hasOwnProperty;
    function classNames2() {
      var classes = [];
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (!arg)
          continue;
        var argType = typeof arg;
        if (argType === "string" || argType === "number") {
          classes.push(arg);
        } else if (Array.isArray(arg)) {
          if (arg.length) {
            var inner = classNames2.apply(null, arg);
            if (inner) {
              classes.push(inner);
            }
          }
        } else if (argType === "object") {
          if (arg.toString === Object.prototype.toString) {
            for (var key in arg) {
              if (hasOwn2.call(arg, key) && arg[key]) {
                classes.push(key);
              }
            }
          } else {
            classes.push(arg.toString());
          }
        }
      }
      return classes.join(" ");
    }
    if (module.exports) {
      classNames2.default = classNames2;
      module.exports = classNames2;
    } else {
      window.classNames = classNames2;
    }
  })();
})(classnames);
var classNames = classnames.exports;
const blockRenderMap = Map$1({
  paragraph: {
    element: "p"
  }
});
const convertContent = (html, isEdition = false) => {
  const initialContentState = isEdition ? converter(html) : converter$1(html);
  return initialContentState.set("blockMap", initialContentState.getBlockMap().filter((contentblock) => {
    return !(!["atomic", "br"].includes(contentblock.getType()) && contentblock.getText() === "");
  }));
};
const getRawContent = (html, isEdition = false) => {
  return Draft.convertToRaw(convertContent(html, isEdition));
};
const createContent = (html) => {
  return Draft.EditorState.createWithContent(convertContent(html));
};
const HtmlEditor = ({
  html,
  perfEnabled,
  useRichTextStyle
}) => {
  if (!html)
    return null;
  if (!domElementHelper.canUseDom()) {
    const defaultImage = `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 300'><path fill='%23caf4fe' d='M0 0h400v300H0z'/></svg>`;
    const imageRegEx = /<img([\S ]*?) src="[\S]+?"/gm;
    const imageReplacer = `<img $1 src="${defaultImage}"`;
    html = html.replace(imageRegEx, imageReplacer);
    if (perfEnabled) {
      html = html.replace(/<(img|iframe)([\S ]+?) (src=")/gm, "<$1 $2 data-$3");
    }
    return /* @__PURE__ */ jsx("section", {
      className: classNames({
        "kiss-RichText": useRichTextStyle
      }),
      children: parseHtml(html)
    });
  }
  return /* @__PURE__ */ jsx("section", {
    className: classNames({
      "kiss-RichText": useRichTextStyle
    }),
    children: /* @__PURE__ */ jsx(Draft.Editor, {
      editorState: Draft.EditorState.set(html !== null ? createContent(html) : Draft.EditorState.createEmpty(), {
        decorator: perfEnabled ? performanceDecorators : lazyDecorators
      }),
      onChange: () => null,
      blockRenderMap: Draft.DefaultDraftBlockRenderMap.merge(blockRenderMap),
      blockStyleFn: (contentBlock) => {
        const textAlignStyle = contentBlock.getData().get("textAlign");
        switch (textAlignStyle) {
          case "right":
            return "draft-align-right";
          case "center":
            return "draft-align-center";
          case "left":
            return "draft-align-left";
          default:
            return "";
        }
      },
      readOnly: true
    })
  });
};
HtmlEditor.propTypes = {
  useRichTextStyle: PropTypes.bool
};
HtmlEditor.defaultProps = {
  useRichTextStyle: true
};
const StyledButton = styled((props) => /* @__PURE__ */ jsx(Button$1, __spreadValues({
  as: "button",
  type: "button"
}, props)))`
  ${BUTTON_STYLE_ICON};
  ${buttonModifierStyles("hydrogen")};

  &.Editor__toolbar__button--large {
    width: ${pxToRem(80)};
  }

  // Lithium modifier.
  &.Editor__toolbar__button--isSelected,
  :hover,
  :focus {
    border-color: ${COLORS.primary4};
    background-color: ${COLORS.background1};
    color: ${COLORS.primary1};

    svg,
    path {
      fill: ${COLORS.primary1};
    }
  }

  :disabled {
    border-color: ${COLORS.line2};
    background-color: ${COLORS.line2};
    color: ${COLORS.background1};

    svg,
    path {
      fill: ${COLORS.background1};
      pointer-events: none;
    }
  }
`;
const iconComponents = {
  format_bold: BoldIcon,
  format_italic: ItalicIcon,
  format_list_bulleted: ListIcon,
  ["k-u-align-left"]: AlignLeftIcon,
  ["k-u-align-center"]: AlignCenterIcon,
  ["k-u-align-right"]: AlignRightIcon,
  image: ImageIcon,
  video: VideoIcon,
  link: LinkIcon,
  button_link: EditorButtonIcon,
  quote: BlockquoteIcon
};
const Button = ({
  onToggle,
  style,
  active,
  icon,
  disabled,
  className
}) => {
  const [{
    focus,
    translations
  }] = useContext(EditorContext);
  const Icon = iconComponents[icon];
  const title = translations == null ? void 0 : translations.controls[active ? `activated_${icon}` : icon];
  const handleMouseDown = (e) => {
    e.preventDefault();
    if (disabled)
      return;
    onToggle(style);
  };
  return /* @__PURE__ */ jsx(StyledButton, {
    disabled,
    className: classNames(className, {
      "Editor__toolbar__button--isSelected": active && focus
    }),
    onMouseDown: handleMouseDown,
    title,
    "aria-label": title,
    children: /* @__PURE__ */ jsx(Icon, {})
  });
};
Button.propTypes = {
  disabled: PropTypes.bool,
  active: PropTypes.bool,
  onToggle: PropTypes.func
};
Button.defaultProps = {
  disabled: false,
  active: false,
  onToggle: () => null
};
const Label = ({
  htmlFor,
  size,
  label,
  children,
  tooltip
}) => {
  var _a;
  const [{
    translations
  }] = useContext(EditorContext);
  return /* @__PURE__ */ jsx(Field.Label, {
    labelProps: {
      htmlFor,
      size
    },
    tooltipId: `tooltip-${htmlFor}`,
    tooltip,
    tooltipProps: {
      actionLabel: (_a = translations == null ? void 0 : translations.form) == null ? void 0 : _a.tooltip_action_label
    },
    children: label || children
  });
};
Label.propTypes = {
  htmlFor: PropTypes.string.isRequired,
  size: PropTypes.string,
  label: PropTypes.string,
  tooltip: PropTypes.string
};
Label.defaultProps = {
  size: "micro"
};
const InputText = (_c) => {
  var _d = _c, {
    name,
    form,
    placeholder: placeholder2,
    limit,
    unit,
    type,
    digits,
    disabled,
    rows,
    defaultValue,
    style,
    className,
    onFocus: onFocus2,
    onChange,
    onBlur: onBlur2,
    normalize: normalize2,
    validate
  } = _d, others = __objRest(_d, [
    "name",
    "form",
    "placeholder",
    "limit",
    "unit",
    "type",
    "digits",
    "disabled",
    "rows",
    "defaultValue",
    "style",
    "className",
    "onFocus",
    "onChange",
    "onBlur",
    "normalize",
    "validate"
  ]);
  const [field, meta, {
    setValue
  }] = useField({
    name,
    validate
  });
  useEffect(() => {
    if (!defaultValue)
      return;
    if (field.value)
      return;
    setValue(defaultValue);
  }, []);
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsx("div", {
      style,
      className,
      children: /* @__PURE__ */ jsx(Field.Input, __spreadValues(__spreadProps(__spreadValues({}, field), {
        id: name,
        error: meta.error && meta.touched,
        onFocus: onFocus2,
        onChange: (e) => {
          field.onChange(e);
          if (normalize2) {
            setValue(normalize2(e.target.value));
          }
          onChange(e);
        },
        onBlur: (e) => {
          field.onBlur(e);
          if (normalize2) {
            setValue(normalize2(e.target.value));
          }
          onBlur2(e);
        },
        "data-test-id": name,
        placeholder: placeholder2,
        limit,
        unit,
        type,
        tag: type,
        rows,
        digits,
        disabled
      }), others))
    }), /* @__PURE__ */ jsx(ErrorMessage, {
      name,
      children: (msg) => /* @__PURE__ */ jsx(Field.ErrorMessage, {
        children: msg
      })
    })]
  });
};
InputText.defaultProps = {
  type: "text",
  disabled: false,
  validate: () => {
  },
  onFocus: () => {
  },
  onBlur: () => {
  },
  onChange: () => {
  }
};
InputText.propTypes = {
  name: PropTypes.string.isRequired,
  placeholder: PropTypes.string,
  defaultValue: PropTypes.string,
  rows: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  limit: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  unit: PropTypes.string,
  type: PropTypes.string,
  digits: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  disabled: PropTypes.bool,
  validate: PropTypes.func,
  onFocus: PropTypes.func,
  onBlur: PropTypes.func,
  onChange: PropTypes.func,
  normalize: PropTypes.func
};
const FormikInputWithButton = (_e) => {
  var _f = _e, {
    name,
    onClick,
    isDisabled
  } = _f, props = __objRest(_f, [
    "name",
    "onClick",
    "isDisabled"
  ]);
  const [field, meta] = useField(name);
  return /* @__PURE__ */ jsx(Fragment, {
    children: /* @__PURE__ */ jsx(TextInputWithButton, __spreadValues(__spreadValues({
      id: name,
      buttonProps: {
        onClick,
        disabled: isDisabled || meta.error && meta.touched
      },
      error: meta.error && meta.touched
    }, field), props))
  });
};
FormikInputWithButton.defaultProps = {
  onClick: () => {
  },
  isDisabled: false
};
FormikInputWithButton.propTypes = {
  name: PropTypes.string.isRequired,
  onClick: PropTypes.func,
  isDisabled: PropTypes.bool
};
const animation = "1.6s ease-in-out 0s infinite";
const heartAnim = keyframes`
  0% { transform: translateX(0); }
  20%, 30% { transform: translateX(${pxToRem(7)}); }
  50%, 100% { transform: translateX(0); }
`;
const circleAnim = keyframes`
  0%, 5% { transform: rotate(0deg); }
  46%, 100% { transform: rotate(360deg); }
`;
const StyledLoadingAnimation = styled.div`
  .kiss-LoadingAnimation__svg {
    overflow: visible;
    width: ${pxToRem(21)};
    height: ${pxToRem(16)};
  }

  .kiss-LoadingAnimation__path-heart {
    animation: ${animation} ${heartAnim};
    backface-visibility: hidden;
  }

  .kiss-LoadingAnimation__path-circle {
    animation: ${animation} ${circleAnim};
    transform-origin: ${pxToRem(8)} ${pxToRem(8)};
    backface-visibility: hidden;
  }
`;
const LoadingAnimation = (_g) => {
  var _h = _g, {
    color,
    svgProps
  } = _h, props = __objRest(_h, [
    "color",
    "svgProps"
  ]);
  return /* @__PURE__ */ jsx(StyledLoadingAnimation, __spreadProps(__spreadValues({
    "aria-hidden": true
  }, props), {
    className: classNames("kiss-LoadingAnimation", props.className),
    children: /* @__PURE__ */ jsxs("svg", __spreadProps(__spreadValues({
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 21 16"
    }, svgProps), {
      className: classNames("kiss-LoadingAnimation__svg", svgProps.className),
      children: [/* @__PURE__ */ jsx("path", {
        className: "kiss-LoadingAnimation__path kiss-LoadingAnimation__path-heart",
        fill: color,
        d: "M18.81 8a2.59 2.59 0 002.18-2.6c0-1.45-1.25-2.7-2.7-2.7-.73 0-1.35.31-1.87.73L11.85 8l4.47 4.47c.52.52 1.24.83 1.97.83 1.45 0 2.7-1.25 2.7-2.7.1-1.15-.83-2.4-2.18-2.6z"
      }), /* @__PURE__ */ jsx("path", {
        className: "kiss-LoadingAnimation__path kiss-LoadingAnimation__path-circle",
        fill: color,
        d: "M13.82 2.5A7.91 7.91 0 008 0C3.53 0 0 3.53 0 8c0 4.47 3.53 8 8 8a8 8 0 005.71-2.39L8 8l5.82-5.5z"
      })]
    }))
  }));
};
LoadingAnimation.defaultProps = {
  color: COLORS.font1,
  svgProps: {}
};
LoadingAnimation.propTypes = {
  color: PropTypes.string,
  svgProps: PropTypes.object
};
var SubmitLoader = (props) => {
  const [{
    translations
  }] = useContext(EditorContext);
  return /* @__PURE__ */ jsxs(Button$1, __spreadProps(__spreadValues({
    modifier: "helium",
    size: "big",
    "aria-live": "polite",
    as: "div"
  }, props), {
    className: classNames("kiss-SubmitLoader", "k-u-cursor-not-allowed", props.className),
    children: [/* @__PURE__ */ jsx(LoadingAnimation, {
      color: COLORS.background1
    }), /* @__PURE__ */ jsx(VisuallyHidden, {
      children: translations.button_loading
    })]
  }));
};
var shams = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol = commonjsGlobal.Symbol;
var hasSymbolSham = shams;
var hasSymbols$1 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice3 = Array.prototype.slice;
var toStr$1 = Object.prototype.toString;
var funcType = "[object Function]";
var implementation$1 = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr$1.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slice3.call(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(this, args.concat(slice3.call(arguments)));
      if (Object(result) === result) {
        return result;
      }
      return this;
    } else {
      return target.apply(that, args.concat(slice3.call(arguments)));
    }
  };
  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs.push("$" + i);
  }
  bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
var implementation = implementation$1;
var functionBind = Function.prototype.bind || implementation;
var bind$1 = functionBind;
var src = bind$1.call(Function.call, Object.prototype.hasOwnProperty);
var undefined$1;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError$1 = TypeError;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e) {
  }
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
  try {
    $gOPD({}, "");
  } catch (e) {
    $gOPD = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError$1();
};
var ThrowTypeError = $gOPD ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols2 = hasSymbols$1();
var getProto = Object.getPrototypeOf || function(x) {
  return x.__proto__;
};
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols2 ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols2 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols2 ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$1,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
var doEval = function doEval2(name) {
  var value;
  if (name === "%AsyncFunction%") {
    value = getEvalledConstructor("async function () {}");
  } else if (name === "%GeneratorFunction%") {
    value = getEvalledConstructor("function* () {}");
  } else if (name === "%AsyncGeneratorFunction%") {
    value = getEvalledConstructor("async function* () {}");
  } else if (name === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value = fn.prototype;
    }
  } else if (name === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name] = value;
  return value;
};
var LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind2 = functionBind;
var hasOwn$1 = src;
var $concat = bind2.call(Function.call, Array.prototype.concat);
var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
var $replace = bind2.call(Function.call, String.prototype.replace);
var $strSlice = bind2.call(Function.call, String.prototype.slice);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first3 = $strSlice(string, 0, 1);
  var last4 = $strSlice(string, -1);
  if (first3 === "%" && last4 !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last4 === "%" && first3 !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace(string, rePropName, function(match3, number, quote2, subString) {
    result[result.length] = quote2 ? $replace(subString, reEscapeChar, "$1") : number || match3;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$1(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError$1("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError("intrinsic " + name + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== "string" || name.length === 0) {
    throw new $TypeError$1("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$1('"allowMissing" argument must be a boolean');
  }
  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first3 = $strSlice(part, 0, 1);
    var last4 = $strSlice(part, -1);
    if ((first3 === '"' || first3 === "'" || first3 === "`" || last4 === '"' || last4 === "'" || last4 === "`") && first3 !== last4) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError$1("base intrinsic for " + name + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn$1(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
var callBind$1 = { exports: {} };
(function(module) {
  var bind3 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind3.call($call, $apply);
  var $gOPD2 = GetIntrinsic3("%Object.getOwnPropertyDescriptor%", true);
  var $defineProperty = GetIntrinsic3("%Object.defineProperty%", true);
  var $max = GetIntrinsic3("%Math.max%");
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", {
        value: 1
      });
    } catch (e) {
      $defineProperty = null;
    }
  }
  module.exports = function callBind2(originalFunction) {
    var func2 = $reflectApply(bind3, $call, arguments);
    if ($gOPD2 && $defineProperty) {
      var desc = $gOPD2(func2, "length");
      if (desc.configurable) {
        $defineProperty(func2, "length", {
          value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
        });
      }
    }
    return func2;
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind3, $apply, arguments);
  };
  if ($defineProperty) {
    $defineProperty(module.exports, "apply", {
      value: applyBind
    });
  } else {
    module.exports.apply = applyBind;
  }
})(callBind$1);
var GetIntrinsic$1 = getIntrinsic;
var callBind = callBind$1.exports;
var $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf"));
var callBound$1 = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic$1(name, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
    return callBind(intrinsic);
  }
  return intrinsic;
};
var __viteBrowserExternal = {};
var __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": __viteBrowserExternal
});
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var match = String.prototype.match;
var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
  return O2.__proto__;
} : null);
var inspectCustom = require$$0.custom;
var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;
var toStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag !== "undefined" ? Symbol.toStringTag : null;
var objectInspect = function inspect_(obj, options, depth, seen) {
  var opts = options || {};
  if (has$3(opts, "quoteStyle") && opts.quoteStyle !== "single" && opts.quoteStyle !== "double") {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has$3(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has$3(opts, "customInspect") ? opts.customInspect : true;
  if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  }
  if (has$3(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('options "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  if (typeof obj === "boolean") {
    return obj ? "true" : "false";
  }
  if (typeof obj === "string") {
    return inspectString(obj, opts);
  }
  if (typeof obj === "number") {
    if (obj === 0) {
      return Infinity / obj > 0 ? "0" : "-0";
    }
    return String(obj);
  }
  if (typeof obj === "bigint") {
    return String(obj) + "n";
  }
  var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
  if (typeof depth === "undefined") {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
    return isArray$3(obj) ? "[Array]" : "[Object]";
  }
  var indent = getIndent(opts, depth);
  if (typeof seen === "undefined") {
    seen = [];
  } else if (indexOf2(seen, obj) >= 0) {
    return "[Circular]";
  }
  function inspect2(value, from, noIndent) {
    if (from) {
      seen = seen.slice();
      seen.push(from);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has$3(opts, "quoteStyle")) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen);
    }
    return inspect_(value, opts, depth + 1, seen);
  }
  if (typeof obj === "function") {
    var name = nameOf(obj);
    var keys3 = arrObjKeys(obj, inspect2);
    return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys3.length > 0 ? " { " + keys3.join(", ") + " }" : "");
  }
  if (isSymbol(obj)) {
    var symString = hasShammedSymbols ? String(obj).replace(/^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
    return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement(obj)) {
    var s = "<" + String(obj.nodeName).toLowerCase();
    var attrs = obj.attributes || [];
    for (var i = 0; i < attrs.length; i++) {
      s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
    }
    s += ">";
    if (obj.childNodes && obj.childNodes.length) {
      s += "...";
    }
    s += "</" + String(obj.nodeName).toLowerCase() + ">";
    return s;
  }
  if (isArray$3(obj)) {
    if (obj.length === 0) {
      return "[]";
    }
    var xs = arrObjKeys(obj, inspect2);
    if (indent && !singleLineValues(xs)) {
      return "[" + indentedJoin(xs, indent) + "]";
    }
    return "[ " + xs.join(", ") + " ]";
  }
  if (isError(obj)) {
    var parts = arrObjKeys(obj, inspect2);
    if (parts.length === 0) {
      return "[" + String(obj) + "]";
    }
    return "{ [" + String(obj) + "] " + parts.join(", ") + " }";
  }
  if (typeof obj === "object" && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === "function") {
      return obj[inspectSymbol]();
    } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
      return obj.inspect();
    }
  }
  if (isMap(obj)) {
    var mapParts = [];
    mapForEach.call(obj, function(value, key) {
      mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
    });
    return collectionOf("Map", mapSize.call(obj), mapParts, indent);
  }
  if (isSet(obj)) {
    var setParts = [];
    setForEach.call(obj, function(value) {
      setParts.push(inspect2(value, obj));
    });
    return collectionOf("Set", setSize.call(obj), setParts, indent);
  }
  if (isWeakMap(obj)) {
    return weakCollectionOf("WeakMap");
  }
  if (isWeakSet(obj)) {
    return weakCollectionOf("WeakSet");
  }
  if (isWeakRef(obj)) {
    return weakCollectionOf("WeakRef");
  }
  if (isNumber(obj)) {
    return markBoxed(inspect2(Number(obj)));
  }
  if (isBigInt(obj)) {
    return markBoxed(inspect2(bigIntValueOf.call(obj)));
  }
  if (isBoolean(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString$1(obj)) {
    return markBoxed(inspect2(String(obj)));
  }
  if (!isDate(obj) && !isRegExp$2(obj)) {
    var ys = arrObjKeys(obj, inspect2);
    var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? "" : "null prototype";
    var stringTag2 = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? toStr(obj).slice(8, -1) : protoTag ? "Object" : "";
    var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
    var tag = constructorTag + (stringTag2 || protoTag ? "[" + [].concat(stringTag2 || [], protoTag || []).join(": ") + "] " : "");
    if (ys.length === 0) {
      return tag + "{}";
    }
    if (indent) {
      return tag + "{" + indentedJoin(ys, indent) + "}";
    }
    return tag + "{ " + ys.join(", ") + " }";
  }
  return String(obj);
};
function wrapQuotes(s, defaultStyle, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
  return quoteChar + s + quoteChar;
}
function quote(s) {
  return String(s).replace(/"/g, "&quot;");
}
function isArray$3(obj) {
  return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isDate(obj) {
  return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isRegExp$2(obj) {
  return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isError(obj) {
  return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isString$1(obj) {
  return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isNumber(obj) {
  return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isBoolean(obj) {
  return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isSymbol(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === "object" && obj instanceof Symbol;
  }
  if (typeof obj === "symbol") {
    return true;
  }
  if (!obj || typeof obj !== "object" || !symToString) {
    return false;
  }
  try {
    symToString.call(obj);
    return true;
  } catch (e) {
  }
  return false;
}
function isBigInt(obj) {
  if (!obj || typeof obj !== "object" || !bigIntValueOf) {
    return false;
  }
  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e) {
  }
  return false;
}
var hasOwn = Object.prototype.hasOwnProperty || function(key) {
  return key in this;
};
function has$3(obj, key) {
  return hasOwn.call(obj, key);
}
function toStr(obj) {
  return objectToString.call(obj);
}
function nameOf(f2) {
  if (f2.name) {
    return f2.name;
  }
  var m2 = match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
  if (m2) {
    return m2[1];
  }
  return null;
}
function indexOf2(xs, x) {
  if (xs.indexOf) {
    return xs.indexOf(x);
  }
  for (var i = 0, l2 = xs.length; i < l2; i++) {
    if (xs[i] === x) {
      return i;
    }
  }
  return -1;
}
function isMap(x) {
  if (!mapSize || !x || typeof x !== "object") {
    return false;
  }
  try {
    mapSize.call(x);
    try {
      setSize.call(x);
    } catch (s) {
      return true;
    }
    return x instanceof Map;
  } catch (e) {
  }
  return false;
}
function isWeakMap(x) {
  if (!weakMapHas || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakMapHas.call(x, weakMapHas);
    try {
      weakSetHas.call(x, weakSetHas);
    } catch (s) {
      return true;
    }
    return x instanceof WeakMap;
  } catch (e) {
  }
  return false;
}
function isWeakRef(x) {
  if (!weakRefDeref || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakRefDeref.call(x);
    return true;
  } catch (e) {
  }
  return false;
}
function isSet(x) {
  if (!setSize || !x || typeof x !== "object") {
    return false;
  }
  try {
    setSize.call(x);
    try {
      mapSize.call(x);
    } catch (m2) {
      return true;
    }
    return x instanceof Set;
  } catch (e) {
  }
  return false;
}
function isWeakSet(x) {
  if (!weakSetHas || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakSetHas.call(x, weakSetHas);
    try {
      weakMapHas.call(x, weakMapHas);
    } catch (s) {
      return true;
    }
    return x instanceof WeakSet;
  } catch (e) {
  }
  return false;
}
function isElement(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
    return true;
  }
  return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
}
function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
    return inspectString(str.slice(0, opts.maxStringLength), opts) + trailer;
  }
  var s = str.replace(/(['\\])/g, "\\$1").replace(/[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s, "single", opts);
}
function lowbyte(c) {
  var n2 = c.charCodeAt(0);
  var x = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[n2];
  if (x) {
    return "\\" + x;
  }
  return "\\x" + (n2 < 16 ? "0" : "") + n2.toString(16).toUpperCase();
}
function markBoxed(str) {
  return "Object(" + str + ")";
}
function weakCollectionOf(type) {
  return type + " { ? }";
}
function collectionOf(type, size, entries2, indent) {
  var joinedEntries = indent ? indentedJoin(entries2, indent) : entries2.join(", ");
  return type + " (" + size + ") {" + joinedEntries + "}";
}
function singleLineValues(xs) {
  for (var i = 0; i < xs.length; i++) {
    if (indexOf2(xs[i], "\n") >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === "	") {
    baseIndent = "	";
  } else if (typeof opts.indent === "number" && opts.indent > 0) {
    baseIndent = Array(opts.indent + 1).join(" ");
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: Array(depth + 1).join(baseIndent)
  };
}
function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return "";
  }
  var lineJoiner = "\n" + indent.prev + indent.base;
  return lineJoiner + xs.join("," + lineJoiner) + "\n" + indent.prev;
}
function arrObjKeys(obj, inspect2) {
  var isArr = isArray$3(obj);
  var xs = [];
  if (isArr) {
    xs.length = obj.length;
    for (var i = 0; i < obj.length; i++) {
      xs[i] = has$3(obj, i) ? inspect2(obj[i], obj) : "";
    }
  }
  var syms = typeof gOPS === "function" ? gOPS(obj) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k = 0; k < syms.length; k++) {
      symMap["$" + syms[k]] = syms[k];
    }
  }
  for (var key in obj) {
    if (!has$3(obj, key)) {
      continue;
    }
    if (isArr && String(Number(key)) === key && key < obj.length) {
      continue;
    }
    if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
      continue;
    } else if (/[^\w$]/.test(key)) {
      xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
    } else {
      xs.push(key + ": " + inspect2(obj[key], obj));
    }
  }
  if (typeof gOPS === "function") {
    for (var j = 0; j < syms.length; j++) {
      if (isEnumerable.call(obj, syms[j])) {
        xs.push("[" + inspect2(syms[j]) + "]: " + inspect2(obj[syms[j]], obj));
      }
    }
  }
  return xs;
}
var GetIntrinsic2 = getIntrinsic;
var callBound = callBound$1;
var inspect = objectInspect;
var $TypeError = GetIntrinsic2("%TypeError%");
var $WeakMap = GetIntrinsic2("%WeakMap%", true);
var $Map = GetIntrinsic2("%Map%", true);
var $weakMapGet = callBound("WeakMap.prototype.get", true);
var $weakMapSet = callBound("WeakMap.prototype.set", true);
var $weakMapHas = callBound("WeakMap.prototype.has", true);
var $mapGet = callBound("Map.prototype.get", true);
var $mapSet = callBound("Map.prototype.set", true);
var $mapHas = callBound("Map.prototype.has", true);
var listGetNode = function(list, key) {
  for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
    if (curr.key === key) {
      prev.next = curr.next;
      curr.next = list.next;
      list.next = curr;
      return curr;
    }
  }
};
var listGet = function(objects, key) {
  var node = listGetNode(objects, key);
  return node && node.value;
};
var listSet = function(objects, key, value) {
  var node = listGetNode(objects, key);
  if (node) {
    node.value = value;
  } else {
    objects.next = {
      key,
      next: objects.next,
      value
    };
  }
};
var listHas = function(objects, key) {
  return !!listGetNode(objects, key);
};
var sideChannel = function getSideChannel() {
  var $wm;
  var $m;
  var $o;
  var channel = {
    assert: function(key) {
      if (!channel.has(key)) {
        throw new $TypeError("Side channel does not contain " + inspect(key));
      }
    },
    get: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapGet($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapGet($m, key);
        }
      } else {
        if ($o) {
          return listGet($o, key);
        }
      }
    },
    has: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapHas($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapHas($m, key);
        }
      } else {
        if ($o) {
          return listHas($o, key);
        }
      }
      return false;
    },
    set: function(key, value) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if (!$wm) {
          $wm = new $WeakMap();
        }
        $weakMapSet($wm, key, value);
      } else if ($Map) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key, value);
      } else {
        if (!$o) {
          $o = {
            key: {},
            next: null
          };
        }
        listSet($o, key, value);
      }
    }
  };
  return channel;
};
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
};
var formats$3 = {
  "default": Format.RFC3986,
  formatters: {
    RFC1738: function(value) {
      return replace.call(value, percentTwenties, "+");
    },
    RFC3986: function(value) {
      return String(value);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
};
var formats$2 = formats$3;
var has$2 = Object.prototype.hasOwnProperty;
var isArray$2 = Array.isArray;
var hexTable = function() {
  var array = [];
  for (var i = 0; i < 256; ++i) {
    array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array;
}();
var compactQueue = function compactQueue2(queue) {
  while (queue.length > 1) {
    var item = queue.pop();
    var obj = item.obj[item.prop];
    if (isArray$2(obj)) {
      var compacted = [];
      for (var j = 0; j < obj.length; ++j) {
        if (typeof obj[j] !== "undefined") {
          compacted.push(obj[j]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
};
var arrayToObject = function arrayToObject2(source, options) {
  var obj = options && options.plainObjects ? Object.create(null) : {};
  for (var i = 0; i < source.length; ++i) {
    if (typeof source[i] !== "undefined") {
      obj[i] = source[i];
    }
  }
  return obj;
};
var merge = function merge2(target, source, options) {
  if (!source) {
    return target;
  }
  if (typeof source !== "object") {
    if (isArray$2(target)) {
      target.push(source);
    } else if (target && typeof target === "object") {
      if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source)) {
        target[source] = true;
      }
    } else {
      return [target, source];
    }
    return target;
  }
  if (!target || typeof target !== "object") {
    return [target].concat(source);
  }
  var mergeTarget = target;
  if (isArray$2(target) && !isArray$2(source)) {
    mergeTarget = arrayToObject(target, options);
  }
  if (isArray$2(target) && isArray$2(source)) {
    source.forEach(function(item, i) {
      if (has$2.call(target, i)) {
        var targetItem = target[i];
        if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
          target[i] = merge2(targetItem, item, options);
        } else {
          target.push(item);
        }
      } else {
        target[i] = item;
      }
    });
    return target;
  }
  return Object.keys(source).reduce(function(acc, key) {
    var value = source[key];
    if (has$2.call(acc, key)) {
      acc[key] = merge2(acc[key], value, options);
    } else {
      acc[key] = value;
    }
    return acc;
  }, mergeTarget);
};
var assign$1 = function assignSingleSource(target, source) {
  return Object.keys(source).reduce(function(acc, key) {
    acc[key] = source[key];
    return acc;
  }, target);
};
var decode2 = function(str, decoder, charset) {
  var strWithoutPlus = str.replace(/\+/g, " ");
  if (charset === "iso-8859-1") {
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  }
  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e) {
    return strWithoutPlus;
  }
};
var encode2 = function encode3(str, defaultEncoder, charset, kind, format) {
  if (str.length === 0) {
    return str;
  }
  var string = str;
  if (typeof str === "symbol") {
    string = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string = String(str);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  var out = "";
  for (var i = 0; i < string.length; ++i) {
    var c = string.charCodeAt(i);
    if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats$2.RFC1738 && (c === 40 || c === 41)) {
      out += string.charAt(i);
      continue;
    }
    if (c < 128) {
      out = out + hexTable[c];
      continue;
    }
    if (c < 2048) {
      out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
      continue;
    }
    if (c < 55296 || c >= 57344) {
      out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
      continue;
    }
    i += 1;
    c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
    out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
  }
  return out;
};
var compact = function compact2(value) {
  var queue = [{
    obj: {
      o: value
    },
    prop: "o"
  }];
  var refs = [];
  for (var i = 0; i < queue.length; ++i) {
    var item = queue[i];
    var obj = item.obj[item.prop];
    var keys3 = Object.keys(obj);
    for (var j = 0; j < keys3.length; ++j) {
      var key = keys3[j];
      var val = obj[key];
      if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
        queue.push({
          obj,
          prop: key
        });
        refs.push(val);
      }
    }
  }
  compactQueue(queue);
  return value;
};
var isRegExp$1 = function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer = function isBuffer2(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine2(a, b) {
  return [].concat(a, b);
};
var maybeMap = function maybeMap2(val, fn) {
  if (isArray$2(val)) {
    var mapped = [];
    for (var i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
};
var utils$2 = {
  arrayToObject,
  assign: assign$1,
  combine,
  compact,
  decode: decode2,
  encode: encode2,
  isBuffer,
  isRegExp: isRegExp$1,
  maybeMap,
  merge
};
var getSideChannel2 = sideChannel;
var utils$1 = utils$2;
var formats$1 = formats$3;
var has$1 = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix) {
    return prefix + "[]";
  },
  comma: "comma",
  indices: function indices(prefix, key) {
    return prefix + "[" + key + "]";
  },
  repeat: function repeat(prefix) {
    return prefix;
  }
};
var isArray$1 = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
  push.apply(arr, isArray$1(valueOrArray) ? valueOrArray : [valueOrArray]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats$1["default"];
var defaults$1 = {
  addQueryPrefix: false,
  allowDots: false,
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encoder: utils$1.encode,
  encodeValuesOnly: false,
  format: defaultFormat,
  formatter: formats$1.formatters[defaultFormat],
  indices: false,
  serializeDate: function serializeDate(date) {
    return toISO.call(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
};
var stringify$1 = function stringify2(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter3, sort2, allowDots, serializeDate2, format, formatter, encodeValuesOnly, charset, sideChannel2) {
  var obj = object;
  if (sideChannel2.has(object)) {
    throw new RangeError("Cyclic object value");
  }
  if (typeof filter3 === "function") {
    obj = filter3(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate2(obj);
  } else if (generateArrayPrefix === "comma" && isArray$1(obj)) {
    obj = utils$1.maybeMap(obj, function(value2) {
      if (value2 instanceof Date) {
        return serializeDate2(value2);
      }
      return value2;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix, defaults$1.encoder, charset, "key", format) : prefix;
    }
    obj = "";
  }
  if (isNonNullishPrimitive(obj) || utils$1.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset, "key", format);
      return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$1.encoder, charset, "value", format))];
    }
    return [formatter(prefix) + "=" + formatter(String(obj))];
  }
  var values2 = [];
  if (typeof obj === "undefined") {
    return values2;
  }
  var objKeys;
  if (generateArrayPrefix === "comma" && isArray$1(obj)) {
    objKeys = [{
      value: obj.length > 0 ? obj.join(",") || null : void 0
    }];
  } else if (isArray$1(filter3)) {
    objKeys = filter3;
  } else {
    var keys3 = Object.keys(obj);
    objKeys = sort2 ? keys3.sort(sort2) : keys3;
  }
  for (var i = 0; i < objKeys.length; ++i) {
    var key = objKeys[i];
    var value = typeof key === "object" && key.value !== void 0 ? key.value : obj[key];
    if (skipNulls && value === null) {
      continue;
    }
    var keyPrefix = isArray$1(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(prefix, key) : prefix : prefix + (allowDots ? "." + key : "[" + key + "]");
    sideChannel2.set(object, true);
    var valueSideChannel = getSideChannel2();
    pushToArray(values2, stringify2(value, keyPrefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter3, sort2, allowDots, serializeDate2, format, formatter, encodeValuesOnly, charset, valueSideChannel));
  }
  return values2;
};
var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
  if (!opts) {
    return defaults$1;
  }
  if (opts.encoder !== null && opts.encoder !== void 0 && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  var charset = opts.charset || defaults$1.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var format = formats$1["default"];
  if (typeof opts.format !== "undefined") {
    if (!has$1.call(formats$1.formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format = opts.format;
  }
  var formatter = formats$1.formatters[format];
  var filter3 = defaults$1.filter;
  if (typeof opts.filter === "function" || isArray$1(opts.filter)) {
    filter3 = opts.filter;
  }
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
    allowDots: typeof opts.allowDots === "undefined" ? defaults$1.allowDots : !!opts.allowDots,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
    delimiter: typeof opts.delimiter === "undefined" ? defaults$1.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults$1.encode,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$1.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
    filter: filter3,
    format,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$1.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$1.skipNulls,
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
  };
};
var stringify_1 = function(object, opts) {
  var obj = object;
  var options = normalizeStringifyOptions(opts);
  var objKeys;
  var filter3;
  if (typeof options.filter === "function") {
    filter3 = options.filter;
    obj = filter3("", obj);
  } else if (isArray$1(options.filter)) {
    filter3 = options.filter;
    objKeys = filter3;
  }
  var keys3 = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  var arrayFormat;
  if (opts && opts.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts.arrayFormat;
  } else if (opts && "indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = "indices";
  }
  var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
  if (!objKeys) {
    objKeys = Object.keys(obj);
  }
  if (options.sort) {
    objKeys.sort(options.sort);
  }
  var sideChannel2 = getSideChannel2();
  for (var i = 0; i < objKeys.length; ++i) {
    var key = objKeys[i];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    pushToArray(keys3, stringify$1(obj[key], key, generateArrayPrefix, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel2));
  }
  var joined = keys3.join(options.delimiter);
  var prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
};
var utils = utils$2;
var has3 = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;
var defaults = {
  allowDots: false,
  allowPrototypes: false,
  allowSparse: false,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: false,
  comma: false,
  decoder: utils.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1e3,
  parseArrays: true,
  plainObjects: false,
  strictNullHandling: false
};
var interpretNumericEntities = function(str) {
  return str.replace(/&#(\d+);/g, function($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};
var parseArrayValue = function(val, options) {
  if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
    return val.split(",");
  }
  return val;
};
var isoSentinel = "utf8=%26%2310003%3B";
var charsetSentinel = "utf8=%E2%9C%93";
var parseValues = function parseQueryStringValues(str, options) {
  var obj = {};
  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
  var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
  var parts = cleanStr.split(options.delimiter, limit);
  var skipIndex = -1;
  var i;
  var charset = options.charset;
  if (options.charsetSentinel) {
    for (i = 0; i < parts.length; ++i) {
      if (parts[i].indexOf("utf8=") === 0) {
        if (parts[i] === charsetSentinel) {
          charset = "utf-8";
        } else if (parts[i] === isoSentinel) {
          charset = "iso-8859-1";
        }
        skipIndex = i;
        i = parts.length;
      }
    }
  }
  for (i = 0; i < parts.length; ++i) {
    if (i === skipIndex) {
      continue;
    }
    var part = parts[i];
    var bracketEqualsPos = part.indexOf("]=");
    var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
    var key, val;
    if (pos === -1) {
      key = options.decoder(part, defaults.decoder, charset, "key");
      val = options.strictNullHandling ? null : "";
    } else {
      key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
      val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
        return options.decoder(encodedVal, defaults.decoder, charset, "value");
      });
    }
    if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
      val = interpretNumericEntities(val);
    }
    if (part.indexOf("[]=") > -1) {
      val = isArray(val) ? [val] : val;
    }
    if (has3.call(obj, key)) {
      obj[key] = utils.combine(obj[key], val);
    } else {
      obj[key] = val;
    }
  }
  return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
  var leaf = valuesParsed ? val : parseArrayValue(val, options);
  for (var i = chain.length - 1; i >= 0; --i) {
    var obj;
    var root2 = chain[i];
    if (root2 === "[]" && options.parseArrays) {
      obj = [].concat(leaf);
    } else {
      obj = options.plainObjects ? Object.create(null) : {};
      var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
      var index = parseInt(cleanRoot, 10);
      if (!options.parseArrays && cleanRoot === "") {
        obj = {
          0: leaf
        };
      } else if (!isNaN(index) && root2 !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
        obj = [];
        obj[index] = leaf;
      } else {
        obj[cleanRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
  if (!givenKey) {
    return;
  }
  var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
  var brackets2 = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g;
  var segment = options.depth > 0 && brackets2.exec(key);
  var parent2 = segment ? key.slice(0, segment.index) : key;
  var keys3 = [];
  if (parent2) {
    if (!options.plainObjects && has3.call(Object.prototype, parent2)) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys3.push(parent2);
  }
  var i = 0;
  while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
    i += 1;
    if (!options.plainObjects && has3.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys3.push(segment[1]);
  }
  if (segment) {
    keys3.push("[" + key.slice(segment.index) + "]");
  }
  return parseObject(keys3, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions2(opts) {
  if (!opts) {
    return defaults;
  }
  if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
    throw new TypeError("Decoder has to be a function.");
  }
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
  return {
    allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
    allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
    allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
    arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
    decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
    delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
    depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
    ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
    parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
    parseArrays: opts.parseArrays !== false,
    plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
};
var parse$1 = function(str, opts) {
  var options = normalizeParseOptions(opts);
  if (str === "" || str === null || typeof str === "undefined") {
    return options.plainObjects ? Object.create(null) : {};
  }
  var tempObj = typeof str === "string" ? parseValues(str, options) : str;
  var obj = options.plainObjects ? Object.create(null) : {};
  var keys3 = Object.keys(tempObj);
  for (var i = 0; i < keys3.length; ++i) {
    var key = keys3[i];
    var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
    obj = utils.merge(obj, newObj, options);
  }
  if (options.allowSparse === true) {
    return obj;
  }
  return utils.compact(obj);
};
var stringify3 = stringify_1;
var parse = parse$1;
var formats = formats$3;
var lib = {
  formats,
  parse,
  stringify: stringify3
};
const EMBEDLY_API_URL = "https://api.embed.ly/1/";
const oembed = (customConfig) => {
  if (!customConfig.key) {
    throw new Error("You need an API key to call Embedly");
  }
  return fetch(`${EMBEDLY_API_URL}oembed?${lib.stringify(__spreadValues({
    secure: document.location.protocol === "https:",
    scheme: document.location.protocol.replace(":", "")
  }, customConfig))}`).then((response) => response.json());
};
const VideoEditor = ({
  contentState,
  entityKey,
  blockKey
}) => {
  const {
    embedlyHtml,
    embedRatio,
    html
  } = contentState.getEntity(entityKey).getData();
  const [{
    editorState
  }, dispatch] = useContext(EditorContext);
  const onClick = (e) => {
    e.preventDefault();
    e.stopPropagation();
    dispatch(updateEditor(moveSelectionTo(editorState, blockKey)));
  };
  const hasFocus = hasEntityFocus(contentState, editorState, entityKey);
  if (html) {
    return /* @__PURE__ */ jsx(ResponsiveIframeContainer, {
      className: "kiss-Draft__media",
      children: /* @__PURE__ */ jsx("div", {
        className: classNames("kiss-Draft__media-focus", {
          "kiss-Draft__media-focus__focused": hasFocus
        }),
        onClick,
        children: parseHtml(html, {
          sanitize: false
        })
      })
    });
  }
  return /* @__PURE__ */ jsx(ResponsiveIframeContainer, {
    ratio: embedRatio,
    className: "kiss-Draft__media",
    children: /* @__PURE__ */ jsx("div", {
      className: classNames("kiss-Draft__media-focus", {
        "kiss-Draft__media-focus__focused": hasFocus
      }),
      onClick,
      children: parseHtml(embedlyHtml, {
        sanitize: false
      })
    })
  });
};
const VideoDisplayer = (props) => {
  const {
    embedlyHtml,
    embedRatio,
    html
  } = props.contentState.getEntity(props.entityKey).getData();
  if (html) {
    return /* @__PURE__ */ jsx(ResponsiveIframeContainer, {
      className: "kiss-Draft__media-read",
      children: parseHtml(html, {
        sanitize: false
      })
    });
  }
  return /* @__PURE__ */ jsx(ResponsiveIframeContainer, {
    ratio: embedRatio,
    className: "kiss-Draft__media-read",
    children: parseHtml(embedlyHtml, {
      sanitize: false
    })
  });
};
const videoStrategy = (contentBlock, callback, contentState) => {
  contentBlock.findEntityRanges((character) => {
    const entityKey = character.getEntity();
    return entityKey !== null && ["VIDEO", "MEDIA"].includes(contentState.getEntity(entityKey).getType());
  }, callback);
};
const decorator$3 = {
  strategy: videoStrategy,
  component: VideoEditor
};
const readDecorator$3 = {
  strategy: videoStrategy,
  component: VideoDisplayer
};
const calculRatio = (response) => (response.height / response.width * 100).toPrecision(4);
const VideoControls = ({
  disabled,
  onChange,
  embedlyApiKey
}) => {
  const [{
    editorState,
    translations,
    disabled: contextDisabled
  }, dispatch] = useContext(EditorContext);
  const [modalOpened, openModal] = useState(false);
  const [embedlyHtml, setEmbedlyHtml] = useState(void 0);
  const [embedRatio, setEmbedRatio] = useState(void 0);
  const [hasOembedError, oembedError] = useState(false);
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsx(Button, {
      icon: "video",
      disabled: contextDisabled || disabled,
      onToggle: () => {
        if (modalOpened) {
          openModal(false);
        } else {
          openModal(true);
        }
      }
    }), /* @__PURE__ */ jsx(ModalNext, {
      onClose: () => openModal(false),
      isOpen: modalOpened,
      variant: "orion",
      headerTitle: /* @__PURE__ */ jsx(Title$1, {
        modifier: "quaternary",
        children: translations.media_upload.title
      }),
      children: ({
        close
      }) => {
        return /* @__PURE__ */ jsxs(ModalNext.Block, {
          children: [/* @__PURE__ */ jsx(Label, {
            size: "micro",
            className: "k-u-margin-bottom-single",
            children: translations.image_upload.label
          }), /* @__PURE__ */ jsx(Formik, {
            initialValues: {
              url: ""
            },
            validationSchema: Yup.object().shape({
              url: Yup.string().url(translations.video.invalid_url)
            }),
            onSubmit: ({
              url
            }) => {
              onChange(url);
              oembedError(false);
              return oembed({
                key: embedlyApiKey,
                maxwidth: 640,
                url
              }).then((response) => {
                if (response.type === "error") {
                  oembedError(true);
                  return;
                }
                if (response.provider_name === "Flipsnack") {
                  dispatch(updateEditor(createMediaBlock(editorState, {
                    html: `<iframe src="${response.url}" width="100%" height="480" seamless="seamless" scrolling="no" frameBorder="0" allowFullScreen></iframe>`
                  })));
                } else {
                  dispatch(updateEditor(createMediaBlock(editorState, {
                    embedlyHtml: response.html,
                    embedRatio: calculRatio(response)
                  })));
                }
                close();
                setTimeout(() => openModal(false), 500);
              });
            },
            children: ({
              handleSubmit,
              isSubmitting,
              values: values2
            }) => {
              return /* @__PURE__ */ jsxs(Fragment, {
                children: [/* @__PURE__ */ jsx(FormikInputWithButton, {
                  name: "url",
                  variant: "orion",
                  placeholder: "https://",
                  value: translations.image_upload.preview,
                  onClick: () => {
                    oembedError(false);
                    oembed({
                      key: embedlyApiKey,
                      maxwidth: 640,
                      url: values2.url
                    }).then((response) => {
                      if (response.type === "error") {
                        oembedError(true);
                        return;
                      }
                      if (response.provider_name === "Flipsnack") {
                        setEmbedRatio(67.5);
                        setEmbedlyHtml(`<iframe src="${response.url}" width="100%" height="480" seamless="seamless" scrolling="no" frameBorder="0" allowFullScreen></iframe>`);
                      } else {
                        setEmbedRatio(calculRatio(response));
                        setEmbedlyHtml(response.html);
                      }
                    });
                  }
                }), embedlyHtml && /* @__PURE__ */ jsx("div", {
                  className: "k-u-margin-vertical-single",
                  children: /* @__PURE__ */ jsx(ResponsiveIframeContainer, {
                    ratio: embedRatio,
                    children: parseHtml(embedlyHtml, {
                      sanitize: false
                    })
                  })
                }), hasOembedError && /* @__PURE__ */ jsx(Field.ErrorMessage, {
                  children: translations.video.problem
                }), /* @__PURE__ */ jsx(ModalNext.Actions, {
                  children: isSubmitting ? /* @__PURE__ */ jsx(SubmitLoader, {
                    fluid: true
                  }) : /* @__PURE__ */ jsx(ModalNext.Button, {
                    size: "big",
                    variant: "orion",
                    type: "button",
                    modifier: "helium",
                    onClick: handleSubmit,
                    children: translations.submit
                  })
                })]
              });
            }
          })]
        });
      }
    })]
  });
};
VideoControls.propTypes = {
  embedlyApiKey: PropTypes.string.isRequired,
  disabled: PropTypes.bool,
  onChange: PropTypes.func
};
VideoControls.defaultProps = {
  disabled: false,
  onChange: () => null
};
const StyledArrowContainer$1 = styled(ArrowContainer)`
  display: flex;
  position: absolute;
  min-width: max-content;
  padding: 0 ${pxToRem(20)};
  background-color: ${COLORS.background1};
  margin-top: ${pxToRem(0)};
  transition: opacity 0.1s ease-out, margin-top 0.1s ease-out;
  z-index: 99999;
`;
const DeleteLink$1 = styled(Text)`
  flex: 1;
  width: 100%;
  text-align: center;
  display: block;
  padding: 0;
`;
const VerticalSeparator$1 = styled.span`
  flex: 0;
  border-left: ${pxToRem(2)} solid ${COLORS.font2};
  margin: ${pxToRem(5)} ${pxToRem(10)};
`;
const ShareLink$1 = styled(Text)`
  flex: 2;
  max-width: ${pxToRem(240)};
  text-overflow: ellipsis;
  display: inline-block;
  overflow: hidden;
  white-space: nowrap;
`;
const LinkInline = ({
  onDelete: onDelete2,
  url
}) => {
  const [{
    translations
  }] = useContext(EditorContext);
  return /* @__PURE__ */ jsxs(StyledArrowContainer$1, {
    position: "top",
    shadow: true,
    borderWidth: 1,
    borderColor: COLORS.line1,
    contentEditable: false,
    children: [/* @__PURE__ */ jsx(DeleteLink$1, {
      href: "#",
      tag: "a",
      size: "micro",
      color: "error",
      onClick: (e) => {
        e.preventDefault();
        e.stopPropagation();
        onDelete2(e);
      },
      children: translations.link.button.delete
    }), /* @__PURE__ */ jsx(VerticalSeparator$1, {}), /* @__PURE__ */ jsx(ShareLink$1, {
      href: url,
      target: "_blank",
      rel: "noopener",
      tag: "a",
      size: "micro",
      color: "font1",
      onClick: (e) => {
        e.preventDefault();
        e.stopPropagation();
        window.open(url, "_blank").focus();
      },
      children: url
    })]
  });
};
const StyledImage = styled.div`
  width: 100%;
  img {
    display: inline-block;
    height: auto;
    max-width: 100%;
  }
`;
const LinkManager = ({
  url,
  entityKey
}) => {
  const [{
    editorState
  }, dispatch] = useContext(EditorContext);
  return /* @__PURE__ */ jsx(LinkInline, {
    url,
    onDelete: () => {
      dispatch(updateEditor(removeDataFromEntity(editorState, entityKey, ["url"])));
    }
  });
};
const ImageEditor = ({
  contentState,
  entityKey,
  blockKey
}) => {
  const [{
    editorState
  }, dispatch] = useContext(EditorContext);
  const hasFocus = hasEntityFocus(contentState, editorState, entityKey);
  const {
    src: src2,
    url
  } = contentState.getEntity(entityKey).getData();
  const onClick = () => {
    dispatch(updateEditor(moveSelectionTo(editorState, blockKey)));
  };
  return /* @__PURE__ */ jsx(StyledImage, {
    className: "kiss-Draft__image",
    onClick,
    children: /* @__PURE__ */ jsxs("div", {
      className: classNames("kiss-Draft__image-focus", {
        "kiss-Draft__image-focus__focused": hasFocus
      }),
      children: [/* @__PURE__ */ jsx("div", {
        className: "k-u-align-center",
        children: /* @__PURE__ */ jsx("img", {
          src: getImageUrl(src2),
          alt: ""
        })
      }), hasFocus && !!url && /* @__PURE__ */ jsx(LinkManager, {
        url,
        entityKey
      })]
    })
  });
};
const ImageDisplayer = ({
  contentState,
  entityKey
}) => {
  const {
    src: src2,
    url
  } = contentState.getEntity(entityKey).getData();
  return /* @__PURE__ */ jsx(StyledImage, {
    className: "kiss-Draft__image-read",
    children: url ? /* @__PURE__ */ jsx("a", {
      href: url,
      target: "_blank",
      rel: "nofollow noopener",
      children: /* @__PURE__ */ jsx("div", {
        className: "k-u-align-center",
        children: /* @__PURE__ */ jsx("img", {
          src: getImageUrl(src2),
          alt: ""
        })
      })
    }) : /* @__PURE__ */ jsx("div", {
      className: "k-u-align-center",
      children: /* @__PURE__ */ jsx("img", {
        src: getImageUrl(src2),
        alt: ""
      })
    })
  });
};
const HiddenInput = styled.input`
  display: none;
`;
const imageStrategy = (contentBlock, callback, contentState) => {
  contentBlock.findEntityRanges((character) => {
    const entityKey = character.getEntity();
    return entityKey !== null && contentState.getEntity(entityKey).getType() === "IMAGE";
  }, callback);
};
const decorator$2 = {
  strategy: imageStrategy,
  component: ImageEditor
};
const readDecorator$2 = {
  strategy: imageStrategy,
  component: ImageDisplayer
};
const Form = ({
  imageUrl,
  setImageUrl
}) => {
  const [{
    translations
  }] = useContext(EditorContext);
  const {
    handleSubmit,
    values: values2,
    isSubmitting
  } = useFormikContext();
  const [, , fileSizeHelpers] = useField("fileSize");
  const [, , urlHelpers] = useField("url");
  const [, , fileHelpers] = useField("file");
  const fileInputRef = useRef(null);
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsx(HiddenInput, {
      ref: fileInputRef,
      name: "file",
      type: "file",
      id: "imageFile",
      onChange: (event) => {
        const file = event.target.files[0];
        if (!file.type.match("image.*")) {
          return;
        }
        fileHelpers.setValue(file);
        fileSizeHelpers.setValue(file.size);
        urlHelpers.setValue("");
        const reader = new FileReader();
        reader.addEventListener("load", (file2) => {
          setImageUrl(file2.target.result);
        });
        reader.readAsDataURL(file);
      },
      accept: "image/gif, image/jpeg, image/jpg, image/png"
    }), /* @__PURE__ */ jsx("div", {
      className: "k-u-margin-top-single",
      children: /* @__PURE__ */ jsx(Label, {
        htmlFor: "url",
        children: translations.image_upload.label
      })
    }), /* @__PURE__ */ jsx(FormikInputWithButton, {
      name: "url",
      placeholder: "https://",
      value: translations.image_upload.preview,
      onClick: () => {
        setImageUrl(values2.url);
        fileSizeHelpers.setValue(0);
      }
    }), /* @__PURE__ */ jsx("div", {
      className: "k-u-margin-vertical-single",
      children: imageUrl && /* @__PURE__ */ jsx("img", {
        src: imageUrl,
        width: "100%",
        alt: ""
      })
    }), /* @__PURE__ */ jsx(ErrorMessage, {
      name: "url",
      children: (msg) => /* @__PURE__ */ jsx(Field.ErrorMessage, {
        children: msg
      })
    }), /* @__PURE__ */ jsx(ErrorMessage, {
      name: "fileSize",
      children: (msg) => /* @__PURE__ */ jsx(Field.ErrorMessage, {
        children: msg
      })
    }), /* @__PURE__ */ jsxs("div", {
      className: "k-u-margin-top-single",
      children: [/* @__PURE__ */ jsx("div", {
        className: "k-u-margin-bottom-single",
        children: /* @__PURE__ */ jsx("a", {
          href: "#",
          className: "k-u-link k-u-link-primary1",
          onClick: (e) => {
            e.preventDefault();
            fileInputRef.current.click();
          },
          children: /* @__PURE__ */ jsx(Text, {
            tag: "span",
            decoration: "underline",
            children: translations.image_upload.upload
          })
        })
      }), /* @__PURE__ */ jsxs(ModalNext.Paragraph, {
        align: "left",
        noMargin: true,
        children: [translations.image_upload.help_file.formats, /* @__PURE__ */ jsx("br", {}), translations.image_upload.help_file.width, /* @__PURE__ */ jsx("br", {}), translations.image_upload.help_file.size]
      }), /* @__PURE__ */ jsx(ModalNext.Actions, {
        children: isSubmitting ? /* @__PURE__ */ jsx(SubmitLoader, {
          fluid: true,
          variant: "orion"
        }) : /* @__PURE__ */ jsx(ModalNext.Button, {
          type: "button",
          size: "big",
          variant: "orion",
          modifier: "helium",
          onClick: handleSubmit,
          children: translations.submit
        })
      })]
    })]
  });
};
const ImageControls = ({
  disabled,
  onUpload
}) => {
  const [modalOpened, openModal] = useState(false);
  const [{
    editorState,
    translations,
    disabled: contextDisabled
  }, dispatch] = useContext(EditorContext);
  const [imageUrl, setImageUrl] = useState("");
  useEffect(() => {
    if (!modalOpened) {
      setImageUrl("");
    }
  }, [modalOpened]);
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsx(Button, {
      icon: "image",
      disabled: contextDisabled || disabled,
      onToggle: () => {
        if (modalOpened) {
          openModal(false);
        } else {
          openModal(true);
        }
      }
    }), /* @__PURE__ */ jsx(ModalNext, {
      onClose: () => openModal(false),
      isOpen: modalOpened,
      variant: "orion",
      headerTitle: /* @__PURE__ */ jsx(Title$1, {
        modifier: "quaternary",
        children: translations.image_upload.title
      }),
      children: ({
        close
      }) => {
        return /* @__PURE__ */ jsx(ModalNext.Block, {
          children: /* @__PURE__ */ jsx(Formik, {
            initialValues: {
              url: "",
              fileSize: 0
            },
            validationSchema: Yup.object().shape({
              url: Yup.string().url(translations.image.invalid_url).matches(/(?:jpg|jpeg|gif|png)$/, translations.image.invalid_extension),
              fileSize: Yup.number().max(5e6, translations.image.max_size)
            }),
            onSubmit: ({
              url,
              fileSize,
              file
            }) => {
              return new Promise((resolve, reject) => {
                if (isEmpty(url) && fileSize === 0) {
                  reject("WRONG");
                }
                if (!isEmpty(url) && fileSize === 0) {
                  resolve(url);
                }
                onUpload(file).then((url2) => resolve(url2));
              }).then((url2) => {
                const contentState = editorState.getCurrentContent();
                const contentStateWithEntity = contentState.createEntity("IMAGE", "IMMUTABLE", {
                  src: url2
                });
                const entityKey = contentStateWithEntity.getLastCreatedEntityKey();
                const newEditorState = Draft.AtomicBlockUtils.insertAtomicBlock(editorState, entityKey, " ");
                const newState = Draft.EditorState.forceSelection(newEditorState, newEditorState.getCurrentContent().getSelectionAfter());
                dispatch(updateEditor(newState));
                close();
                openModal(false);
                setTimeout(() => openModal(false), 500);
              });
            },
            children: () => /* @__PURE__ */ jsx(Form, {
              imageUrl,
              setImageUrl
            })
          })
        });
      }
    })]
  });
};
ImageControls.propTypes = {
  disabled: PropTypes.bool,
  onUpload: PropTypes.func
};
ImageControls.defaultProps = {
  disabled: false,
  onUpload: () => null
};
var regex$3 = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var regex$2 = /[\0-\x1F\x7F-\x9F]/;
var regex$1 = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
var regex = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
var re = function(opts) {
  var re2 = {};
  re2.src_Any = regex$3.source;
  re2.src_Cc = regex$2.source;
  re2.src_Z = regex$1.source;
  re2.src_P = regex.source;
  re2.src_ZPCc = [re2.src_Z, re2.src_P, re2.src_Cc].join("|");
  re2.src_ZCc = [re2.src_Z, re2.src_Cc].join("|");
  var text_separators = "[><\uFF5C]";
  re2.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re2.src_ZPCc + ")" + re2.src_Any + ")";
  re2.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
  re2.src_auth = "(?:(?:(?!" + re2.src_ZCc + "|[@/\\[\\]()]).)+@)?";
  re2.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
  re2.src_host_terminator = "(?=$|" + text_separators + "|" + re2.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + re2.src_ZPCc + "))";
  re2.src_path = "(?:[/?#](?:(?!" + re2.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re2.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re2.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re2.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re2.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re2.src_ZCc + "|[']).)+\\'|\\'(?=" + re2.src_pseudo_letter + "|[-]).|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re2.src_ZCc + "|[.]).|" + (opts && opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re2.src_ZCc + ").|;(?!" + re2.src_ZCc + ").|\\!+(?!" + re2.src_ZCc + "|[!]).|\\?(?!" + re2.src_ZCc + "|[?]).)+|\\/)?";
  re2.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
  re2.src_xn = "xn--[a-z0-9\\-]{1,59}";
  re2.src_domain_root = "(?:" + re2.src_xn + "|" + re2.src_pseudo_letter + "{1,63})";
  re2.src_domain = "(?:" + re2.src_xn + "|(?:" + re2.src_pseudo_letter + ")|(?:" + re2.src_pseudo_letter + "(?:-|" + re2.src_pseudo_letter + "){0,61}" + re2.src_pseudo_letter + "))";
  re2.src_host = "(?:(?:(?:(?:" + re2.src_domain + ")\\.)*" + re2.src_domain + "))";
  re2.tpl_host_fuzzy = "(?:" + re2.src_ip4 + "|(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%)))";
  re2.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%))";
  re2.src_host_strict = re2.src_host + re2.src_host_terminator;
  re2.tpl_host_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_host_terminator;
  re2.src_host_port_strict = re2.src_host + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_port_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_port_no_ip_fuzzy_strict = re2.tpl_host_no_ip_fuzzy + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re2.src_ZPCc + "|>|$))";
  re2.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re2.src_ZCc + ")(" + re2.src_email_name + "@" + re2.tpl_host_fuzzy_strict + ")";
  re2.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re2.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re2.tpl_host_port_fuzzy_strict + re2.src_path + ")";
  re2.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re2.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re2.tpl_host_port_no_ip_fuzzy_strict + re2.src_path + ")";
  return re2;
};
function assign(obj) {
  var sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === "[object String]";
}
function isObject(obj) {
  return _class(obj) === "[object Object]";
}
function isRegExp2(obj) {
  return _class(obj) === "[object RegExp]";
}
function isFunction(obj) {
  return _class(obj) === "[object Function]";
}
function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function(acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}
var defaultSchemas = {
  "http:": {
    validate: function(text, pos, self2) {
      var tail = text.slice(pos);
      if (!self2.re.http) {
        self2.re.http = new RegExp("^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path, "i");
      }
      if (self2.re.http.test(tail)) {
        return tail.match(self2.re.http)[0].length;
      }
      return 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(text, pos, self2) {
      var tail = text.slice(pos);
      if (!self2.re.no_http) {
        self2.re.no_http = new RegExp("^" + self2.re.src_auth + "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path, "i");
      }
      if (self2.re.no_http.test(tail)) {
        if (pos >= 3 && text[pos - 3] === ":") {
          return 0;
        }
        if (pos >= 3 && text[pos - 3] === "/") {
          return 0;
        }
        return tail.match(self2.re.no_http)[0].length;
      }
      return 0;
    }
  },
  "mailto:": {
    validate: function(text, pos, self2) {
      var tail = text.slice(pos);
      if (!self2.re.mailto) {
        self2.re.mailto = new RegExp("^" + self2.re.src_email_name + "@" + self2.re.src_host_strict, "i");
      }
      if (self2.re.mailto.test(tail)) {
        return tail.match(self2.re.mailto)[0].length;
      }
      return 0;
    }
  }
};
var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
function resetScanCache(self2) {
  self2.__index__ = -1;
  self2.__text_cache__ = "";
}
function createValidator(re2) {
  return function(text, pos) {
    var tail = text.slice(pos);
    if (re2.test(tail)) {
      return tail.match(re2)[0].length;
    }
    return 0;
  };
}
function createNormalizer() {
  return function(match3, self2) {
    self2.normalize(match3);
  };
}
function compile(self2) {
  var re$1 = self2.re = re(self2.__opts__);
  var tlds3 = self2.__tlds__.slice();
  self2.onCompile();
  if (!self2.__tlds_replaced__) {
    tlds3.push(tlds_2ch_src_re);
  }
  tlds3.push(re$1.src_xn);
  re$1.src_tlds = tlds3.join("|");
  function untpl(tpl) {
    return tpl.replace("%TLDS%", re$1.src_tlds);
  }
  re$1.email_fuzzy = RegExp(untpl(re$1.tpl_email_fuzzy), "i");
  re$1.link_fuzzy = RegExp(untpl(re$1.tpl_link_fuzzy), "i");
  re$1.link_no_ip_fuzzy = RegExp(untpl(re$1.tpl_link_no_ip_fuzzy), "i");
  re$1.host_fuzzy_test = RegExp(untpl(re$1.tpl_host_fuzzy_test), "i");
  var aliases = [];
  self2.__compiled__ = {};
  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }
  Object.keys(self2.__schemas__).forEach(function(name) {
    var val = self2.__schemas__[name];
    if (val === null) {
      return;
    }
    var compiled = {
      validate: null,
      link: null
    };
    self2.__compiled__[name] = compiled;
    if (isObject(val)) {
      if (isRegExp2(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }
      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }
      return;
    }
    if (isString(val)) {
      aliases.push(name);
      return;
    }
    schemaError(name, val);
  });
  aliases.forEach(function(alias) {
    if (!self2.__compiled__[self2.__schemas__[alias]]) {
      return;
    }
    self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
    self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
  });
  self2.__compiled__[""] = {
    validate: null,
    normalize: createNormalizer()
  };
  var slist = Object.keys(self2.__compiled__).filter(function(name) {
    return name.length > 0 && self2.__compiled__[name];
  }).map(escapeRE).join("|");
  self2.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re$1.src_ZPCc + "))(" + slist + ")", "i");
  self2.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re$1.src_ZPCc + "))(" + slist + ")", "ig");
  self2.re.pretest = RegExp("(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@", "i");
  resetScanCache(self2);
}
function Match(self2, shift) {
  var start = self2.__index__, end = self2.__last_index__, text = self2.__text_cache__.slice(start, end);
  this.schema = self2.__schema__.toLowerCase();
  this.index = start + shift;
  this.lastIndex = end + shift;
  this.raw = text;
  this.text = text;
  this.url = text;
}
function createMatch(self2, shift) {
  var match3 = new Match(self2, shift);
  self2.__compiled__[match3.schema].normalize(match3, self2);
  return match3;
}
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }
  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }
  this.__opts__ = assign({}, defaultOptions, options);
  this.__index__ = -1;
  this.__last_index__ = -1;
  this.__schema__ = "";
  this.__text_cache__ = "";
  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};
  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;
  this.re = {};
  compile(this);
}
LinkifyIt.prototype.add = function add3(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};
LinkifyIt.prototype.set = function set2(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};
LinkifyIt.prototype.test = function test(text) {
  this.__text_cache__ = text;
  this.__index__ = -1;
  if (!text.length) {
    return false;
  }
  var m2, ml, me, len, shift, next, re2, tld_pos, at_pos;
  if (this.re.schema_test.test(text)) {
    re2 = this.re.schema_search;
    re2.lastIndex = 0;
    while ((m2 = re2.exec(text)) !== null) {
      len = this.testSchemaAt(text, m2[2], re2.lastIndex);
      if (len) {
        this.__schema__ = m2[2];
        this.__index__ = m2.index + m2[1].length;
        this.__last_index__ = m2.index + m2[0].length + len;
        break;
      }
    }
  }
  if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
    tld_pos = text.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
          shift = ml.index + ml[1].length;
          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = "";
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }
  if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
    at_pos = text.indexOf("@");
    if (at_pos >= 0) {
      if ((me = text.match(this.re.email_fuzzy)) !== null) {
        shift = me.index + me[1].length;
        next = me.index + me[0].length;
        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = "mailto:";
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }
  return this.__index__ >= 0;
};
LinkifyIt.prototype.pretest = function pretest(text) {
  return this.re.pretest.test(text);
};
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
};
LinkifyIt.prototype.match = function match2(text) {
  var shift = 0, result = [];
  if (this.__index__ >= 0 && this.__text_cache__ === text) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }
  var tail = shift ? text.slice(shift) : text;
  while (this.test(tail)) {
    result.push(createMatch(this, shift));
    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }
  if (result.length) {
    return result;
  }
  return null;
};
LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
  list = Array.isArray(list) ? list : [list];
  if (!keepOld) {
    this.__tlds__ = list.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }
  this.__tlds__ = this.__tlds__.concat(list).sort().filter(function(el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();
  compile(this);
  return this;
};
LinkifyIt.prototype.normalize = function normalize(match3) {
  if (!match3.schema) {
    match3.url = "http://" + match3.url;
  }
  if (match3.schema === "mailto:" && !/^mailto:/i.test(match3.url)) {
    match3.url = "mailto:" + match3.url;
  }
};
LinkifyIt.prototype.onCompile = function onCompile() {
};
var linkifyIt = LinkifyIt;
var tlds2 = [
  "aaa",
  "aarp",
  "abarth",
  "abb",
  "abbott",
  "abbvie",
  "abc",
  "able",
  "abogado",
  "abudhabi",
  "ac",
  "academy",
  "accenture",
  "accountant",
  "accountants",
  "aco",
  "actor",
  "ad",
  "adac",
  "ads",
  "adult",
  "ae",
  "aeg",
  "aero",
  "aetna",
  "af",
  "afamilycompany",
  "afl",
  "africa",
  "ag",
  "agakhan",
  "agency",
  "ai",
  "aig",
  "airbus",
  "airforce",
  "airtel",
  "akdn",
  "al",
  "alfaromeo",
  "alibaba",
  "alipay",
  "allfinanz",
  "allstate",
  "ally",
  "alsace",
  "alstom",
  "am",
  "amazon",
  "americanexpress",
  "americanfamily",
  "amex",
  "amfam",
  "amica",
  "amsterdam",
  "analytics",
  "android",
  "anquan",
  "anz",
  "ao",
  "aol",
  "apartments",
  "app",
  "apple",
  "aq",
  "aquarelle",
  "ar",
  "arab",
  "aramco",
  "archi",
  "army",
  "arpa",
  "art",
  "arte",
  "as",
  "asda",
  "asia",
  "associates",
  "at",
  "athleta",
  "attorney",
  "au",
  "auction",
  "audi",
  "audible",
  "audio",
  "auspost",
  "author",
  "auto",
  "autos",
  "avianca",
  "aw",
  "aws",
  "ax",
  "axa",
  "az",
  "azure",
  "ba",
  "baby",
  "baidu",
  "banamex",
  "bananarepublic",
  "band",
  "bank",
  "bar",
  "barcelona",
  "barclaycard",
  "barclays",
  "barefoot",
  "bargains",
  "baseball",
  "basketball",
  "bauhaus",
  "bayern",
  "bb",
  "bbc",
  "bbt",
  "bbva",
  "bcg",
  "bcn",
  "bd",
  "be",
  "beats",
  "beauty",
  "beer",
  "bentley",
  "berlin",
  "best",
  "bestbuy",
  "bet",
  "bf",
  "bg",
  "bh",
  "bharti",
  "bi",
  "bible",
  "bid",
  "bike",
  "bing",
  "bingo",
  "bio",
  "biz",
  "bj",
  "black",
  "blackfriday",
  "blockbuster",
  "blog",
  "bloomberg",
  "blue",
  "bm",
  "bms",
  "bmw",
  "bn",
  "bnpparibas",
  "bo",
  "boats",
  "boehringer",
  "bofa",
  "bom",
  "bond",
  "boo",
  "book",
  "booking",
  "bosch",
  "bostik",
  "boston",
  "bot",
  "boutique",
  "box",
  "br",
  "bradesco",
  "bridgestone",
  "broadway",
  "broker",
  "brother",
  "brussels",
  "bs",
  "bt",
  "budapest",
  "bugatti",
  "build",
  "builders",
  "business",
  "buy",
  "buzz",
  "bv",
  "bw",
  "by",
  "bz",
  "bzh",
  "ca",
  "cab",
  "cafe",
  "cal",
  "call",
  "calvinklein",
  "cam",
  "camera",
  "camp",
  "cancerresearch",
  "canon",
  "capetown",
  "capital",
  "capitalone",
  "car",
  "caravan",
  "cards",
  "care",
  "career",
  "careers",
  "cars",
  "casa",
  "case",
  "cash",
  "casino",
  "cat",
  "catering",
  "catholic",
  "cba",
  "cbn",
  "cbre",
  "cbs",
  "cc",
  "cd",
  "center",
  "ceo",
  "cern",
  "cf",
  "cfa",
  "cfd",
  "cg",
  "ch",
  "chanel",
  "channel",
  "charity",
  "chase",
  "chat",
  "cheap",
  "chintai",
  "christmas",
  "chrome",
  "church",
  "ci",
  "cipriani",
  "circle",
  "cisco",
  "citadel",
  "citi",
  "citic",
  "city",
  "cityeats",
  "ck",
  "cl",
  "claims",
  "cleaning",
  "click",
  "clinic",
  "clinique",
  "clothing",
  "cloud",
  "club",
  "clubmed",
  "cm",
  "cn",
  "co",
  "coach",
  "codes",
  "coffee",
  "college",
  "cologne",
  "com",
  "comcast",
  "commbank",
  "community",
  "company",
  "compare",
  "computer",
  "comsec",
  "condos",
  "construction",
  "consulting",
  "contact",
  "contractors",
  "cooking",
  "cookingchannel",
  "cool",
  "coop",
  "corsica",
  "country",
  "coupon",
  "coupons",
  "courses",
  "cpa",
  "cr",
  "credit",
  "creditcard",
  "creditunion",
  "cricket",
  "crown",
  "crs",
  "cruise",
  "cruises",
  "csc",
  "cu",
  "cuisinella",
  "cv",
  "cw",
  "cx",
  "cy",
  "cymru",
  "cyou",
  "cz",
  "dabur",
  "dad",
  "dance",
  "data",
  "date",
  "dating",
  "datsun",
  "day",
  "dclk",
  "dds",
  "de",
  "deal",
  "dealer",
  "deals",
  "degree",
  "delivery",
  "dell",
  "deloitte",
  "delta",
  "democrat",
  "dental",
  "dentist",
  "desi",
  "design",
  "dev",
  "dhl",
  "diamonds",
  "diet",
  "digital",
  "direct",
  "directory",
  "discount",
  "discover",
  "dish",
  "diy",
  "dj",
  "dk",
  "dm",
  "dnp",
  "do",
  "docs",
  "doctor",
  "dog",
  "domains",
  "dot",
  "download",
  "drive",
  "dtv",
  "dubai",
  "duck",
  "dunlop",
  "dupont",
  "durban",
  "dvag",
  "dvr",
  "dz",
  "earth",
  "eat",
  "ec",
  "eco",
  "edeka",
  "edu",
  "education",
  "ee",
  "eg",
  "email",
  "emerck",
  "energy",
  "engineer",
  "engineering",
  "enterprises",
  "epson",
  "equipment",
  "er",
  "ericsson",
  "erni",
  "es",
  "esq",
  "estate",
  "et",
  "etisalat",
  "eu",
  "eurovision",
  "eus",
  "events",
  "exchange",
  "expert",
  "exposed",
  "express",
  "extraspace",
  "fage",
  "fail",
  "fairwinds",
  "faith",
  "family",
  "fan",
  "fans",
  "farm",
  "farmers",
  "fashion",
  "fast",
  "fedex",
  "feedback",
  "ferrari",
  "ferrero",
  "fi",
  "fiat",
  "fidelity",
  "fido",
  "film",
  "final",
  "finance",
  "financial",
  "fire",
  "firestone",
  "firmdale",
  "fish",
  "fishing",
  "fit",
  "fitness",
  "fj",
  "fk",
  "flickr",
  "flights",
  "flir",
  "florist",
  "flowers",
  "fly",
  "fm",
  "fo",
  "foo",
  "food",
  "foodnetwork",
  "football",
  "ford",
  "forex",
  "forsale",
  "forum",
  "foundation",
  "fox",
  "fr",
  "free",
  "fresenius",
  "frl",
  "frogans",
  "frontdoor",
  "frontier",
  "ftr",
  "fujitsu",
  "fun",
  "fund",
  "furniture",
  "futbol",
  "fyi",
  "ga",
  "gal",
  "gallery",
  "gallo",
  "gallup",
  "game",
  "games",
  "gap",
  "garden",
  "gay",
  "gb",
  "gbiz",
  "gd",
  "gdn",
  "ge",
  "gea",
  "gent",
  "genting",
  "george",
  "gf",
  "gg",
  "ggee",
  "gh",
  "gi",
  "gift",
  "gifts",
  "gives",
  "giving",
  "gl",
  "glade",
  "glass",
  "gle",
  "global",
  "globo",
  "gm",
  "gmail",
  "gmbh",
  "gmo",
  "gmx",
  "gn",
  "godaddy",
  "gold",
  "goldpoint",
  "golf",
  "goo",
  "goodyear",
  "goog",
  "google",
  "gop",
  "got",
  "gov",
  "gp",
  "gq",
  "gr",
  "grainger",
  "graphics",
  "gratis",
  "green",
  "gripe",
  "grocery",
  "group",
  "gs",
  "gt",
  "gu",
  "guardian",
  "gucci",
  "guge",
  "guide",
  "guitars",
  "guru",
  "gw",
  "gy",
  "hair",
  "hamburg",
  "hangout",
  "haus",
  "hbo",
  "hdfc",
  "hdfcbank",
  "health",
  "healthcare",
  "help",
  "helsinki",
  "here",
  "hermes",
  "hgtv",
  "hiphop",
  "hisamitsu",
  "hitachi",
  "hiv",
  "hk",
  "hkt",
  "hm",
  "hn",
  "hockey",
  "holdings",
  "holiday",
  "homedepot",
  "homegoods",
  "homes",
  "homesense",
  "honda",
  "horse",
  "hospital",
  "host",
  "hosting",
  "hot",
  "hoteles",
  "hotels",
  "hotmail",
  "house",
  "how",
  "hr",
  "hsbc",
  "ht",
  "hu",
  "hughes",
  "hyatt",
  "hyundai",
  "ibm",
  "icbc",
  "ice",
  "icu",
  "id",
  "ie",
  "ieee",
  "ifm",
  "ikano",
  "il",
  "im",
  "imamat",
  "imdb",
  "immo",
  "immobilien",
  "in",
  "inc",
  "industries",
  "infiniti",
  "info",
  "ing",
  "ink",
  "institute",
  "insurance",
  "insure",
  "int",
  "international",
  "intuit",
  "investments",
  "io",
  "ipiranga",
  "iq",
  "ir",
  "irish",
  "is",
  "ismaili",
  "ist",
  "istanbul",
  "it",
  "itau",
  "itv",
  "jaguar",
  "java",
  "jcb",
  "je",
  "jeep",
  "jetzt",
  "jewelry",
  "jio",
  "jll",
  "jm",
  "jmp",
  "jnj",
  "jo",
  "jobs",
  "joburg",
  "jot",
  "joy",
  "jp",
  "jpmorgan",
  "jprs",
  "juegos",
  "juniper",
  "kaufen",
  "kddi",
  "ke",
  "kerryhotels",
  "kerrylogistics",
  "kerryproperties",
  "kfh",
  "kg",
  "kh",
  "ki",
  "kia",
  "kim",
  "kinder",
  "kindle",
  "kitchen",
  "kiwi",
  "km",
  "kn",
  "koeln",
  "komatsu",
  "kosher",
  "kp",
  "kpmg",
  "kpn",
  "kr",
  "krd",
  "kred",
  "kuokgroup",
  "kw",
  "ky",
  "kyoto",
  "kz",
  "la",
  "lacaixa",
  "lamborghini",
  "lamer",
  "lancaster",
  "lancia",
  "land",
  "landrover",
  "lanxess",
  "lasalle",
  "lat",
  "latino",
  "latrobe",
  "law",
  "lawyer",
  "lb",
  "lc",
  "lds",
  "lease",
  "leclerc",
  "lefrak",
  "legal",
  "lego",
  "lexus",
  "lgbt",
  "li",
  "lidl",
  "life",
  "lifeinsurance",
  "lifestyle",
  "lighting",
  "like",
  "lilly",
  "limited",
  "limo",
  "lincoln",
  "linde",
  "link",
  "lipsy",
  "live",
  "living",
  "lixil",
  "lk",
  "llc",
  "llp",
  "loan",
  "loans",
  "locker",
  "locus",
  "loft",
  "lol",
  "london",
  "lotte",
  "lotto",
  "love",
  "lpl",
  "lplfinancial",
  "lr",
  "ls",
  "lt",
  "ltd",
  "ltda",
  "lu",
  "lundbeck",
  "luxe",
  "luxury",
  "lv",
  "ly",
  "ma",
  "macys",
  "madrid",
  "maif",
  "maison",
  "makeup",
  "man",
  "management",
  "mango",
  "map",
  "market",
  "marketing",
  "markets",
  "marriott",
  "marshalls",
  "maserati",
  "mattel",
  "mba",
  "mc",
  "mckinsey",
  "md",
  "me",
  "med",
  "media",
  "meet",
  "melbourne",
  "meme",
  "memorial",
  "men",
  "menu",
  "merckmsd",
  "mg",
  "mh",
  "miami",
  "microsoft",
  "mil",
  "mini",
  "mint",
  "mit",
  "mitsubishi",
  "mk",
  "ml",
  "mlb",
  "mls",
  "mm",
  "mma",
  "mn",
  "mo",
  "mobi",
  "mobile",
  "moda",
  "moe",
  "moi",
  "mom",
  "monash",
  "money",
  "monster",
  "mormon",
  "mortgage",
  "moscow",
  "moto",
  "motorcycles",
  "mov",
  "movie",
  "mp",
  "mq",
  "mr",
  "ms",
  "msd",
  "mt",
  "mtn",
  "mtr",
  "mu",
  "museum",
  "mutual",
  "mv",
  "mw",
  "mx",
  "my",
  "mz",
  "na",
  "nab",
  "nagoya",
  "name",
  "natura",
  "navy",
  "nba",
  "nc",
  "ne",
  "nec",
  "net",
  "netbank",
  "netflix",
  "network",
  "neustar",
  "new",
  "news",
  "next",
  "nextdirect",
  "nexus",
  "nf",
  "nfl",
  "ng",
  "ngo",
  "nhk",
  "ni",
  "nico",
  "nike",
  "nikon",
  "ninja",
  "nissan",
  "nissay",
  "nl",
  "no",
  "nokia",
  "northwesternmutual",
  "norton",
  "now",
  "nowruz",
  "nowtv",
  "np",
  "nr",
  "nra",
  "nrw",
  "ntt",
  "nu",
  "nyc",
  "nz",
  "obi",
  "observer",
  "off",
  "office",
  "okinawa",
  "olayan",
  "olayangroup",
  "oldnavy",
  "ollo",
  "om",
  "omega",
  "one",
  "ong",
  "onl",
  "online",
  "ooo",
  "open",
  "oracle",
  "orange",
  "org",
  "organic",
  "origins",
  "osaka",
  "otsuka",
  "ott",
  "ovh",
  "pa",
  "page",
  "panasonic",
  "paris",
  "pars",
  "partners",
  "parts",
  "party",
  "passagens",
  "pay",
  "pccw",
  "pe",
  "pet",
  "pf",
  "pfizer",
  "pg",
  "ph",
  "pharmacy",
  "phd",
  "philips",
  "phone",
  "photo",
  "photography",
  "photos",
  "physio",
  "pics",
  "pictet",
  "pictures",
  "pid",
  "pin",
  "ping",
  "pink",
  "pioneer",
  "pizza",
  "pk",
  "pl",
  "place",
  "play",
  "playstation",
  "plumbing",
  "plus",
  "pm",
  "pn",
  "pnc",
  "pohl",
  "poker",
  "politie",
  "porn",
  "post",
  "pr",
  "pramerica",
  "praxi",
  "press",
  "prime",
  "pro",
  "prod",
  "productions",
  "prof",
  "progressive",
  "promo",
  "properties",
  "property",
  "protection",
  "pru",
  "prudential",
  "ps",
  "pt",
  "pub",
  "pw",
  "pwc",
  "py",
  "qa",
  "qpon",
  "quebec",
  "quest",
  "racing",
  "radio",
  "raid",
  "re",
  "read",
  "realestate",
  "realtor",
  "realty",
  "recipes",
  "red",
  "redstone",
  "redumbrella",
  "rehab",
  "reise",
  "reisen",
  "reit",
  "reliance",
  "ren",
  "rent",
  "rentals",
  "repair",
  "report",
  "republican",
  "rest",
  "restaurant",
  "review",
  "reviews",
  "rexroth",
  "rich",
  "richardli",
  "ricoh",
  "ril",
  "rio",
  "rip",
  "ro",
  "rocher",
  "rocks",
  "rodeo",
  "rogers",
  "room",
  "rs",
  "rsvp",
  "ru",
  "rugby",
  "ruhr",
  "run",
  "rw",
  "rwe",
  "ryukyu",
  "sa",
  "saarland",
  "safe",
  "safety",
  "sakura",
  "sale",
  "salon",
  "samsclub",
  "samsung",
  "sandvik",
  "sandvikcoromant",
  "sanofi",
  "sap",
  "sarl",
  "sas",
  "save",
  "saxo",
  "sb",
  "sbi",
  "sbs",
  "sc",
  "sca",
  "scb",
  "schaeffler",
  "schmidt",
  "scholarships",
  "school",
  "schule",
  "schwarz",
  "science",
  "scjohnson",
  "scot",
  "sd",
  "se",
  "search",
  "seat",
  "secure",
  "security",
  "seek",
  "select",
  "sener",
  "services",
  "ses",
  "seven",
  "sew",
  "sex",
  "sexy",
  "sfr",
  "sg",
  "sh",
  "shangrila",
  "sharp",
  "shaw",
  "shell",
  "shia",
  "shiksha",
  "shoes",
  "shop",
  "shopping",
  "shouji",
  "show",
  "showtime",
  "si",
  "silk",
  "sina",
  "singles",
  "site",
  "sj",
  "sk",
  "ski",
  "skin",
  "sky",
  "skype",
  "sl",
  "sling",
  "sm",
  "smart",
  "smile",
  "sn",
  "sncf",
  "so",
  "soccer",
  "social",
  "softbank",
  "software",
  "sohu",
  "solar",
  "solutions",
  "song",
  "sony",
  "soy",
  "spa",
  "space",
  "sport",
  "spot",
  "sr",
  "srl",
  "ss",
  "st",
  "stada",
  "staples",
  "star",
  "statebank",
  "statefarm",
  "stc",
  "stcgroup",
  "stockholm",
  "storage",
  "store",
  "stream",
  "studio",
  "study",
  "style",
  "su",
  "sucks",
  "supplies",
  "supply",
  "support",
  "surf",
  "surgery",
  "suzuki",
  "sv",
  "swatch",
  "swiss",
  "sx",
  "sy",
  "sydney",
  "systems",
  "sz",
  "tab",
  "taipei",
  "talk",
  "taobao",
  "target",
  "tatamotors",
  "tatar",
  "tattoo",
  "tax",
  "taxi",
  "tc",
  "tci",
  "td",
  "tdk",
  "team",
  "tech",
  "technology",
  "tel",
  "temasek",
  "tennis",
  "teva",
  "tf",
  "tg",
  "th",
  "thd",
  "theater",
  "theatre",
  "tiaa",
  "tickets",
  "tienda",
  "tiffany",
  "tips",
  "tires",
  "tirol",
  "tj",
  "tjmaxx",
  "tjx",
  "tk",
  "tkmaxx",
  "tl",
  "tm",
  "tmall",
  "tn",
  "to",
  "today",
  "tokyo",
  "tools",
  "top",
  "toray",
  "toshiba",
  "total",
  "tours",
  "town",
  "toyota",
  "toys",
  "tr",
  "trade",
  "trading",
  "training",
  "travel",
  "travelchannel",
  "travelers",
  "travelersinsurance",
  "trust",
  "trv",
  "tt",
  "tube",
  "tui",
  "tunes",
  "tushu",
  "tv",
  "tvs",
  "tw",
  "tz",
  "ua",
  "ubank",
  "ubs",
  "ug",
  "uk",
  "unicom",
  "university",
  "uno",
  "uol",
  "ups",
  "us",
  "uy",
  "uz",
  "va",
  "vacations",
  "vana",
  "vanguard",
  "vc",
  "ve",
  "vegas",
  "ventures",
  "verisign",
  "verm\xF6gensberater",
  "verm\xF6gensberatung",
  "versicherung",
  "vet",
  "vg",
  "vi",
  "viajes",
  "video",
  "vig",
  "viking",
  "villas",
  "vin",
  "vip",
  "virgin",
  "visa",
  "vision",
  "viva",
  "vivo",
  "vlaanderen",
  "vn",
  "vodka",
  "volkswagen",
  "volvo",
  "vote",
  "voting",
  "voto",
  "voyage",
  "vu",
  "vuelos",
  "wales",
  "walmart",
  "walter",
  "wang",
  "wanggou",
  "watch",
  "watches",
  "weather",
  "weatherchannel",
  "webcam",
  "weber",
  "website",
  "wed",
  "wedding",
  "weibo",
  "weir",
  "wf",
  "whoswho",
  "wien",
  "wiki",
  "williamhill",
  "win",
  "windows",
  "wine",
  "winners",
  "wme",
  "wolterskluwer",
  "woodside",
  "work",
  "works",
  "world",
  "wow",
  "ws",
  "wtc",
  "wtf",
  "xbox",
  "xerox",
  "xfinity",
  "xihuan",
  "xin",
  "xxx",
  "xyz",
  "yachts",
  "yahoo",
  "yamaxun",
  "yandex",
  "ye",
  "yodobashi",
  "yoga",
  "yokohama",
  "you",
  "youtube",
  "yt",
  "yun",
  "za",
  "zappos",
  "zara",
  "zero",
  "zip",
  "zm",
  "zone",
  "zuerich",
  "zw",
  "\u03B5\u03BB",
  "\u03B5\u03C5",
  "\u0431\u0433",
  "\u0431\u0435\u043B",
  "\u0434\u0435\u0442\u0438",
  "\u0435\u044E",
  "\u043A\u0430\u0442\u043E\u043B\u0438\u043A",
  "\u043A\u043E\u043C",
  "\u043C\u043A\u0434",
  "\u043C\u043E\u043D",
  "\u043C\u043E\u0441\u043A\u0432\u0430",
  "\u043E\u043D\u043B\u0430\u0439\u043D",
  "\u043E\u0440\u0433",
  "\u0440\u0443\u0441",
  "\u0440\u0444",
  "\u0441\u0430\u0439\u0442",
  "\u0441\u0440\u0431",
  "\u0443\u043A\u0440",
  "\u049B\u0430\u0437",
  "\u0570\u0561\u0575",
  "\u05D9\u05E9\u05E8\u05D0\u05DC",
  "\u05E7\u05D5\u05DD",
  "\u0627\u0628\u0648\u0638\u0628\u064A",
  "\u0627\u062A\u0635\u0627\u0644\u0627\u062A",
  "\u0627\u0631\u0627\u0645\u0643\u0648",
  "\u0627\u0644\u0627\u0631\u062F\u0646",
  "\u0627\u0644\u0628\u062D\u0631\u064A\u0646",
  "\u0627\u0644\u062C\u0632\u0627\u0626\u0631",
  "\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629",
  "\u0627\u0644\u0639\u0644\u064A\u0627\u0646",
  "\u0627\u0644\u0645\u063A\u0631\u0628",
  "\u0627\u0645\u0627\u0631\u0627\u062A",
  "\u0627\u06CC\u0631\u0627\u0646",
  "\u0628\u0627\u0631\u062A",
  "\u0628\u0627\u0632\u0627\u0631",
  "\u0628\u064A\u062A\u0643",
  "\u0628\u06BE\u0627\u0631\u062A",
  "\u062A\u0648\u0646\u0633",
  "\u0633\u0648\u062F\u0627\u0646",
  "\u0633\u0648\u0631\u064A\u0629",
  "\u0634\u0628\u0643\u0629",
  "\u0639\u0631\u0627\u0642",
  "\u0639\u0631\u0628",
  "\u0639\u0645\u0627\u0646",
  "\u0641\u0644\u0633\u0637\u064A\u0646",
  "\u0642\u0637\u0631",
  "\u0643\u0627\u062B\u0648\u0644\u064A\u0643",
  "\u0643\u0648\u0645",
  "\u0645\u0635\u0631",
  "\u0645\u0644\u064A\u0633\u064A\u0627",
  "\u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627",
  "\u0645\u0648\u0642\u0639",
  "\u0647\u0645\u0631\u0627\u0647",
  "\u067E\u0627\u06A9\u0633\u062A\u0627\u0646",
  "\u0680\u0627\u0631\u062A",
  "\u0915\u0949\u092E",
  "\u0928\u0947\u091F",
  "\u092D\u093E\u0930\u0924",
  "\u092D\u093E\u0930\u0924\u092E\u094D",
  "\u092D\u093E\u0930\u094B\u0924",
  "\u0938\u0902\u0917\u0920\u0928",
  "\u09AC\u09BE\u0982\u09B2\u09BE",
  "\u09AD\u09BE\u09B0\u09A4",
  "\u09AD\u09BE\u09F0\u09A4",
  "\u0A2D\u0A3E\u0A30\u0A24",
  "\u0AAD\u0ABE\u0AB0\u0AA4",
  "\u0B2D\u0B3E\u0B30\u0B24",
  "\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE",
  "\u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8",
  "\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD",
  "\u0C2D\u0C3E\u0C30\u0C24\u0C4D",
  "\u0CAD\u0CBE\u0CB0\u0CA4",
  "\u0D2D\u0D3E\u0D30\u0D24\u0D02",
  "\u0DBD\u0D82\u0D9A\u0DCF",
  "\u0E04\u0E2D\u0E21",
  "\u0E44\u0E17\u0E22",
  "\u0EA5\u0EB2\u0EA7",
  "\u10D2\u10D4",
  "\u307F\u3093\u306A",
  "\u30A2\u30DE\u30BE\u30F3",
  "\u30AF\u30E9\u30A6\u30C9",
  "\u30B0\u30FC\u30B0\u30EB",
  "\u30B3\u30E0",
  "\u30B9\u30C8\u30A2",
  "\u30BB\u30FC\u30EB",
  "\u30D5\u30A1\u30C3\u30B7\u30E7\u30F3",
  "\u30DD\u30A4\u30F3\u30C8",
  "\u4E16\u754C",
  "\u4E2D\u4FE1",
  "\u4E2D\u56FD",
  "\u4E2D\u570B",
  "\u4E2D\u6587\u7F51",
  "\u4E9A\u9A6C\u900A",
  "\u4F01\u4E1A",
  "\u4F5B\u5C71",
  "\u4FE1\u606F",
  "\u5065\u5EB7",
  "\u516B\u5366",
  "\u516C\u53F8",
  "\u516C\u76CA",
  "\u53F0\u6E7E",
  "\u53F0\u7063",
  "\u5546\u57CE",
  "\u5546\u5E97",
  "\u5546\u6807",
  "\u5609\u91CC",
  "\u5609\u91CC\u5927\u9152\u5E97",
  "\u5728\u7EBF",
  "\u5927\u4F17\u6C7D\u8F66",
  "\u5927\u62FF",
  "\u5929\u4E3B\u6559",
  "\u5A31\u4E50",
  "\u5BB6\u96FB",
  "\u5E7F\u4E1C",
  "\u5FAE\u535A",
  "\u6148\u5584",
  "\u6211\u7231\u4F60",
  "\u624B\u673A",
  "\u62DB\u8058",
  "\u653F\u52A1",
  "\u653F\u5E9C",
  "\u65B0\u52A0\u5761",
  "\u65B0\u95FB",
  "\u65F6\u5C1A",
  "\u66F8\u7C4D",
  "\u673A\u6784",
  "\u6DE1\u9A6C\u9521",
  "\u6E38\u620F",
  "\u6FB3\u9580",
  "\u70B9\u770B",
  "\u79FB\u52A8",
  "\u7EC4\u7EC7\u673A\u6784",
  "\u7F51\u5740",
  "\u7F51\u5E97",
  "\u7F51\u7AD9",
  "\u7F51\u7EDC",
  "\u8054\u901A",
  "\u8BFA\u57FA\u4E9A",
  "\u8C37\u6B4C",
  "\u8D2D\u7269",
  "\u901A\u8CA9",
  "\u96C6\u56E2",
  "\u96FB\u8A0A\u76C8\u79D1",
  "\u98DE\u5229\u6D66",
  "\u98DF\u54C1",
  "\u9910\u5385",
  "\u9999\u683C\u91CC\u62C9",
  "\u9999\u6E2F",
  "\uB2F7\uB137",
  "\uB2F7\uCEF4",
  "\uC0BC\uC131",
  "\uD55C\uAD6D"
];
const linkify$3 = linkifyIt();
linkify$3.tlds(tlds2);
const Wrapper$2 = styled.div`
  display: inline-block;
  position: relative;
`;
const ImageWrapper = styled.div`
  display: flex;
  justify-content: center;
  img {
    max-height: ${pxToRem(200)};
    max-width: 100%;
  }
`;
const ImageLinked = ({
  src: src2
}) => {
  return /* @__PURE__ */ jsx(ImageWrapper, {
    children: /* @__PURE__ */ jsx("img", {
      src: getImageUrl(src2),
      alt: ""
    })
  });
};
const Link$1 = ({
  contentState,
  entityKey,
  children
}) => {
  const [isVisible, setVisible] = useState(false);
  const {
    url
  } = contentState.getEntity(entityKey).getData();
  const [{
    editorState,
    focus
  }, dispatch] = useContext(EditorContext);
  const hasFocus = hasEntityFocus(contentState, editorState, entityKey);
  useEffect(() => {
    setTimeout(() => setVisible(hasFocus && focus), 0);
  }, [focus, editorState]);
  return /* @__PURE__ */ jsxs(Wrapper$2, {
    "aria-live": "assertive",
    children: [/* @__PURE__ */ jsx("a", {
      href: url,
      target: "_blank",
      className: "k-u-link k-u-link-primary1",
      rel: "nofollow noopener",
      children
    }), isVisible && /* @__PURE__ */ jsx(LinkInline, {
      url,
      onDelete: () => {
        var _a;
        const currentContent = contentState == null ? void 0 : contentState.getBlockForKey((_a = editorState == null ? void 0 : editorState.getSelection()) == null ? void 0 : _a.getFocusKey());
        if (!currentContent)
          return;
        currentContent.findEntityRanges((character) => {
          return character.getEntity() === entityKey;
        }, (start, end) => {
          const newsSelection = editorState.getSelection().merge({
            focusOffset: end,
            anchorOffset: start
          });
          const newsEditorState = Draft.Modifier.applyEntity(contentState, newsSelection, null);
          dispatch(updateEditor(Draft.EditorState.push(editorState, newsEditorState, "apply-entity")));
        });
      }
    })]
  });
};
const linkStrategy$1 = (contentBlock, callback, contentState) => {
  contentBlock.findEntityRanges((character) => {
    const entityKey = character.getEntity();
    return entityKey !== null && contentState.getEntity(entityKey).getType() === "LINK";
  }, callback);
};
const decorator$1 = {
  strategy: linkStrategy$1,
  component: Link$1
};
const readDecorator$1 = {
  strategy: linkStrategy$1,
  component: (props) => {
    const {
      url
    } = props.contentState.getEntity(props.entityKey).getData();
    return /* @__PURE__ */ jsx(Wrapper$2, {
      children: /* @__PURE__ */ jsx("a", {
        href: url,
        target: "_blank",
        rel: "nofollow noopener",
        className: "k-u-link k-u-link-primary1",
        children: props.children
      })
    });
  }
};
const LinkControls = ({
  disabled,
  onChange
}) => {
  const [modalOpened, openModal] = useState(false);
  const [{
    editorState,
    editorRef,
    translations,
    disabled: contextDisabled
  }, dispatch] = useContext(EditorContext);
  const entity = getEntity(editorState);
  const entityKey = getEntityKey(editorState);
  const textToShow = () => {
    if (!entity) {
      return getCurrentSelection(editorState);
    }
    return getEntityText(editorState, entityKey);
  };
  const forceFocus = () => {
    const currentSelection = editorState.getSelection();
    setTimeout(() => editorRef.current.focus(), 0);
    const newSelectionAtTheEnd = currentSelection.merge({
      anchorOffset: currentSelection.getFocusOffset(),
      hasFocus: true
    });
    dispatch(updateEditor(Draft.EditorState.forceSelection(editorState, newSelectionAtTheEnd)));
  };
  const active = !contextDisabled && !disabled && (entity || !isEmpty(textToShow()));
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsx(Button, {
      icon: "link",
      disabled: !active,
      onToggle: () => {
        if (modalOpened) {
          openModal(false);
        } else {
          openModal(true);
        }
      }
    }), /* @__PURE__ */ jsx(ModalNext, {
      onClose: () => {
        openModal(false);
        forceFocus();
      },
      isOpen: modalOpened,
      variant: "orion",
      headerTitle: /* @__PURE__ */ jsx(Title$1, {
        modifier: "quaternary",
        children: translations.link.title
      }),
      children: ({
        close
      }) => {
        return /* @__PURE__ */ jsx(ModalNext.Block, {
          children: /* @__PURE__ */ jsx(Formik, {
            enableReinitialize: true,
            initialValues: {
              url: entity ? entity.getData().url : "",
              text: textToShow()
            },
            onSubmit: ({
              url
            }) => {
              const link = linkify$3.match(url);
              const contentState = editorState.getCurrentContent();
              onChange();
              if (entity) {
                if ((entity == null ? void 0 : entity.get("type")) === "IMAGE") {
                  const newImageContentState = contentState.mergeEntityData(entityKey, {
                    url: link[0].url
                  });
                  dispatch(updateEditor(Draft.EditorState.push(editorState, newImageContentState, "change-block-data")));
                } else {
                  const newContentState = contentState.replaceEntityData(entityKey, {
                    url: link[0].url
                  });
                  dispatch(updateEditor(Draft.EditorState.push(editorState, newContentState, "change-block-data")));
                }
              } else {
                const contentStateWithEntity = contentState.createEntity("LINK", "MUTABLE", {
                  url: link[0].url
                });
                const entityKey2 = contentStateWithEntity.getLastCreatedEntityKey();
                const newEditorState = Draft.EditorState.set(editorState, {
                  currentContent: contentStateWithEntity
                });
                dispatch(updateEditor(Draft.RichUtils.toggleLink(newEditorState, newEditorState.getSelection(), entityKey2)));
              }
              close();
              openModal(false);
              setTimeout(() => editorRef.current.focus(), 0);
            },
            children: ({
              handleSubmit
            }) => {
              var _a;
              return /* @__PURE__ */ jsxs(Fragment, {
                children: [/* @__PURE__ */ jsx("div", {
                  className: "k-u-margin-bottom-double",
                  children: (entity == null ? void 0 : entity.get("type")) === "IMAGE" ? /* @__PURE__ */ jsx(ImageLinked, {
                    src: (_a = entity == null ? void 0 : entity.getData()) == null ? void 0 : _a.src
                  }) : /* @__PURE__ */ jsxs(Fragment, {
                    children: [/* @__PURE__ */ jsx(Label, {
                      htmlFor: "",
                      children: translations.link.text.label
                    }), /* @__PURE__ */ jsx(InputText, {
                      name: "text",
                      disabled: true
                    })]
                  })
                }), /* @__PURE__ */ jsxs("div", {
                  className: "k-u-margin-vertical-double",
                  children: [/* @__PURE__ */ jsx(Label, {
                    size: "micro",
                    htmlFor: "url",
                    children: translations.image_upload.url
                  }), /* @__PURE__ */ jsx(InputText, {
                    name: "url",
                    variant: "orion",
                    validate: (value) => {
                      if (!linkify$3.test(value)) {
                        return translations.link.error;
                      }
                    }
                  })]
                }), /* @__PURE__ */ jsx(ModalNext.Actions, {
                  children: /* @__PURE__ */ jsx(ModalNext.Button, {
                    size: "big",
                    type: "button",
                    variant: "orion",
                    modifier: "helium",
                    onClick: handleSubmit,
                    children: translations.submit
                  })
                })]
              });
            }
          })
        });
      }
    })]
  });
};
LinkControls.propTypes = {
  disabled: PropTypes.bool,
  onChange: PropTypes.func
};
LinkControls.defaultProps = {
  disabled: false,
  onChange: () => null
};
const linkify$2 = linkifyIt();
linkify$2.tlds(tlds2);
const Wrapper$1 = styled.div`
  position: relative;
  margin: ${pxToRem(30)} 0;

  @media (min-width: ${pxToRem(ScreenConfig.S.min)}) {
    display: inline-block;
  }
`;
const ButtonLinkWithFluidStyle = styled(Button$1)`
  @media (max-width: ${pxToRem(ScreenConfig.XS.max)}) {
    min-width: initial;
    width: 100%;
  }
`;
const StyledArrowContainer = styled(ArrowContainer)`
  display: flex;
  position: absolute;
  min-width: max-content;
  padding: 0 ${pxToRem(20)};
  background-color: ${COLORS.background1};
  margin-top: ${pxToRem(5)};
  transition: opacity 0.1s ease-out, margin-top 0.1s ease-out;
`;
const DeleteLink = styled(Text)`
  display: block;
  width: 100%;
  padding: 0;
  text-align: center;
`;
const VerticalSeparator = styled.span`
  margin: ${pxToRem(5)} ${pxToRem(10)};
  border-left: ${pxToRem(2)} solid ${COLORS.font2};
`;
const ShareLink = styled(Text)`
  overflow: hidden;
  display: inline-block;
  max-width: ${pxToRem(150)};
  text-overflow: ellipsis;
  white-space: nowrap;
`;
const StyledButtonLink = ({
  href,
  children
}) => {
  return /* @__PURE__ */ jsx(ButtonLinkWithFluidStyle, {
    tag: "a",
    href,
    target: "_blank",
    rel: "nofollow noopener",
    modifier: "helium",
    size: "big",
    variant: "orion",
    children
  });
};
const ButtonLink = ({
  contentState,
  entityKey,
  children
}) => {
  const [isVisible, setVisible] = useState(false);
  const {
    url
  } = contentState.getEntity(entityKey).getData();
  const [{
    editorState,
    focus,
    translations
  }, dispatch] = useContext(EditorContext);
  const hasFocus = hasEntityFocus(contentState, editorState, entityKey);
  useEffect(() => {
    setTimeout(() => setVisible(hasFocus && focus), 0);
  }, [focus, editorState]);
  return /* @__PURE__ */ jsxs(Wrapper$1, {
    "aria-live": "assertive",
    children: [/* @__PURE__ */ jsx(StyledButtonLink, {
      href: url,
      children
    }), isVisible && /* @__PURE__ */ jsxs(StyledArrowContainer, {
      position: "top",
      shadow: true,
      borderWidth: 1,
      borderColor: COLORS.line1,
      contentEditable: false,
      children: [/* @__PURE__ */ jsx(DeleteLink, {
        href: "#",
        tag: "a",
        size: "micro",
        weight: "regular",
        color: "error",
        onClick: (e) => {
          e.preventDefault();
          const currentContent = contentState.getBlockForKey(editorState.getSelection().getFocusKey());
          currentContent.findEntityRanges((character) => {
            return character.getEntity() === entityKey;
          }, (start, end) => {
            const newsSelection = editorState.getSelection().merge({
              focusOffset: end,
              anchorOffset: start
            });
            const newsEditorState = Draft.Modifier.applyEntity(contentState, newsSelection, null);
            dispatch(updateEditor(Draft.EditorState.push(editorState, newsEditorState, "apply-entity")));
          });
        },
        children: translations.link.button.delete
      }), /* @__PURE__ */ jsx(VerticalSeparator, {}), /* @__PURE__ */ jsx(ShareLink, {
        href: url,
        target: "_blank",
        rel: "noopener",
        tag: "a",
        size: "micro",
        weight: "regular",
        color: "font1",
        children: url
      })]
    })]
  });
};
const buttonLinkStrategy = (contentBlock, callback, contentState) => {
  contentBlock.findEntityRanges((character) => {
    const entityKey = character.getEntity();
    return entityKey !== null && contentState.getEntity(entityKey).getType() === "BUTTON_LINK";
  }, callback);
};
const decorator = {
  strategy: buttonLinkStrategy,
  component: ButtonLink
};
const readDecorator = {
  strategy: buttonLinkStrategy,
  component: (props) => {
    const {
      url
    } = props.contentState.getEntity(props.entityKey).getData();
    return /* @__PURE__ */ jsx(Wrapper$1, {
      children: /* @__PURE__ */ jsx(StyledButtonLink, {
        href: url,
        children: props.children
      })
    });
  }
};
const ButtonLinkControls = ({
  disabled,
  onChange
}) => {
  const [{
    editorState,
    editorRef,
    translations
  }, dispatch] = useContext(EditorContext);
  const entity = getEntity(editorState);
  const entityKey = getEntityKey(editorState);
  const textToShow = () => {
    if (!entity) {
      return getCurrentSelection(editorState);
    }
    return getEntityText(editorState, entityKey);
  };
  return /* @__PURE__ */ jsx(ModalNext, {
    variant: "orion",
    headerTitle: /* @__PURE__ */ jsx(Title$1, {
      noMargin: true,
      modifier: "quaternary",
      children: translations.button_link.title
    }),
    trigger: /* @__PURE__ */ jsx(Button, {
      icon: "button_link",
      className: "Editor__toolbar__button--large",
      disabled
    }),
    children: ({
      close
    }) => {
      return /* @__PURE__ */ jsx(Formik, {
        enableReinitialize: true,
        initialValues: {
          url: entity ? entity.getData().url : "",
          text: textToShow()
        },
        onSubmit: ({
          url
        }) => {
          onChange(url);
          const link = linkify$2.match(url);
          const contentState = editorState.getCurrentContent();
          if (entity) {
            const newContentState = contentState.replaceEntityData(entityKey, {
              url: link[0].url
            });
            dispatch(updateEditor(Draft.EditorState.push(editorState, newContentState, "change-block-data")));
          } else {
            const contentStateWithEntity = contentState.createEntity("BUTTON_LINK", "MUTABLE", {
              url: link[0].url
            });
            const entityKey2 = contentStateWithEntity.getLastCreatedEntityKey();
            const newEditorState = Draft.EditorState.set(editorState, {
              currentContent: contentStateWithEntity
            });
            dispatch(updateEditor(Draft.RichUtils.toggleLink(newEditorState, newEditorState.getSelection(), entityKey2)));
          }
          close();
          setTimeout(() => editorRef.current.blur(), 0);
        },
        children: ({
          handleSubmit
        }) => {
          return /* @__PURE__ */ jsxs(Fragment, {
            children: [/* @__PURE__ */ jsxs(ModalNext.Block, {
              className: "k-u-margin-bottom-quadruple",
              children: [/* @__PURE__ */ jsxs("div", {
                className: "k-u-margin-bottom-double",
                children: [/* @__PURE__ */ jsx(Label, {
                  htmlFor: "",
                  children: translations.button_link.text
                }), /* @__PURE__ */ jsx(InputText, {
                  name: "text",
                  disabled: true
                })]
              }), /* @__PURE__ */ jsx(Label, {
                htmlFor: "url",
                children: translations.button_link.url
              }), /* @__PURE__ */ jsx(InputText, {
                name: "url",
                validate: (value) => {
                  if (!linkify$2.test(value)) {
                    return translations.link.error;
                  }
                }
              })]
            }), /* @__PURE__ */ jsx(ModalNext.Button, {
              fluid: true,
              size: "big",
              type: "button",
              modifier: "helium",
              variant: "orion",
              onClick: handleSubmit,
              children: translations.submit
            })]
          });
        }
      });
    }
  });
};
ButtonLinkControls.propTypes = {
  disabled: PropTypes.bool,
  onChange: PropTypes.func
};
ButtonLinkControls.defaultProps = {
  disabled: false,
  onChange: () => null
};
const linkify = linkifyIt({
  fuzzyLink: false
});
linkify.tlds(tlds2);
const linkStrategy = (contentBlock, callback) => {
  const links = linkify.match(contentBlock.get("text"));
  if (typeof links !== "undefined" && links !== null) {
    for (let i = 0; i < links.length; i += 1) {
      callback(links[i].index, links[i].lastIndex);
    }
  }
};
const Link = (props) => {
  return /* @__PURE__ */ jsx("a", {
    target: "_blank",
    rel: "nofollow noopener",
    className: "k-u-link k-u-link-primary1",
    href: props.decoratedText,
    children: props.children
  });
};
var linkify$1 = {
  strategy: linkStrategy,
  component: Link
};
const isJSONContent$1 = (content) => {
  try {
    JSON.parse(content);
    return true;
  } catch (e) {
    return false;
  }
};
const getEditorValue = (value) => {
  if (!domElementHelper.canUseDom())
    return null;
  if (!value || isEmpty(value)) {
    return Draft.EditorState.createEmpty();
  }
  try {
    return Draft.EditorState.createWithContent(isJSONContent$1(value) ? Draft.convertFromRaw(JSON.parse(value)) : Draft.convertFromRaw(getRawContent(value, true)));
  } catch (e) {
    return Draft.EditorState.createEmpty();
  }
};
const resetEditor = (editorState) => {
  return Draft.EditorState.set(editorState, {
    decorator: new Draft.CompositeDecorator([decorator$2, decorator$3, decorator$1, decorator, linkify$1])
  });
};
const resetTypeOnSelectionAfter = (editorState) => {
  const contentState = editorState.getCurrentContent();
  return Draft.EditorState.push(editorState, Draft.Modifier.setBlockType(contentState, contentState.getSelectionAfter(), "unstyled"), "change-block-type");
};
const getCurrentAlignmentStyle = (editorState) => {
  const currentContent = editorState.getCurrentContent();
  const selection = editorState.getSelection();
  return currentContent.getBlockForKey(selection.getStartKey()).getData().get("alignmentStyle");
};
const getCurrentBlock = (editorState) => {
  const selectionState = editorState.getSelection();
  const anchorKey = selectionState.getAnchorKey();
  const currentContent = editorState.getCurrentContent();
  return currentContent.getBlockForKey(anchorKey);
};
const getCurrentSelection = (editorState) => {
  const currentContentBlock = getCurrentBlock(editorState);
  const selectionState = editorState.getSelection();
  const start = selectionState.getStartOffset();
  const end = selectionState.getEndOffset();
  return currentContentBlock.getText().slice(start, end);
};
const getEntityKey = (editorState) => {
  const contentState = editorState.getCurrentContent();
  const startKey = editorState.getSelection().getStartKey();
  const startOffset = editorState.getSelection().getStartOffset();
  const blockWithLinkAtBeginning = contentState.getBlockForKey(startKey);
  return blockWithLinkAtBeginning.getEntityAt(startOffset);
};
const getEntity = (editorState) => {
  const contentState = editorState.getCurrentContent();
  const entityKey = getEntityKey(editorState);
  return !entityKey ? void 0 : contentState.getEntity(entityKey);
};
const getEntityText = (editorState, entityKey) => {
  let text = void 0;
  const contentState = editorState.getCurrentContent();
  const selection = editorState.getSelection();
  const currentContent = contentState.getBlockForKey(selection.getFocusKey());
  currentContent.findEntityRanges((char) => char.getEntity() === entityKey, (start, end) => {
    text = currentContent.getText().slice(start, end);
  });
  return text;
};
const hasEntityFocus = (contentState, editorState, entityKey) => {
  const currentContent = contentState.getBlockForKey(editorState.getSelection().getFocusKey());
  if (!currentContent)
    return false;
  const currentEntityFocused = currentContent.getEntityAt(editorState.getSelection().getStartOffset());
  return entityKey === currentEntityFocused;
};
const isPreviousBlockAnImage = (editorState) => {
  const currentContent = editorState.getCurrentContent();
  const selectionState = editorState.getSelection();
  const anchorKey = selectionState.getAnchorKey();
  const beforeBlock = currentContent.getBlockBefore(anchorKey);
  const blockType = beforeBlock == null ? void 0 : beforeBlock.get("type");
  return blockType === "atomic";
};
const isEmptyBlock = (editorState) => {
  const currentContent = editorState.getCurrentContent();
  const selectionState = editorState.getSelection();
  const anchorKey = selectionState.getAnchorKey();
  const curentBlock = currentContent.getBlockForKey(anchorKey);
  return flow(trim, isEmpty)(curentBlock.getText());
};
const isFirstBlock = (editorState) => {
  const currentContent = editorState.getCurrentContent();
  const selectionState = editorState.getSelection();
  const anchorKey = selectionState.getAnchorKey();
  const beforeBlock = currentContent.getBlockBefore(anchorKey);
  return !beforeBlock;
};
const isCurrentBlockAllSelected = (editorState) => {
  var _a, _b, _c;
  const selectionState = editorState.getSelection();
  const anchorKey = selectionState.getAnchorKey();
  const currentContent = editorState.getCurrentContent();
  const currentContentBlock = currentContent.getBlockForKey(anchorKey);
  const blockTextLength = (_a = currentContentBlock == null ? void 0 : currentContentBlock.get("text")) == null ? void 0 : _a.length;
  const start = (_b = selectionState == null ? void 0 : selectionState.getStartOffset()) != null ? _b : 0;
  const end = (_c = selectionState == null ? void 0 : selectionState.getEndOffset()) != null ? _c : 0;
  return blockTextLength === end - start;
};
const removeCurrentBlock = (editorState, blockKey) => {
  const contentState = editorState.getCurrentContent();
  const contentBlock = contentState.getBlockForKey(blockKey);
  let targetRange = Draft.SelectionState.createEmpty(contentBlock.getKey());
  targetRange = targetRange.merge({
    anchorKey: contentBlock.getKey(),
    anchorOffset: 0,
    focusKey: contentBlock.getKey(),
    focusOffset: contentBlock.getLength()
  });
  const newContentState = Draft.Modifier.removeRange(contentState, targetRange, "backward");
  const blockMap = newContentState.getBlockMap().delete(blockKey);
  const newContentStateWithoutBlock = newContentState.merge({
    blockMap
  });
  return Draft.EditorState.push(editorState, newContentStateWithoutBlock, "remove-range");
};
const moveSelectionTo = (editorState, anchorKey, focusOffset = 0) => {
  const selectionState = Draft.SelectionState.createEmpty(anchorKey).merge({
    focusOffset
  });
  return Draft.EditorState.forceSelection(editorState, selectionState);
};
const removeDataFromEntity = (editorState, entityKey, propsArray) => {
  const entityData = editorState.getCurrentContent().getEntity(entityKey).getData();
  const newContentState = editorState.getCurrentContent().replaceEntityData(entityKey, omit(propsArray)(entityData));
  return Draft.EditorState.push(editorState, newContentState, "apply-entity");
};
const forceSelection = (editorState) => {
  var _a, _b;
  const selectionState = editorState.getSelection();
  const anchorKey = selectionState.getAnchorKey();
  const previousKey = editorState.getCurrentContent().getKeyBefore(anchorKey);
  const nextKey = editorState.getCurrentContent().getKeyAfter(anchorKey);
  const previousBlock = editorState.getCurrentContent().getBlockBefore(anchorKey);
  if (!nextKey && !previousKey) {
    const emptyEditor = resetEditor(Draft.EditorState.createEmpty());
    return Draft.EditorState.moveSelectionToEnd(emptyEditor);
  }
  let newSelectionState = Draft.SelectionState.createEmpty(previousKey || nextKey);
  newSelectionState = newSelectionState.merge({
    anchorOffset: (_a = previousBlock == null ? void 0 : previousBlock.getLength()) != null ? _a : 0,
    focusOffset: (_b = previousBlock == null ? void 0 : previousBlock.getLength()) != null ? _b : 0
  });
  return Draft.EditorState.forceSelection(removeCurrentBlock(editorState, anchorKey), newSelectionState);
};
const isImageBlock = (entity) => {
  var _a;
  const src2 = (_a = entity == null ? void 0 : entity.get("data")) == null ? void 0 : _a.src;
  return isImageDom(src2) || isImageFile(src2);
};
const isImageFile = (src2) => /\.(gif|jpe?g|tiff?|png|webp|bmp)$/i.test(src2);
const isImageDom = (src2) => /<img.*?src="(.*?)"[^\\>]+>/.test(src2);
const getImageUrl = (src2) => {
  var _a;
  const [, url] = (_a = src2 == null ? void 0 : src2.match(/src\s*=\s*"(.+?)"/)) != null ? _a : [];
  return url || src2;
};
const isVideoBlock = (entity) => {
  var _a, _b;
  return !!((_a = entity == null ? void 0 : entity.get("data")) == null ? void 0 : _a.embedlyHtml) || !!((_b = entity == null ? void 0 : entity.get("data")) == null ? void 0 : _b.html);
};
const addBlockAfter = (editorState, keyBefore, blockParams = {}) => {
  const newBlock = new Draft.ContentBlock(__spreadValues({
    key: Draft.genKey(),
    type: "unstyled",
    text: ""
  }, blockParams));
  const contentState = editorState.getCurrentContent();
  const oldBlockMap = contentState.getBlockMap();
  const newBlockMap = OrderedMap().withMutations((map2) => {
    for (let [k, v] of oldBlockMap.entries()) {
      map2.set(k, v);
      if (keyBefore === k) {
        map2.set(newBlock.getKey(), newBlock);
      }
    }
  });
  return Draft.EditorState.forceSelection(Draft.EditorState.push(editorState, Draft.ContentState.createFromBlockArray(Array.from(newBlockMap.values())).set("selectionBefore", contentState.getSelectionBefore()).set("selectionAfter", contentState.getSelectionAfter())), Draft.SelectionState.createEmpty(newBlock.getKey()));
};
const createMediaBlock = (editorState, data = {}) => {
  const contentState = editorState.getCurrentContent();
  const contentStateWithEntity = contentState.createEntity("VIDEO", "MUTABLE", data);
  const entityKey = contentStateWithEntity.getLastCreatedEntityKey();
  return Draft.AtomicBlockUtils.insertAtomicBlock(editorState, entityKey, " ");
};
const EditorStyle = createGlobalStyle`
  .public-DraftEditorPlaceholder-root {
    ${TYPOGRAPHY.fontStyles.light};
    font-size: ${pxToRem(20)};
    line-height: ${pxToRem(32)};
    color: ${COLORS.font2};
    position: absolute;
    z-index: -1;
  }

  .public-DraftEditor-content {
    font-size: ${pxToRem(20)};
    line-height: ${pxToRem(32)};
  }

  .DraftEditor-editorContainer {
    ${TYPOGRAPHY.fontStyles.light};
    color: ${COLORS.font1};
    cursor: text;
    word-break: break-word;
    letter-spacing: 0;

    .public-DraftStyleDefault-ul {
      margin-top: ${pxToRem(10)};
      margin-bottom: ${pxToRem(10)};
      list-style: disc;

      .public-DraftStyleDefault-unorderedListItem {
        margin-left: ${pxToRem(20)};
      }
    }

    .kiss-Draft__image-read, .kiss-Draft__media-read {
      margin: ${pxToRem(40)} auto;
    }
    
    .kiss-Draft__image, .kiss-Draft__media {
      margin: ${pxToRem(34)} auto;
      display: flex;
      justify-content: center;
      
      img {
        display: block;
      }
    }

    .kiss-Draft__media-focus {
      padding: ${pxToRem(2)};
      border: ${pxToRem(4)} solid ${COLORS.background1};
      cursor: pointer;
      transition: all ease-in-out 100ms;
      > iframe {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
      }
    }

    .kiss-Draft__image-focus {
      width: fit-content;
      padding: ${pxToRem(2)};
      border: ${pxToRem(4)} solid ${COLORS.background1};
      cursor: pointer;
      transition: all ease-in-out 100ms;
    }

    .kiss-Draft__image-focus:hover, .kiss-Draft__media-focus:hover {
      border-color: ${COLORS.primary4};
    }

    .kiss-Draft__image-focus__focused, .kiss-Draft__media-focus__focused {
      border-color: ${COLORS.primary1} !important;
      caret-color: transparent;
    }

    blockquote {
      font-style: italic;
      padding-left: ${pxToRem(15)};
      margin-left: ${pxToRem(50)};
      margin-top: ${pxToRem(20)};
      margin-bottom: ${pxToRem(20)};
      border-left: ${pxToRem(3)} solid ${COLORS.line1};
    }
  }

  .DraftEditor-editorContainer__disabled {
    color: ${COLORS.font2};
    cursor: not-allowed;

    a {
      color: ${COLORS.line2};
      &:hover,
      &:focus {
        color: ${COLORS.line2};
      }
    }
  }

  .DraftEditor-editorContainer__no-richText {
    font-size: ${pxToRem(14)};
  }

  .DraftEditor-editorContainer__compact {
    line-height: ${pxToRem(20)};
  }

  li.DraftEditor-editorContainer__compact,
  li.DraftEditor-editorContainer__richText {
    .public-DraftStyleDefault-block {
      margin: 0;
    }
  }

  .k-Editor__compact,
  .k-Editor__root {
    .public-DraftStyleDefault-ul {
      margin: 0;
    }
  }

  .public-DraftStyleDefault-block {
    margin: ${pxToRem(10)} auto;
  }
`;
const styleBlock = ({
  isDisabled,
  useRichTextStyle,
  compact: compact3
}) => (contentBlock) => {
  const alignmentStyle = contentBlock.getData().get("alignmentStyle");
  return classNames({
    "DraftEditor-editorContainer__disabled": isDisabled,
    "DraftEditor-editorContainer__richText": useRichTextStyle,
    "DraftEditor-editorContainer__no-richText": !useRichTextStyle,
    "DraftEditor-editorContainer__compact": compact3,
    [alignmentStyle]: alignmentStyle
  });
};
var keyCommandHandler = (onChange) => (command, editorState) => {
  const currentEntity = getEntity(editorState);
  if (command === "backspace" && isImageBlock(currentEntity) || isVideoBlock(currentEntity)) {
    onChange(forceSelection(editorState));
    return "handled";
  }
  if (command === "backspace" && isCurrentBlockAllSelected(editorState) && isPreviousBlockAnImage(editorState)) {
    onChange(forceSelection(editorState));
    return "handled";
  }
  if (command === "backspace" && isFirstBlock(editorState) && isEmptyBlock(editorState)) {
    onChange(forceSelection(editorState));
    return "handled";
  }
  const newState = Draft.RichUtils.handleKeyCommand(editorState, command);
  if (newState) {
    onChange(newState);
    return "handled";
  }
  return "not-handled";
};
var returnHandler = (onChange) => (event, editorState) => {
  const contentState = editorState.getCurrentContent();
  const currentKey = editorState.getSelection().getAnchorKey();
  const currentBlock = contentState.getBlockForKey(currentKey);
  const currentEntity = getEntity(editorState);
  if (isVideoBlock(currentEntity) || isImageBlock(currentEntity)) {
    onChange(addBlockAfter(editorState, currentKey));
    return "handled";
  }
  if (currentBlock.getText() === "" && ["unordered-list-item", "blockquote"].includes(currentBlock.getType())) {
    onChange(resetTypeOnSelectionAfter(editorState));
    return "handled";
  }
  if (["header-two", "header-three"].includes(currentBlock.getType())) {
    onChange(addBlockAfter(editorState, currentKey));
    return "handled";
  }
  return "not-handled";
};
const customBlockRenderMap = Draft.DefaultDraftBlockRenderMap.merge(Map$1({
  "header-one": {
    element: "span",
    wrapper: /* @__PURE__ */ jsx(Title$1, {
      tag: "h1",
      modifier: "secondary",
      noMargin: true,
      className: "k-u-margin-bottom-singleHalf k-u-margin-bottom-double@s-up"
    })
  },
  "header-two": {
    element: "span",
    wrapper: /* @__PURE__ */ jsx(Title$1, {
      tag: "h2",
      modifier: "tertiary",
      noMargin: true,
      className: "k-u-margin-bottom-singleHalf k-u-margin-bottom-double@l-up"
    })
  },
  "header-three": {
    element: "span",
    wrapper: /* @__PURE__ */ jsx(Title$1, {
      tag: "h3",
      modifier: "quaternary",
      noMargin: true,
      className: "k-u-margin-bottom-singleHalf"
    })
  },
  "header-four": {
    element: "span",
    wrapper: /* @__PURE__ */ jsx(Title$1, {
      tag: "h4",
      modifier: "quinary",
      noMargin: true,
      className: "k-u-margin-bottom-single k-u-margin-bottom-singleHalf@s-up"
    })
  }
}));
const Wrapper = styled.div`
  border: 0.125rem solid ${COLORS.line1};
  padding: ${pxToRem(15)};
  ${(props) => props.hasError && css`
      border-color: ${COLORS.error3};
    `};
  ${(props) => props.focused && !props.hasError && css`
      border-color: ${COLORS.line2};
    `};
  ${({
  withoutBorder
}) => withoutBorder && css`
      border: none;
      padding: 0;
    `}
  ${({
  variant
}) => variant === "orion" && css`
      border-radius: 0.25rem;
    `}
`;
const Playground = (_i) => {
  var _j = _i, {
    className,
    hasError,
    onFocus: onFocus2,
    onBlur: onBlur2,
    rawValue,
    initialValue,
    placeholder: placeholder2,
    withoutBorder,
    useRichTextStyle,
    isDisabled,
    compact: compact3,
    variant
  } = _j, props = __objRest(_j, [
    "className",
    "hasError",
    "onFocus",
    "onBlur",
    "rawValue",
    "initialValue",
    "placeholder",
    "withoutBorder",
    "useRichTextStyle",
    "isDisabled",
    "compact",
    "variant"
  ]);
  const playgroundRef = useRef(null);
  const [{
    editorState,
    focus
  }, dispatch] = useContext(EditorContext);
  const onChange = (editorState2) => dispatch(updateEditor(editorState2));
  useEffect(() => {
    props.onChange(rawValue ? Draft.convertToRaw(editorState.getCurrentContent()) : editorState.getCurrentContent());
  }, [editorState]);
  useEffect(() => {
    dispatch(updateEditorRef(playgroundRef));
  }, [playgroundRef]);
  useEffect(() => {
    onChange(resetEditor(getEditorValue(initialValue)));
  }, [initialValue]);
  return /* @__PURE__ */ jsxs(Wrapper, {
    variant,
    hasError,
    focused: focus,
    withoutBorder,
    children: [/* @__PURE__ */ jsx(EditorStyle, {}), /* @__PURE__ */ jsx(Paragraph, {
      "data-test-id": props["data-test-id"],
      tag: "section",
      modifier: "tertiary",
      noMargin: true,
      withoutBorder,
      className: classNames("k-Editor__root", {
        "k-Editor__compact": compact3
      }),
      children: /* @__PURE__ */ jsx(Draft.Editor, {
        ref: playgroundRef,
        editorState,
        placeholder: placeholder2,
        readOnly: isDisabled,
        handleKeyCommand: keyCommandHandler(onChange),
        handleReturn: returnHandler(onChange),
        onChange,
        onFocus: () => {
          dispatch(setFocus(true));
          onFocus2();
        },
        onBlur: () => {
          dispatch(setFocus(false));
          onBlur2();
        },
        blockStyleFn: styleBlock({
          isDisabled,
          useRichTextStyle,
          compact: compact3
        }),
        blockRenderMap: customBlockRenderMap
      })
    })]
  });
};
Playground.propTypes = {
  onChange: PropTypes.func,
  onFocus: PropTypes.func,
  onBlur: PropTypes.func,
  onInit: PropTypes.func,
  hasError: PropTypes.bool,
  initialValue: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
  rawValue: PropTypes.bool,
  placeholder: PropTypes.string,
  withoutBorder: PropTypes.bool,
  useRichTextStyle: PropTypes.bool,
  isDisabled: PropTypes.bool,
  compact: PropTypes.bool,
  variant: PropTypes.string
};
Playground.defaultProps = {
  onChange: () => null,
  onFocus: () => null,
  onBlur: () => null,
  hasError: false,
  initialValue: Draft.EditorState.createEmpty(),
  rawValue: true,
  placeholder: "",
  withoutBorder: false,
  useRichTextStyle: false,
  isDisabled: false,
  compact: false,
  variant: ""
};
const Toolbar = styled.div`
  display: flex;
  overflow-y: scroll;
  padding: ${pxToRem(12)} 0;
  background-color: ${COLORS.background3};

  > :last-child {
    margin-right: 0;
  }

  @media (min-width: ${pxToRem(ScreenConfig.M.min)}) {
    overflow-y: initial;
    padding: ${pxToRem(15)} 0;
  }

  &.Editor-Toolbar__whiteMode {
    background-color: ${COLORS.background1};
  }

  &.Editor-Toolbar__centered {
    justify-content: center;
  }

  ${({
  whiteMode
}) => whiteMode && css`
      background-color: ${COLORS.background1};
    `}
`;
const List = styled.ul`
  position: absolute;
  z-index: 5;
  display: flex;
  flex-direction: column;
  width: ${pxToRem(75)};
  list-style: none;
  margin: 0;
  padding: 0;
  border-bottom: ${pxToRem(2)} solid ${COLORS.line1};

  .Editor__toolbar__tagsList__Item {
    width: 100%;
    position: relative;
    padding: ${pxToRem(15)} ${pxToRem(20)};
    background-color: ${COLORS.background1};
    border: none;
    border-left: ${pxToRem(2)} solid ${COLORS.line1};
    border-right: ${pxToRem(2)} solid ${COLORS.line1};
    text-align: left;
    cursor: pointer;

    appareance: none;
    box-sizing: border-box;

    &:hover,
    &:focus {
      background-color: ${COLORS.background3};
    }

    &:focus {
      z-index: 3;
      outline: ${COLORS.primary4} solid ${pxToRem(2)};
      outline-offset: ${pxToRem(2)};
    }

    &[aria-selected='true'] {
      svg,
      path {
        fill: ${COLORS.primary1};
      }
    }
  }
`;
const StyledDetails = styled(Details)`
  summary.Editor__toolbar__tagListToggle {
    .Editor__toolbar__tagListToggle__button {
      pointer-events: none;
      width: ${pxToRem(75)};
    }

    &:focus {
      z-index: 3;
      outline: ${COLORS.primary4} solid ${pxToRem(2)};
      outline-offset: ${pxToRem(2)};

      .Editor__toolbar__tagListToggle__button {
        border-color: ${COLORS.primary4};
        background-color: ${COLORS.background1};
        color: ${COLORS.primary1};

        svg,
        path {
          fill: ${COLORS.primary1};
        }
      }
    }
  }

  ${({
  disabled
}) => disabled && css`
      pointer-events: none;
      cursor: not-allowed;
    `}
`;
const componentByTagType = (tagType) => {
  switch (tagType) {
    case "header-one":
      return /* @__PURE__ */ jsx(Title1Icon, {});
    case "header-two":
      return /* @__PURE__ */ jsx(Title2Icon, {});
    case "header-three":
      return /* @__PURE__ */ jsx(Title3Icon, {});
    case "header-four":
      return /* @__PURE__ */ jsx(Title4Icon, {});
    case "unstyled":
    default:
      return /* @__PURE__ */ jsx(ParagraphIcon, {});
  }
};
const TagsList = ({
  disabled,
  onChange,
  tags
}) => {
  const [{
    editorState,
    disabled: contextDisabled
  }, dispatch] = useContext(EditorContext);
  const currentContent = editorState.getCurrentContent();
  const selection = editorState.getSelection();
  const currentBlockType = currentContent.getBlockForKey(selection.getStartKey()).getType();
  useEffect(() => {
    onChange(currentBlockType);
  }, [currentBlockType]);
  const handleClick = (type) => () => {
    dispatch(updateEditor(Draft.RichUtils.toggleBlockType(editorState, type)));
  };
  return /* @__PURE__ */ jsx(StyledDetails, {
    summaryRender: ({
      open
    }) => /* @__PURE__ */ jsxs(StyledButton, {
      className: "Editor__toolbar__tagListToggle__button",
      tabIndex: "-1",
      disabled: contextDisabled || disabled,
      children: [componentByTagType(currentBlockType), /* @__PURE__ */ jsx(ArrowIcon, {
        width: "6",
        direction: open ? "top" : "bottom"
      })]
    }),
    summaryProps: {
      className: "Editor__toolbar__tagListToggle"
    },
    disabled: contextDisabled || disabled,
    children: /* @__PURE__ */ jsx(List, {
      children: tags.map((tag) => {
        const component = componentByTagType(tag);
        if (!component)
          return;
        return /* @__PURE__ */ jsx("li", {
          children: /* @__PURE__ */ jsx("button", {
            onClick: handleClick(tag),
            type: "button",
            "aria-selected": tag === currentBlockType,
            className: "Editor__toolbar__tagsList__Item",
            children: component
          })
        }, tag);
      })
    })
  }, currentContent);
};
TagsList.propTypes = {
  tags: PropTypes.array,
  disabled: PropTypes.bool,
  onChange: PropTypes.func
};
TagsList.defaultProps = {
  tags: ["header-one", "header-two", "header-three", "header-four", "unstyled"],
  disabled: false,
  onChange: () => null
};
const Actions = styled.div`
  display: flex;

  > * {
    margin-left: -${pxToRem(2)};
  }

  :first-child > :first-child {
    margin-left: 0;
  }

  @media (min-width: ${pxToRem(ScreenConfig.S.min)}) {
    margin-right: ${pxToRem(20)};

    > :not(:first-child) {
      margin-left: -${pxToRem(2)};
    }
  }

  > :hover:not(:disabled),
  > :focus:not(:disabled) {
    z-index: 1;
  }

  .Editor__toolbar__button--isSelected {
    z-index: 2;
  }
`;
const Quote = ({
  disabled,
  onChange
}) => {
  const [{
    editorState,
    disabled: contextDisabled
  }, dispatch] = useContext(EditorContext);
  const currentContent = editorState.getCurrentContent();
  const selection = editorState.getSelection();
  const currentBlockType = currentContent.getBlockForKey(selection.getStartKey()).get("type");
  const active = currentBlockType === "blockquote";
  return /* @__PURE__ */ jsx(Button, {
    icon: "quote",
    active,
    disabled: contextDisabled || disabled,
    onToggle: () => {
      onChange();
      dispatch(updateEditor(Draft.RichUtils.toggleBlockType(editorState, "blockquote")));
    }
  });
};
Quote.propTypes = {
  disabled: PropTypes.bool,
  onChange: PropTypes.func
};
Quote.defaultProps = {
  disabled: false,
  onChange: () => null
};
const UnorderedList = ({
  disabled,
  onChange
}) => {
  const [{
    editorState,
    disabled: contextDisabled
  }, dispatch] = useContext(EditorContext);
  const currentContent = editorState.getCurrentContent();
  const selection = editorState.getSelection();
  const currentBlockType = currentContent.getBlockForKey(selection.getStartKey()).get("type");
  return /* @__PURE__ */ jsx(Button, {
    active: currentBlockType === "unordered-list-item",
    icon: "format_list_bulleted",
    onToggle: (blockType) => {
      onChange();
      dispatch(updateEditor(Draft.RichUtils.toggleBlockType(editorState, blockType)));
    },
    style: "unordered-list-item",
    disabled: disabled || contextDisabled
  }, "format_list_bulleted");
};
UnorderedList.propTypes = {
  disabled: PropTypes.bool,
  onChange: PropTypes.func
};
UnorderedList.defaultProps = {
  disabled: false,
  onChange: () => null
};
const Bold = ({
  disabled,
  onChange
}) => {
  const [{
    editorState,
    disabled: contextDisabled
  }, dispatch] = useContext(EditorContext);
  const currentStyle = editorState.getCurrentInlineStyle();
  return /* @__PURE__ */ jsx(Button, {
    active: currentStyle.has("BOLD"),
    icon: "format_bold",
    onToggle: (style) => {
      onChange();
      dispatch(updateEditor(Draft.RichUtils.toggleInlineStyle(editorState, style)));
    },
    style: "BOLD",
    disabled: contextDisabled || disabled
  }, "format_bold");
};
Bold.propTypes = {
  disabled: PropTypes.bool,
  onChange: PropTypes.func
};
Bold.defaultProps = {
  disabled: false,
  onChange: () => null
};
const Italic = ({
  disabled,
  onChange
}) => {
  const [{
    editorState,
    disabled: contextDisabled
  }, dispatch] = useContext(EditorContext);
  const currentStyle = editorState.getCurrentInlineStyle();
  return /* @__PURE__ */ jsx(Button, {
    active: currentStyle.has("ITALIC"),
    icon: "format_italic",
    onToggle: (style) => {
      onChange();
      dispatch(updateEditor(Draft.RichUtils.toggleInlineStyle(editorState, style)));
    },
    style: "ITALIC",
    disabled: contextDisabled || disabled
  }, "format_italic");
};
Italic.propTypes = {
  disabled: PropTypes.bool,
  onChange: PropTypes.func
};
Italic.defaultProps = {
  disabled: false,
  onChange: () => null
};
const Generic = ({
  disabled,
  label,
  onChange
}) => {
  var _a;
  const [{
    editorState,
    disabled: contextDisabled
  }, dispatch] = useContext(EditorContext);
  const currentAlignmentStyle = (_a = getCurrentAlignmentStyle(editorState)) != null ? _a : "k-u-align-left";
  return /* @__PURE__ */ jsx(Button, {
    icon: label,
    disabled: contextDisabled || disabled,
    active: currentAlignmentStyle === label,
    onToggle: () => {
      onChange();
      const currentContent = editorState.getCurrentContent();
      const selection = editorState.getSelection();
      dispatch(updateEditor(Draft.EditorState.push(editorState, Draft.Modifier.setBlockData(currentContent, selection, Map$1({
        alignmentStyle: label
      })), "change-inline-style")));
    }
  }, label);
};
Generic.propTypes = {
  label: PropTypes.string.isRequired,
  disabled: PropTypes.bool,
  onChange: PropTypes.func
};
Generic.defaultProps = {
  disabled: false,
  onChange: () => null
};
const Left = (props) => {
  return /* @__PURE__ */ jsx(Generic, __spreadValues({
    label: "k-u-align-left"
  }, props));
};
Left.propTypes = {
  disabled: PropTypes.bool,
  onChange: PropTypes.func
};
Left.defaultProps = {
  disabled: false,
  onChange: () => null
};
const Right = (props) => {
  return /* @__PURE__ */ jsx(Generic, __spreadValues({
    label: "k-u-align-right"
  }, props));
};
Right.propTypes = {
  disabled: PropTypes.bool,
  onChange: PropTypes.func
};
Right.defaultProps = {
  disabled: false,
  onChange: () => null
};
const Center = (props) => {
  return /* @__PURE__ */ jsx(Generic, __spreadValues({
    label: "k-u-align-center"
  }, props));
};
Center.propTypes = {
  disabled: PropTypes.bool,
  onChange: PropTypes.func
};
Center.defaultProps = {
  disabled: false,
  onChange: () => null
};
const Controls = ({
  whiteMode,
  disabled,
  className,
  centered,
  children
}) => {
  const [, dispatch] = useContext(EditorContext);
  useEffect(() => {
    dispatch(updateState({
      disabled
    }));
  }, [disabled]);
  return /* @__PURE__ */ jsx(Toolbar, {
    className: classNames(className, {
      "Editor-Toolbar__whiteMode": whiteMode,
      "Editor-Toolbar__centered": centered
    }),
    children
  });
};
Controls.Image = ImageControls;
Controls.TagList = TagsList;
Controls.Bold = Bold;
Controls.Italic = Italic;
Controls.Quote = Quote;
Controls.Left = Left;
Controls.Right = Right;
Controls.Center = Center;
Controls.UnorderedList = UnorderedList;
Controls.Link = LinkControls;
Controls.Button = ButtonLinkControls;
Controls.Video = VideoControls;
Controls.Group = Actions;
Controls.propTypes = {
  disabled: PropTypes.bool,
  whiteMode: PropTypes.bool,
  centered: PropTypes.bool,
  className: PropTypes.string
};
Controls.defaultProps = {
  disabled: false,
  whiteMode: false,
  centered: false
};
const getinitialValue = (value) => {
  if (!domElementHelper.canUseDom())
    return null;
  if (!value) {
    return Draft.EditorState.createEmpty();
  }
  try {
    return Draft.EditorState.createWithContent(Draft.convertFromRaw(JSON.parse(value)), new Draft.CompositeDecorator([readDecorator$2, readDecorator$3, readDecorator$1, readDecorator, linkify$1]));
  } catch (e) {
    const blocksFromHTML = Draft.convertFromHTML(`<p>${value}</p>`);
    const contentState = Draft.ContentState.createFromBlockArray(blocksFromHTML);
    return Draft.EditorState.createWithContent(contentState);
  }
};
const isJSONContent = (content) => {
  try {
    JSON.parse(content);
    return true;
  } catch (e) {
    return false;
  }
};
const renderRaw = (text) => {
  try {
    const value = JSON.parse(text);
    const render = value.blocks.reduce((acc, value2) => `${acc} ${value2.text}`, "");
    return /* @__PURE__ */ jsx("div", {
      children: render
    });
  } catch (e) {
    return /* @__PURE__ */ jsx("div", {
      children: text
    });
  }
};
const DraftDisplayer = ({
  text,
  useRichTextStyle,
  perfEnabled,
  isDisabled,
  compact: compact3,
  configResponsiveImageHandler
}) => {
  if (!domElementHelper.canUseDom())
    return renderRaw(text);
  return isJSONContent(text) ? /* @__PURE__ */ jsxs(EditorProvider, {
    configResponsiveImageHandler,
    children: [/* @__PURE__ */ jsx(EditorStyle, {}), /* @__PURE__ */ jsx("section", {
      className: classNames("k-Editor__root", {
        "k-Editor__compact": compact3
      }),
      children: /* @__PURE__ */ jsx(Draft.Editor, {
        onChange: () => null,
        editorState: getinitialValue(text),
        blockStyleFn: styleBlock({
          isDisabled,
          useRichTextStyle,
          compact: compact3
        }),
        blockRenderMap: customBlockRenderMap,
        readOnly: true
      })
    })]
  }) : /* @__PURE__ */ jsx(EditorProvider, {
    configResponsiveImageHandler,
    children: /* @__PURE__ */ jsx(HtmlEditor, {
      html: text,
      perfEnabled,
      useRichTextStyle
    })
  });
};
DraftDisplayer.propTypes = {
  text: PropTypes.oneOfType([PropTypes.object, PropTypes.string]).isRequired,
  useRichTextStyle: PropTypes.bool,
  isDisabled: PropTypes.bool,
  perfEnabled: PropTypes.bool,
  compact: PropTypes.bool
};
DraftDisplayer.defaultProps = {
  useRichTextStyle: false,
  isDisabled: false,
  perfEnabled: false,
  compact: false
};
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
    return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
}
function ownKeys$1(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    keys3.push.apply(keys3, Object.getOwnPropertySymbols(object));
  }
  if (enumerableOnly)
    keys3 = keys3.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
  return keys3;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$1(source, true).forEach(function(key) {
        _defineProperty$1(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(source).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray$1(arr, i) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit$1(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr))
    return arr;
}
function combineOrderedStyles(customMap, defaults2) {
  if (customMap == null) {
    return defaults2;
  }
  var _defaults = _slicedToArray$1(defaults2, 2), defaultStyleMap = _defaults[0], defaultStyleOrder = _defaults[1];
  var styleMap = _objectSpread$1({}, defaultStyleMap);
  var styleOrder = _toConsumableArray(defaultStyleOrder);
  for (var _i2 = 0, _Object$keys = Object.keys(customMap); _i2 < _Object$keys.length; _i2++) {
    var _styleName = _Object$keys[_i2];
    if (defaultStyleMap.hasOwnProperty(_styleName)) {
      var defaultStyles = defaultStyleMap[_styleName];
      styleMap[_styleName] = _objectSpread$1({}, defaultStyles, {}, customMap[_styleName]);
    } else {
      styleMap[_styleName] = customMap[_styleName];
      styleOrder.push(_styleName);
    }
  }
  return [styleMap, styleOrder];
}
var ATTR_NAME_MAP = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
};
function normalizeAttributes(attributes) {
  if (attributes == null) {
    return attributes;
  }
  var normalized = {};
  var didNormalize = false;
  for (var _i = 0, _Object$keys = Object.keys(attributes); _i < _Object$keys.length; _i++) {
    var name = _Object$keys[_i];
    var newName = name;
    if (ATTR_NAME_MAP.hasOwnProperty(name)) {
      newName = ATTR_NAME_MAP[name];
      didNormalize = true;
    }
    normalized[newName] = attributes[name];
  }
  return didNormalize ? normalized : attributes;
}
var VENDOR_PREFIX = /^(moz|ms|o|webkit)-/;
var NUMERIC_STRING = /^\d+$/;
var UPPERCASE_PATTERN = /([A-Z])/g;
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
function processStyleName(name) {
  return name.replace(UPPERCASE_PATTERN, "-$1").toLowerCase().replace(VENDOR_PREFIX, "-$1-");
}
function processStyleValue(name, value) {
  var isNumeric;
  if (typeof value === "string") {
    isNumeric = NUMERIC_STRING.test(value);
  } else {
    isNumeric = true;
    value = String(value);
  }
  if (!isNumeric || value === "0" || isUnitlessNumber[name] === true) {
    return value;
  } else {
    return value + "px";
  }
}
function styleToCSS(styleDescr) {
  return Object.keys(styleDescr).map(function(name) {
    var styleValue = processStyleValue(name, styleDescr[name]);
    var styleName = processStyleName(name);
    return "".concat(styleName, ": ").concat(styleValue);
  }).join("; ");
}
var BLOCK_TYPE = {
  UNSTYLED: "unstyled",
  HEADER_ONE: "header-one",
  HEADER_TWO: "header-two",
  HEADER_THREE: "header-three",
  HEADER_FOUR: "header-four",
  HEADER_FIVE: "header-five",
  HEADER_SIX: "header-six",
  UNORDERED_LIST_ITEM: "unordered-list-item",
  ORDERED_LIST_ITEM: "ordered-list-item",
  BLOCKQUOTE: "blockquote",
  PULLQUOTE: "pullquote",
  CODE: "code-block",
  ATOMIC: "atomic"
};
var ENTITY_TYPE = {
  LINK: "LINK",
  IMAGE: "IMAGE",
  EMBED: "embed"
};
var INLINE_STYLE = {
  BOLD: "BOLD",
  CODE: "CODE",
  ITALIC: "ITALIC",
  STRIKETHROUGH: "STRIKETHROUGH",
  UNDERLINE: "UNDERLINE"
};
var EMPTY_SET = new OrderedSet();
function getEntityRanges(text, charMetaList) {
  var charEntity = null;
  var prevCharEntity = null;
  var ranges = [];
  var rangeStart = 0;
  for (var i = 0, len = text.length; i < len; i++) {
    prevCharEntity = charEntity;
    var meta = charMetaList.get(i);
    charEntity = meta ? meta.getEntity() : null;
    if (i > 0 && charEntity !== prevCharEntity) {
      ranges.push([prevCharEntity, getStyleRanges(text.slice(rangeStart, i), charMetaList.slice(rangeStart, i))]);
      rangeStart = i;
    }
  }
  ranges.push([charEntity, getStyleRanges(text.slice(rangeStart), charMetaList.slice(rangeStart))]);
  return ranges;
}
function getStyleRanges(text, charMetaList) {
  var charStyle = EMPTY_SET;
  var prevCharStyle = EMPTY_SET;
  var ranges = [];
  var rangeStart = 0;
  for (var i = 0, len = text.length; i < len; i++) {
    prevCharStyle = charStyle;
    var meta = charMetaList.get(i);
    charStyle = meta ? meta.getStyle() : EMPTY_SET;
    if (i > 0 && !is(charStyle, prevCharStyle)) {
      ranges.push([text.slice(rangeStart, i), prevCharStyle]);
      rangeStart = i;
    }
  }
  ranges.push([text.slice(rangeStart), charStyle]);
  return ranges;
}
var _DEFAULT_STYLE_MAP, _ENTITY_ATTR_MAP, _DATA_TO_ATTR;
function ownKeys(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    keys3.push.apply(keys3, Object.getOwnPropertySymbols(object));
  }
  if (enumerableOnly)
    keys3 = keys3.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
  return keys3;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(source, true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var BOLD = INLINE_STYLE.BOLD, CODE = INLINE_STYLE.CODE, ITALIC = INLINE_STYLE.ITALIC, STRIKETHROUGH = INLINE_STYLE.STRIKETHROUGH, UNDERLINE = INLINE_STYLE.UNDERLINE;
var INDENT = "  ";
var BREAK = "<br>";
var DATA_ATTRIBUTE = /^data-([a-z0-9-]+)$/;
var DEFAULT_STYLE_MAP = (_DEFAULT_STYLE_MAP = {}, _defineProperty(_DEFAULT_STYLE_MAP, BOLD, {
  element: "strong"
}), _defineProperty(_DEFAULT_STYLE_MAP, CODE, {
  element: "code"
}), _defineProperty(_DEFAULT_STYLE_MAP, ITALIC, {
  element: "em"
}), _defineProperty(_DEFAULT_STYLE_MAP, STRIKETHROUGH, {
  element: "del"
}), _defineProperty(_DEFAULT_STYLE_MAP, UNDERLINE, {
  element: "u"
}), _DEFAULT_STYLE_MAP);
var DEFAULT_STYLE_ORDER = [BOLD, ITALIC, UNDERLINE, STRIKETHROUGH, CODE];
var ENTITY_ATTR_MAP = (_ENTITY_ATTR_MAP = {}, _defineProperty(_ENTITY_ATTR_MAP, ENTITY_TYPE.LINK, {
  url: "href",
  href: "href",
  rel: "rel",
  target: "target",
  title: "title",
  className: "class"
}), _defineProperty(_ENTITY_ATTR_MAP, ENTITY_TYPE.IMAGE, {
  src: "src",
  height: "height",
  width: "width",
  alt: "alt",
  className: "class"
}), _ENTITY_ATTR_MAP);
var DATA_TO_ATTR = (_DATA_TO_ATTR = {}, _defineProperty(_DATA_TO_ATTR, ENTITY_TYPE.LINK, function(entityType, entity) {
  var attrMap = ENTITY_ATTR_MAP.hasOwnProperty(entityType) ? ENTITY_ATTR_MAP[entityType] : {};
  var data = entity.getData();
  var attrs = {};
  for (var _i = 0, _Object$keys = Object.keys(data); _i < _Object$keys.length; _i++) {
    var dataKey = _Object$keys[_i];
    var dataValue = data[dataKey];
    if (attrMap.hasOwnProperty(dataKey)) {
      var attrKey = attrMap[dataKey];
      attrs[attrKey] = dataValue;
    } else if (DATA_ATTRIBUTE.test(dataKey)) {
      attrs[dataKey] = dataValue;
    }
  }
  return attrs;
}), _defineProperty(_DATA_TO_ATTR, ENTITY_TYPE.IMAGE, function(entityType, entity) {
  var attrMap = ENTITY_ATTR_MAP.hasOwnProperty(entityType) ? ENTITY_ATTR_MAP[entityType] : {};
  var data = entity.getData();
  var attrs = {};
  for (var _i2 = 0, _Object$keys2 = Object.keys(data); _i2 < _Object$keys2.length; _i2++) {
    var dataKey = _Object$keys2[_i2];
    var dataValue = data[dataKey];
    if (attrMap.hasOwnProperty(dataKey)) {
      var attrKey = attrMap[dataKey];
      attrs[attrKey] = dataValue;
    } else if (DATA_ATTRIBUTE.test(dataKey)) {
      attrs[dataKey] = dataValue;
    }
  }
  return attrs;
}), _DATA_TO_ATTR);
function getTags(blockType, defaultBlockTag) {
  switch (blockType) {
    case BLOCK_TYPE.HEADER_ONE:
      return ["h1"];
    case BLOCK_TYPE.HEADER_TWO:
      return ["h2"];
    case BLOCK_TYPE.HEADER_THREE:
      return ["h3"];
    case BLOCK_TYPE.HEADER_FOUR:
      return ["h4"];
    case BLOCK_TYPE.HEADER_FIVE:
      return ["h5"];
    case BLOCK_TYPE.HEADER_SIX:
      return ["h6"];
    case BLOCK_TYPE.UNORDERED_LIST_ITEM:
    case BLOCK_TYPE.ORDERED_LIST_ITEM:
      return ["li"];
    case BLOCK_TYPE.BLOCKQUOTE:
      return ["blockquote"];
    case BLOCK_TYPE.CODE:
      return ["pre", "code"];
    case BLOCK_TYPE.ATOMIC:
      return ["figure"];
    default:
      if (defaultBlockTag === null) {
        return [];
      }
      return [defaultBlockTag || "p"];
  }
}
function getWrapperTag(blockType) {
  switch (blockType) {
    case BLOCK_TYPE.UNORDERED_LIST_ITEM:
      return "ul";
    case BLOCK_TYPE.ORDERED_LIST_ITEM:
      return "ol";
    default:
      return null;
  }
}
var MarkupGenerator = /* @__PURE__ */ function() {
  function MarkupGenerator2(contentState, options) {
    _classCallCheck(this, MarkupGenerator2);
    _defineProperty(this, "blocks", void 0);
    _defineProperty(this, "contentState", void 0);
    _defineProperty(this, "currentBlock", void 0);
    _defineProperty(this, "indentLevel", void 0);
    _defineProperty(this, "output", void 0);
    _defineProperty(this, "totalBlocks", void 0);
    _defineProperty(this, "wrapperTag", void 0);
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "inlineStyles", void 0);
    _defineProperty(this, "inlineStyleFn", void 0);
    _defineProperty(this, "styleOrder", void 0);
    if (options == null) {
      options = {};
    }
    this.contentState = contentState;
    this.options = options;
    var _combineOrderedStyles = combineOrderedStyles(options.inlineStyles, [DEFAULT_STYLE_MAP, DEFAULT_STYLE_ORDER]), _combineOrderedStyles2 = _slicedToArray(_combineOrderedStyles, 2), inlineStyles = _combineOrderedStyles2[0], styleOrder = _combineOrderedStyles2[1];
    this.inlineStyles = inlineStyles;
    this.inlineStyleFn = options.inlineStyleFn;
    this.styleOrder = styleOrder;
  }
  _createClass(MarkupGenerator2, [{
    key: "generate",
    value: function generate2() {
      this.output = [];
      this.blocks = this.contentState.getBlocksAsArray();
      this.totalBlocks = this.blocks.length;
      this.currentBlock = 0;
      this.indentLevel = 0;
      this.wrapperTag = null;
      while (this.currentBlock < this.totalBlocks) {
        this.processBlock();
      }
      this.closeWrapperTag();
      return this.output.join("").trim();
    }
  }, {
    key: "processBlock",
    value: function processBlock() {
      var _this$options = this.options, blockRenderers = _this$options.blockRenderers, defaultBlockTag = _this$options.defaultBlockTag;
      var block = this.blocks[this.currentBlock];
      var blockType = block.getType();
      var newWrapperTag = getWrapperTag(blockType);
      if (this.wrapperTag !== newWrapperTag) {
        if (this.wrapperTag) {
          this.closeWrapperTag();
        }
        if (newWrapperTag) {
          this.openWrapperTag(newWrapperTag);
        }
      }
      this.indent();
      var customRenderer = blockRenderers != null && blockRenderers.hasOwnProperty(blockType) ? blockRenderers[blockType] : null;
      var customRendererOutput = customRenderer ? customRenderer(block) : null;
      if (customRendererOutput != null) {
        this.output.push(customRendererOutput);
        this.output.push("\n");
        this.currentBlock += 1;
        return;
      }
      this.writeStartTag(block, defaultBlockTag);
      this.output.push(this.renderBlockContent(block));
      var nextBlock = this.getNextBlock();
      if (canHaveDepth(blockType) && nextBlock && nextBlock.getDepth() === block.getDepth() + 1) {
        this.output.push("\n");
        var thisWrapperTag = this.wrapperTag;
        this.wrapperTag = null;
        this.indentLevel += 1;
        this.currentBlock += 1;
        this.processBlocksAtDepth(nextBlock.getDepth());
        this.wrapperTag = thisWrapperTag;
        this.indentLevel -= 1;
        this.indent();
      } else {
        this.currentBlock += 1;
      }
      this.writeEndTag(block, defaultBlockTag);
    }
  }, {
    key: "processBlocksAtDepth",
    value: function processBlocksAtDepth(depth) {
      var block = this.blocks[this.currentBlock];
      while (block && block.getDepth() === depth) {
        this.processBlock();
        block = this.blocks[this.currentBlock];
      }
      this.closeWrapperTag();
    }
  }, {
    key: "getNextBlock",
    value: function getNextBlock() {
      return this.blocks[this.currentBlock + 1];
    }
  }, {
    key: "writeStartTag",
    value: function writeStartTag(block, defaultBlockTag) {
      var tags = getTags(block.getType(), defaultBlockTag);
      var attrString;
      if (this.options.blockStyleFn) {
        var _ref = this.options.blockStyleFn(block) || {}, attributes = _ref.attributes, _style = _ref.style;
        attributes = normalizeAttributes(attributes);
        if (_style != null) {
          var styleAttr = styleToCSS(_style);
          attributes = attributes == null ? {
            style: styleAttr
          } : _objectSpread({}, attributes, {
            style: styleAttr
          });
        }
        attrString = stringifyAttrs(attributes);
      } else {
        attrString = "";
      }
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = tags[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var tag = _step.value;
          this.output.push("<".concat(tag).concat(attrString, ">"));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "writeEndTag",
    value: function writeEndTag(block, defaultBlockTag) {
      var tags = getTags(block.getType(), defaultBlockTag);
      if (tags.length === 1) {
        this.output.push("</".concat(tags[0], ">\n"));
      } else {
        var output = [];
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = void 0;
        try {
          for (var _iterator2 = tags[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var tag = _step2.value;
            output.unshift("</".concat(tag, ">"));
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        this.output.push(output.join("") + "\n");
      }
    }
  }, {
    key: "openWrapperTag",
    value: function openWrapperTag(wrapperTag) {
      this.wrapperTag = wrapperTag;
      this.indent();
      this.output.push("<".concat(wrapperTag, ">\n"));
      this.indentLevel += 1;
    }
  }, {
    key: "closeWrapperTag",
    value: function closeWrapperTag() {
      var wrapperTag = this.wrapperTag;
      if (wrapperTag) {
        this.indentLevel -= 1;
        this.indent();
        this.output.push("</".concat(wrapperTag, ">\n"));
        this.wrapperTag = null;
      }
    }
  }, {
    key: "indent",
    value: function indent() {
      this.output.push(INDENT.repeat(this.indentLevel));
    }
  }, {
    key: "withCustomInlineStyles",
    value: function withCustomInlineStyles(content, styleSet) {
      if (!this.inlineStyleFn) {
        return content;
      }
      var renderConfig = this.inlineStyleFn(styleSet);
      if (!renderConfig) {
        return content;
      }
      var _renderConfig$element = renderConfig.element, element = _renderConfig$element === void 0 ? "span" : _renderConfig$element, attributes = renderConfig.attributes, style = renderConfig.style;
      var attrString = stringifyAttrs(_objectSpread({}, attributes, {
        style: style && styleToCSS(style)
      }));
      return "<".concat(element).concat(attrString, ">").concat(content, "</").concat(element, ">");
    }
  }, {
    key: "renderBlockContent",
    value: function renderBlockContent(block) {
      var _this = this;
      var blockType = block.getType();
      var text = block.getText();
      if (text === "") {
        return BREAK;
      }
      text = this.preserveWhitespace(text);
      var charMetaList = block.getCharacterList();
      var entityPieces = getEntityRanges(text, charMetaList);
      return entityPieces.map(function(_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2), entityKey = _ref3[0], stylePieces = _ref3[1];
        var content = stylePieces.map(function(_ref4) {
          var _ref5 = _slicedToArray(_ref4, 2), text2 = _ref5[0], styleSet = _ref5[1];
          var content2 = encodeContent(text2);
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = _this.styleOrder[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _styleName = _step3.value;
              if (_styleName === CODE && blockType === BLOCK_TYPE.CODE) {
                continue;
              }
              if (styleSet.has(_styleName)) {
                var _this$inlineStyles$_s = _this.inlineStyles[_styleName], element2 = _this$inlineStyles$_s.element, attributes2 = _this$inlineStyles$_s.attributes, _style2 = _this$inlineStyles$_s.style;
                if (element2 == null) {
                  element2 = "span";
                }
                attributes2 = normalizeAttributes(attributes2);
                if (_style2 != null) {
                  var styleAttr2 = styleToCSS(_style2);
                  attributes2 = attributes2 == null ? {
                    style: styleAttr2
                  } : _objectSpread({}, attributes2, {
                    style: styleAttr2
                  });
                }
                var attrString2 = stringifyAttrs(attributes2);
                content2 = "<".concat(element2).concat(attrString2, ">").concat(content2, "</").concat(element2, ">");
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          return _this.withCustomInlineStyles(content2, styleSet);
        }).join("");
        var entity = entityKey ? _this.contentState.getEntity(entityKey) : null;
        var entityType = entity == null ? null : entity.getType().toUpperCase();
        var entityStyle;
        if (entity != null && _this.options.entityStyleFn && (entityStyle = _this.options.entityStyleFn(entity))) {
          var _entityStyle = entityStyle, element = _entityStyle.element, attributes = _entityStyle.attributes, _style3 = _entityStyle.style;
          if (element == null) {
            element = "span";
          }
          attributes = normalizeAttributes(attributes);
          if (_style3 != null) {
            var styleAttr = styleToCSS(_style3);
            attributes = attributes == null ? {
              style: styleAttr
            } : _objectSpread({}, attributes, {
              style: styleAttr
            });
          }
          var attrString = stringifyAttrs(attributes);
          return "<".concat(element).concat(attrString, ">").concat(content, "</").concat(element, ">");
        } else if (entityType != null && entityType === ENTITY_TYPE.LINK) {
          var attrs = DATA_TO_ATTR.hasOwnProperty(entityType) ? DATA_TO_ATTR[entityType](entityType, entity) : null;
          var _attrString = stringifyAttrs(attrs);
          return "<a".concat(_attrString, ">").concat(content, "</a>");
        } else if (entityType != null && entityType === ENTITY_TYPE.IMAGE) {
          var _attrs = DATA_TO_ATTR.hasOwnProperty(entityType) ? DATA_TO_ATTR[entityType](entityType, entity) : null;
          var _attrString2 = stringifyAttrs(_attrs);
          return "<img".concat(_attrString2, "/>");
        } else {
          return content;
        }
      }).join("");
    }
  }, {
    key: "preserveWhitespace",
    value: function preserveWhitespace(text) {
      var length = text.length;
      var newText = new Array(length);
      for (var i = 0; i < length; i++) {
        if (text[i] === " " && (i === 0 || i === length - 1 || text[i - 1] === " ")) {
          newText[i] = "\xA0";
        } else {
          newText[i] = text[i];
        }
      }
      return newText.join("");
    }
  }]);
  return MarkupGenerator2;
}();
function stringifyAttrs(attrs) {
  if (attrs == null) {
    return "";
  }
  var parts = [];
  for (var _i3 = 0, _Object$keys3 = Object.keys(attrs); _i3 < _Object$keys3.length; _i3++) {
    var name = _Object$keys3[_i3];
    var value = attrs[name];
    if (value != null) {
      parts.push(" ".concat(name, '="').concat(encodeAttr(value + ""), '"'));
    }
  }
  return parts.join("");
}
function canHaveDepth(blockType) {
  switch (blockType) {
    case BLOCK_TYPE.UNORDERED_LIST_ITEM:
    case BLOCK_TYPE.ORDERED_LIST_ITEM:
      return true;
    default:
      return false;
  }
}
function encodeContent(text) {
  return text.split("&").join("&amp;").split("<").join("&lt;").split(">").join("&gt;").split("\xA0").join("&nbsp;").split("\n").join(BREAK + "\n");
}
function encodeAttr(text) {
  return text.split("&").join("&amp;").split("<").join("&lt;").split(">").join("&gt;").split('"').join("&quot;");
}
function stateToHTML(content, options) {
  return new MarkupGenerator(content, options).generate();
}
const TitleStyle = createGlobalStyle`
  .DraftEditor-wrapper {
      .public-DraftEditorPlaceholder-root {
        ${TYPOGRAPHY.fontStyles.bold};
        font-size: ${pxToRem(28)};
        @media (min-width: ${pxToRem(ScreenConfig.M.min)}) {
          font-size: ${pxToRem(36)};
        }
        @media (min-width: ${pxToRem(ScreenConfig.L.min)}) {
          font-size: ${pxToRem(48)};
        }
      }
  }
  .DraftEditor-editorContainer__title {
    ${TYPOGRAPHY.fontStyles.bold};
    font-size: ${pxToRem(28)};
    @media (min-width: ${pxToRem(ScreenConfig.M.min)}) {
      font-size: ${pxToRem(36)};
    }
    @media (min-width: ${pxToRem(ScreenConfig.L.min)}) {
      font-size: ${pxToRem(48)};
    }
  }
`;
const Title = ({
  onFocus: onFocus2,
  onBlur: onBlur2,
  onChange,
  initialValue,
  placeholder: placeholder2
}) => {
  const [editorState, updateEditorState] = useState(Draft.EditorState.createEmpty());
  useEffect(() => {
    updateEditorState(createContent(initialValue));
  }, [initialValue]);
  return /* @__PURE__ */ jsxs("div", {
    className: "DraftEditor-wrapper",
    children: [/* @__PURE__ */ jsx(TitleStyle, {}), /* @__PURE__ */ jsx(Draft.Editor, {
      editorState,
      onChange: (newsEditorState) => {
        updateEditorState(newsEditorState);
        onChange(stateToHTML(newsEditorState.getCurrentContent(), {
          defaultBlockTag: "span",
          blockStyleFn: () => {
            return {
              style: {
                display: "block"
              }
            };
          }
        }));
      },
      onFocus: onFocus2,
      onBlur: onBlur2,
      placeholder: placeholder2,
      blockStyleFn: () => {
        return "DraftEditor-editorContainer__title";
      }
    })]
  });
};
Title.propTypes = {
  initialValue: PropTypes.string,
  placeholder: PropTypes.string,
  onFocus: PropTypes.func,
  onBlur: PropTypes.func,
  onChange: PropTypes.func
};
Title.defaultProps = {
  initalValue: "",
  placeholder: "",
  onFocus: () => null,
  onBlur: () => null,
  onChange: () => null
};
const defaultTranslations = {
  button_link: {
    title: "",
    text: "",
    url: ""
  },
  link: {
    text: {
      label: ""
    },
    title: "",
    error: "",
    button: {
      delete: ""
    }
  },
  controls: {
    format_bold: "",
    activated_format_bold: "",
    format_italic: "",
    activated_format_italic: "",
    format_list_bulleted: "",
    activated_format_list_bulleted: "",
    ["k-u-align-left"]: "",
    ["activated_k-u-align-left"]: "",
    ["k-u-align-center"]: "",
    ["activated_k-u-align-center"]: "",
    ["k-u-align-right"]: "",
    ["activated_k-u-align-right"]: "",
    image: "",
    activated_image: "",
    video: "",
    activated_video: "",
    link: "",
    activated_link: "",
    quote: "",
    activated_quote: ""
  },
  image_upload: {
    title: "",
    label: "",
    url: "",
    preview: "",
    upload: "",
    help_file: {
      formats: "",
      width: "",
      size: ""
    }
  },
  image: {
    invalid_url: "",
    invalid_extension: "",
    max_size: ""
  },
  media_upload: {
    title: ""
  },
  video: {
    problem: "",
    invalid_url: ""
  },
  submit: "",
  form: {
    tooltip_action_label: "",
    button_loading: ""
  }
};
const Editor = ({
  onInit,
  translations,
  configResponsiveImageHandler,
  children
}) => {
  useEffect(() => {
    onInit();
  }, []);
  return /* @__PURE__ */ jsx(EditorProvider, {
    translations: __spreadValues(__spreadValues({}, defaultTranslations), translations),
    configResponsiveImageHandler,
    children
  });
};
const editorPropTypes = {
  props: {
    onInit: PropTypes.func,
    configResponsiveImageHandler: PropTypes.shape({}),
    translations: PropTypes.shape()
  },
  defaultProps: {
    onInit: () => null,
    configResponsiveImageHandler: {},
    translations: {}
  }
};
Editor.propTypes = editorPropTypes.props;
Editor.defaultProps = editorPropTypes.defaultProps;
export { Controls, DraftDisplayer as Displayer, Editor, Playground, Title, editorPropTypes };
